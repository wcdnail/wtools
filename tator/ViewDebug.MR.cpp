/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include "stdafx.h"

#include <windows.h>
#include <stdarg.h>
#include <conio.h>

#undef LOBYTE
#undef LOWORD
#undef HIBYTE
#undef HIWORD

#include "IDA-defs.h"

//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_140001000(_BYTE *a1, __int64 a2, _QWORD *a3, _BYTE *a4, __int64 a5);
__int64 __fastcall sub_1400010D4(LPSTR lpDst); // idb
__int64 __fastcall sub_140001208(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_1400012F0(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
unsigned __int64 __fastcall sub_1400013E0(__int64 a1);
__int64 __fastcall sub_1400013F0(__int64 a1, __int16 *a2);
HBRUSH __fastcall DialogFunc(HWND a1, int a2, __int16 a3, const char *a4);
void *sub_1400015C0();
__int64 __fastcall sub_140001690(const char *a1, int *a2, __int64 a3);
_BOOL8 __fastcall sub_1400016E0(HKEY a1, const CHAR *a2);
_BOOL8 __fastcall sub_140001780(const char *a1);
__int64 __fastcall sub_140001830(int *a1, __int64 a2);
_BOOL8 sub_1400018B0();
_BOOL8 sub_140001970();
_BOOL8 sub_140001A10();
BOOL __fastcall sub_140001A40(HWND hWnd);
__int64 __fastcall sub_140001CF0(const char *dwInitParam, int *a2, __int64 a3);
__int64 sub_140001E00();
__noreturn void sub_140001E80();
__int64 __fastcall sub_140001EC0(const char *dwInitParam, int a2);
__int64 __fastcall sub_140002270(const char *dwInitParam, int *a2, __int64 a3);
__int64 __fastcall sub_1400023B0(const __m128i **a1, __m128i *a2, int a3, _DWORD *a4);
void *sub_140002420();
__int64 sub_140002430(__int64 a1, ...);
int sub_140002490(char *Buffer, char const *Format, ...);
__int64 sub_1400024F0(__int64 a1, ...);
__int64 sub_140002550(__int64 a1, ...);
char __fastcall sub_1400025B0(BYTE a1);
DWORD __fastcall sub_140002810(HWND hWnd, BYTE a2);
DWORD __fastcall sub_140002A40(HWND hWnd);
__int64 __fastcall sub_140002BF0(HWND hWnd, const char *a2);
INT_PTR __fastcall sub_140002CC0(HWND a1, unsigned int a2, HDC a3, HWND a4);
BOOL __fastcall sub_140002F30(HWND a1, unsigned int a2, unsigned int a3);
char __fastcall sub_140003540(HWND hwnd, char *String1);
_BOOL8 __fastcall sub_1400036E0(HWND a1, int a2);
char __fastcall sub_1400037E0(HWND hWnd);
int __fastcall sub_140003CF0(HWND hWnd, char *String2);
__int64 __fastcall sub_140004740(HWND hWnd, int a2, char *a3, char *a4);
__int64 __fastcall sub_140004B90(HWND hWnd, signed int a2, const struct sockaddr *a3);
__int64 __fastcall sub_140004CC0(HWND hWnd, signed int a2);
void __fastcall sub_140004E00(char *a1);
int __fastcall sub_140004E50(HWND hWnd);
int __fastcall sub_140005030(HWND hWnd, unsigned int a2, BOOL a3);
void __fastcall sub_140005300(void *a1);
__int64 __fastcall sub_140005320(const CHAR *a1, _DWORD *a2, _DWORD *a3);
char *__fastcall sub_1400053E0(char *Buffer);
__int64 __fastcall DBGView_RegisterWndClass(HINSTANCE a1);
HWND __fastcall DBGView_CreateWnd(HINSTANCE hInstance, int a2);
char __fastcall DGBView_StartListener_140005710(unsigned __int8 a1);
void __fastcall StartAddress(const CHAR *a1);
__int64 __fastcall DBGView_WndProc_140005B80(HWND hWnd, UINT Msg, WPARAM wParam, CHAR *lpString);
BOOL __fastcall sub_140007FC0(HWND a1);
char __fastcall sub_140008070(char *String1, _BYTE *a2);
int sub_140008730();
INT_PTR __fastcall sub_1400091E0(HWND a1, int a2, __int16 a3, const char *a4);
int __fastcall sub_140009390(unsigned int a1);
__int64 sub_140009410();
int __fastcall sub_140009460(HWND a1, char a2);
INT_PTR __fastcall sub_140009C50(HWND a1, int a2, __int16 a3, const CHAR *a4);
BOOL __fastcall sub_140009E50(HWND hWnd, unsigned int a2);
HBITMAP __fastcall sub_140009F60(HWND a1, void *a2);
int __fastcall sub_14000A080(HWND hWnd);
HWND __fastcall sub_14000A2C0(HWND hWnd, unsigned int a2);
BOOL __fastcall sub_14000A410(HWND a1, UINT a2, HICON a3, const CHAR *a4);
BOOL __fastcall sub_14000A4C0(HWND a1, UINT a2);
BOOL __fastcall sub_14000A540(HWND a1, UINT a2, HICON a3);
BOOL __fastcall DBGView_CloseListener(unsigned __int8 a1);
void __fastcall sub_14000A640(HWND hWnd, unsigned __int64 a2, unsigned int a3, int a4);
char sub_14000A930();
int __fastcall sub_14000A960(unsigned __int8 a1);
__int64 __fastcall sub_14000AC40(char *a1, __int64 a2, __int64 a3);
int __stdcall DBGVIEW_WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
BOOL sub_14000B220();
__int64 __fastcall sub_14000B4E0(HINSTANCE hInstance, char *Str, int a3);
INT_PTR __fastcall sub_14000B7B0(HWND a1, UINT a2, WPARAM a3, LPARAM a4);
__int64 sub_14000BFF0();
__int64 __fastcall sub_14000C060(HWND hDlg, int a2, __int16 a3, __int64 a4);
__int64 sub_14000C190();
void __fastcall sub_14000C210(HWND a1);
__int64 sub_14000CAB0();
char __fastcall sub_14000CB20(HANDLE hFile, __int64 a2, unsigned int a3, struct _OVERLAPPED *a4);
__int64 __fastcall sub_14000CBE0(LPCSTR lpName); // idb
char __fastcall sub_14000CCC0(LPCSTR lpName, char *FileName);
_BOOL8 __fastcall sub_14000CD70(const char *a1, const char *a2, char **a3);
__int64 __fastcall sub_14000D0D0(const char *a1, char **a2);
_BOOL8 __fastcall sub_14000D1C0(const char *a1);
_BOOL8 __fastcall sub_14000D370(HWND hDlg, int a2, HDC a3, HWND a4);
INT_PTR __fastcall sub_14000D5D0(HWND a1, unsigned int a2, HDC a3, HWND a4);
int __fastcall sub_14000E3A0(HWND hWnd, __int64 a2);
bool __fastcall sub_14000E6F0(_BYTE *a1);
__int64 __fastcall sub_14000E710(char *a1);
char __fastcall sub_14000E890(char *a1);
char __fastcall sub_14000EAC0(char *a1, char *a2);
__int64 __fastcall sub_14000EBB0(__int64 a1, __int64 a2, unsigned int a3);
int __fastcall sub_14000EC00(HWND hDlg, const char *a2);
BOOL __fastcall sub_14000EE30(HWND hWnd, unsigned int a2);
void *sub_14000EF20();
__int64 sub_14000EF30(__int64 a1, __int64 a2, ...);
int sub_14000EF80(char *Buffer, char *Format, ...);
SC_HANDLE __fastcall sub_14000EFE0(SC_HANDLE a1, const CHAR *a2, const CHAR *lpBinaryPathName);
__int64 __fastcall sub_14000F050(const CHAR *a1, const CHAR *a2, const CHAR *a3);
SC_HANDLE __fastcall sub_14000F100(SC_HANDLE a1, const CHAR *a2);
SC_HANDLE __fastcall sub_14000F150(SC_HANDLE hSCManager, LPCSTR lpServiceName);
SC_HANDLE __fastcall sub_14000F270(SC_HANDLE a1, const CHAR *a2);
__int64 __fastcall sub_14000F320(const CHAR *a1, const CHAR *a2);
LRESULT __fastcall sub_14000F370(HWND hWnd, UINT Msg, WPARAM wParam, const __m128i *lParam);
__int64 __fastcall sub_14000F740(HWND hWnd, unsigned int a2);
__int64 __fastcall sub_14000F890(HDC hdc, char *Source, int a3, int a4);
int __fastcall sub_14000FB00(HWND a1);
HWND __fastcall sub_14000FDA0(HWND hWndParent);
BOOL __fastcall sub_14000FFD0(HDC a1, const CHAR *a2, const RECT *a3);
int __fastcall sub_140010090(__int64 a1);
char __fastcall sub_140010340(HWND a1, __int64 a2);
INT_PTR __fastcall sub_140010800(HWND a1, int a2, __int16 a3);
INT_PTR __fastcall sub_140010940(HWND a1, int a2, int a3);
__int64 __fastcall sub_140010B40(HWND hWnd, unsigned int a2, unsigned int a3, FILETIME a4, __int64 a5, char *a6);
LRESULT __fastcall sub_140011350(HWND a1, UINT a2, HWND a3, LPARAM a4);
int __fastcall sub_140011780(HWND hWnd);
__int64 __fastcall sub_140011890(const char *a1, char a2, const char **a3);
INT_PTR __fastcall sub_140011900(HWND a1, int a2, __int16 a3);
__int64 __fastcall sub_140011E80(HWND a1);
int __fastcall sub_140012130(HWND a1, unsigned int a2, HWND a3, const char *a4);
INT_PTR __fastcall sub_140012770(HWND a1, int a2, unsigned __int16 a3);
int __fastcall sub_140012BF0(HWND hWndParent, char a2);
bool __fastcall proc(HDC a1, int a2);
INT_PTR __fastcall sub_140013040(HWND a1, int a2, __int16 a3);
int __fastcall sub_1400130D0(HWND a1, __int64 a2);
INT_PTR __fastcall sub_140013850(HWND a1, int a2, __int16 a3, __int64 a4);
void __fastcall sub_140013B10(__int64 a1);
int __fastcall sub_140013B40(HWND a1, char *a2, HWND a3, char a4);
void __fastcall CompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);
BOOL __fastcall sub_140013E70(HWND hWnd, unsigned int a2, void *a3, DWORD a4, LPDWORD lpNumberOfBytesRead, char a6, DWORD dwMilliseconds);
__int64 __fastcall sub_140014040(HWND hWnd, unsigned int a2, const void *a3, DWORD a4, LPDWORD lpNumberOfBytesWritten, char a6, char a7);
DWORD __fastcall sub_140014250(int a1, int a2);
__noreturn void __fastcall sub_140014290(void *a1);
void __fastcall sub_1400142C0(unsigned int *Block);
// int __stdcall closesocket(SOCKET s);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// u_short __stdcall htons(u_short hostshort);
// unsigned int __stdcall inet_addr(const char *cp);
// SOCKET __stdcall socket(int af, int type, int protocol);
// struct hostent *__stdcall gethostbyaddr(const char *addr, int len, int type);
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall WSAGetLastError();
// SOCKET __stdcall accept(SOCKET s, struct sockaddr *addr, int *addrlen);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall getsockname(SOCKET s, struct sockaddr *name, int *namelen);
// u_long __stdcall htonl(u_long hostlong);
// char *__stdcall inet_ntoa(struct in_addr in);
// int __stdcall listen(SOCKET s, int backlog);
// DWORD __stdcall WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags);
// DWORD __stdcall WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce);
// BOOL __stdcall ConvertStringSecurityDescriptorToSecurityDescriptorA(LPCSTR StringSecurityDescriptor, DWORD StringSDRevision, PSECURITY_DESCRIPTOR *SecurityDescriptor, PULONG SecurityDescriptorSize);
// void __fastcall __noreturn _report_rangecheckfailure(_QWORD); weak
void sub_140015680();
__int64 __fastcall UserMathErrorFunction(struct _exception *a1);
__int64 sub_140015CDC();
__int64 sub_140015CE8();
__int64 sub_140015CEC();
void sub_140015CF0();
__int64 sub_140015D00();
char sub_140015D0C();
void *sub_140015D40();
void *sub_140015D48();
void sub_140015D50();
__int64 sub_140015EE8();
__int64 sub_140015F50();
void sub_140015F8C();
void __fastcall sub_140015FC8();
__int64 __fastcall sub_140016008(__int64 a1);
__int64 __fastcall sub_14001600C(__int64 a1);
__int64 __fastcall sub_1400161D0(void *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_1400161F0(__m128i *a1, const __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_140016630(void *a1, char a2, unsigned __int64 a3);
__int64 __fastcall sub_140016650(__int64 a1, unsigned __int8 a2, unsigned __int64 a3);
// char *__cdecl strchr(const char *Str, int Val);
// char *__cdecl strrchr(const char *Str, int Ch);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// __vcrt_bool __cdecl _vcrt_uninitialize(__vcrt_bool Terminating);
void __cdecl j_j__free_base(void *Block);
void *__cdecl j_j__malloc_base(size_t Size);
void __fastcall sub_140016E64(__int64 a1, void *a2);
void __fastcall sub_140016E6C(__int64 a1, void *a2);
__int64 __fastcall sub_140016E80(__int64 a1);
void (__cdecl *sub_140016ECC())(void *Block);
void *(__cdecl *sub_140016ED4())(size_t Size);
void __fastcall sub_140016EEC(__int64 a1, void *a2);
void *__fastcall sub_140016EF4(__int64 a1, size_t a2);
__int64 __fastcall sub_140016EFC(__int64 a1);
__int64 __fastcall sub_140016F08(__int64 a1);
__int64 __fastcall sub_140016F0C(__int64 a1);
// __int64 __fastcall _std_type_info_destroy_list(_QWORD); weak
// __int64 __fastcall NLG_Notify(_QWORD, _QWORD, _QWORD); weak
// __int64 _NLG_Return2(void); weak
__int64 __fastcall sub_1400172A8(__int64 a1);
void __fastcall sub_1400172E0(__int64 a1);
void __noreturn sub_1400173F0();
void __fastcall sub_1400174A4(__int64 a1, void *a2);
void __fastcall sub_1400174EC(DWORD *a1);
__int64 __fastcall sub_140017508(__int64 a1);
void __fastcall sub_1400177CC(int a1);
void __fastcall sub_140017820(int a1);
uintptr_t sub_14001783C();
__int64 __fastcall sub_140017894(__int64 a1);
__int64 __fastcall sub_140017898(__int64 a1);
__int64 sub_140017908();
__int64 sub_140017928();
// __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD); weak
uintptr_t sub_1400180E8();
// __int64 __fastcall unknown_libname_18(_QWORD); weak
_QWORD *__fastcall sub_140018468(_QWORD *a1);
void *__fastcall sub_1400185C4(unsigned __int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140018730(__int64 a1, __int64 a2, __int64 a3);
// __int64 __fastcall DName::operator+(_QWORD, _QWORD, _QWORD); weak
char __fastcall sub_14001C040(__int64 a1);
// void *__fastcall _HeapManager::getMemory(_HeapManager *__hidden this, unsigned __int64, int); idb
__int64 __fastcall sub_14001EE14(__int64 a1);
__int64 __fastcall sub_14001EE9C(__int64 a1);
__int64 __fastcall sub_14001F398(__int64 a1);
__int64 __fastcall sub_14001F620(__int64 a1);
__int64 __fastcall sub_14001F624(__int64 a1);
_QWORD *__fastcall sub_14001F97C(_QWORD *a1, ULONG64 *a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_14001FF98(__int64 a1);
__int64 __fastcall sub_14002033C(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_140020364(_QWORD *a1, ULONG64 *a2, __int64 a3);
__int64 __fastcall sub_14002039C(_QWORD *a1, ULONG64 *a2, __int64 a3, int a4);
__int64 __fastcall sub_1400203D8(__int64 a1, _QWORD *a2);
// __int64 __fastcall unknown_libname_42(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140020540(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140022274(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_1400222B4(_QWORD *a1);
__int64 __fastcall sub_140022440(__int64 a1);
// void __fastcall __FrameHandler4::HandlerMap::DecompHandler(__FrameHandler4::HandlerMap *__hidden this); idb
__int64 __fastcall sub_1400230E0(__int64 a1, __int64 a2);
__int64 sub_140023414();
__int64 sub_140023484();
__int64 __fastcall sub_140023494(unsigned int *a1);
//void __fastcall sub_140023610(__FrameHandler4::HandlerMap *a1);
__int64 __fastcall sub_1400236F0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
void __fastcall sub_140023738(__int64 a1, void *a2);
__int64 __fastcall sub_140023774(__int64 a1);
// __int64 __fastcall _std_exception_copy(_QWORD); weak
__int64 __fastcall sub_140023914(unsigned int *a1);
// _LocaleUpdate *__fastcall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const); idb
__int64 __fastcall sub_1400239C4(unsigned int *a1);
// int __cdecl wcsicmp(const wchar_t *String1, const wchar_t *String2);
// int __cdecl stricmp(const char *String1, const char *String2);
void __cdecl j__free_base(void *Block);
void *__cdecl j__malloc_base(size_t Size);
bool __fastcall sub_140023D4C(HMODULE a1);
__int64 __fastcall sub_140023F18(__int64 a1);
__int64 __fastcall sub_140023F1C(__int64 a1);
void __fastcall sub_140024018(__int64 a1);
__int64 sub_14002404C();
// void __cdecl __noreturn exit(int Code);
void __fastcall sub_1400240B0(__int64 a1, void *a2);
__int64 __fastcall sub_1400240E4(__int64 a1);
// FILE *__cdecl _acrt_iob_func(unsigned int Ix);
void __fastcall sub_1400242E4(__int64 a1);
void __fastcall sub_1400242F0(__int64 a1);
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140024B34(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024B5C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024B84(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024BAC(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024BD4(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024BFC(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024C24(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_140024CAC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_140024D34(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_140024DBC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_140024E44(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_140024ECC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_1400251F0(int a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, struct __crt_locale_pointers *a5, __int64 a6);
__int64 __fastcall sub_140025398(int a1, _WORD *a2, unsigned __int64 a3, __int64 a4, struct __crt_locale_pointers *a5, __int64 a6);
__int64 __fastcall sub_1400258A8(int a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, struct __crt_locale_pointers *a5, __int64 a6);
__int64 __fastcall sub_140025A50(int a1, _WORD *a2, unsigned __int64 a3, __int64 a4, struct __crt_locale_pointers *a5, __int64 a6);
// __int64 __fastcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_QWORD, _QWORD); weak
char __fastcall sub_140025DC0(__int64 a1, _QWORD *a2);
char __fastcall sub_140025E84(__int64 a1, _QWORD *a2);
char __fastcall sub_140025F48(__int64 a1, _QWORD *a2);
char __fastcall sub_140026010(__int64 a1, _QWORD *a2);
char __fastcall sub_140026128(__int64 a1, _QWORD *a2);
char __fastcall sub_1400261EC(__int64 a1, _QWORD *a2);
char __fastcall sub_1400262B0(__int64 a1, _QWORD *a2);
char __fastcall sub_140026374(__int64 a1, _QWORD *a2);
char __fastcall sub_140026488(__int64 a1, _QWORD *a2);
char __fastcall sub_14002654C(__int64 a1, _QWORD *a2);
char __fastcall sub_140026610(__int64 a1, _QWORD *a2);
char __fastcall sub_1400266D8(__int64 a1, _QWORD *a2);
char __fastcall sub_1400267F0(__int64 a1, _BYTE *a2);
char __fastcall sub_1400268B0(__int64 a1, _BYTE *a2);
char __fastcall sub_140026998(__int64 a1, _QWORD *a2);
char __fastcall sub_140026A5C(__int64 a1, _QWORD *a2);
char __fastcall sub_140026B20(__int64 a1, _QWORD *a2);
char __fastcall sub_140026BE4(__int64 a1, _QWORD *a2);
char __fastcall sub_140026CF8(__int64 a1, _QWORD *a2);
char __fastcall sub_140026DBC(__int64 a1, _QWORD *a2);
char __fastcall sub_140026E80(__int64 a1, _QWORD *a2);
char __fastcall sub_140026F44(__int64 a1, _QWORD *a2);
char __fastcall sub_140027058(__int64 a1, _QWORD *a2);
char __fastcall sub_140027118(__int64 a1, _QWORD *a2);
char __fastcall sub_1400271D8(__int64 a1, _QWORD *a2);
char __fastcall sub_14002729C(__int64 a1, _QWORD *a2);
// __int64 __fastcall unknown_libname_300(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_301(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_302(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_303(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_309(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_313(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_317(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_321(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_324(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_325(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_326(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_327(_QWORD, _QWORD); weak
char __fastcall sub_140027E70(__int64 a1, _QWORD *a2);
char __fastcall sub_140027F38(__int64 a1, _QWORD *a2);
char __fastcall sub_140028000(__int64 a1, _QWORD *a2);
char __fastcall sub_1400280C8(__int64 a1, _QWORD *a2);
// __int64 __fastcall unknown_libname_336(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_337(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_338(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_339(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_344(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_345(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_346(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_347(_QWORD, _QWORD); weak
char __fastcall sub_1400288B0(__int64 a1, _WORD *a2);
char __fastcall sub_140028974(__int64 a1, _WORD *a2);
char __fastcall sub_140028A38(__int64 a1, _WORD *a2);
char __fastcall sub_140028B00(__int64 a1, _WORD *a2);
__int64 sub_140028C18();
__int64 sub_140028C20();
__int64 sub_140028C28();
__int64 sub_140028C30();
__int64 sub_140028C38();
__int64 sub_140028C40();
__int64 sub_140028C48();
__int64 sub_140028C50();
__int64 sub_140028C58();
__int64 sub_140028C60();
__int64 sub_140028C68();
__int64 sub_140028C70();
// __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<char>(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<wchar_t>(_QWORD, _QWORD, _QWORD); weak
char __fastcall sub_140028E1C(__int64 a1);
char __fastcall sub_140028E20(__int64 a1);
__int64 __fastcall sub_140028E2C(unsigned int *a1);
__int64 __fastcall sub_140028E30(unsigned int *a1);
__int64 __fastcall sub_140028E34(__int64 a1);
__int64 __fastcall sub_140028E38(__int64 a1);
__int64 __fastcall sub_140028E3C(__int64 a1);
__int64 __fastcall sub_140028E40(__int64 a1);
__int64 __fastcall sub_140028E44(__int64 a1);
__int64 __fastcall sub_140028E48(__int64 a1);
__int64 __fastcall sub_140028E4C(__int64 a1);
__int64 __fastcall sub_140028E50(__int64 a1);
__int64 __fastcall sub_140028E54(__int64 a1);
int __fastcall sub_140028FD4(const char **a1, char ***a2, int *a3);
int __fastcall sub_140028FE4(const wchar_t **a1, wchar_t ***a2, int *a3);
int __fastcall sub_140028FF4(const char **a1, char ***a2, int *a3);
int __fastcall sub_140029004(const wchar_t **a1, wchar_t ***a2, int *a3);
// __int64 __fastcall unknown_libname_395(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_396(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_397(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_398(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_399(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_400(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_401(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_402(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_403(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_404(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_405(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_406(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_407(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_408(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_409(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_410(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_411(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_412(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_413(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_414(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_415(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_416(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_417(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_418(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_432(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); weak
// __int64 __fastcall unknown_libname_434(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); weak
// __int64 __fastcall unknown_libname_438(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); weak
// __int64 __fastcall unknown_libname_440(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); weak
__int64 __fastcall sub_14002AEFC(__int64 *a1);
void __fastcall sub_14002B064(__int64 *a1);
void __fastcall sub_14002B06C(__int64 *a1);
void __fastcall sub_14002B074(__int64 *a1);
void __fastcall sub_14002B07C(__int64 *a1);
void __fastcall sub_14002B084(__int64 *a1);
void __fastcall sub_14002B17C(__int64 *a1);
void __fastcall sub_14002B274(__int64 *a1);
void __fastcall sub_14002B36C(__int64 *a1);
void __fastcall sub_14002B464(__int64 *a1);
void __fastcall sub_14002B46C(__int64 *a1);
void __fastcall sub_14002B474(__int64 *a1);
void __fastcall sub_14002B56C(__int64 *a1);
// void __fastcall __crt_stdio_output::force_decimal_point(__crt_stdio_output *__hidden this, char *, struct __crt_locale_pointers *const); idb
__int64 sub_14002BAF0();
__int64 sub_14002BB30();
__int64 sub_14002BB70();
__int64 sub_14002BBB0();
// __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
const char *sub_14002C430();
const char *sub_14002C438();
const char *sub_14002C440();
const char *sub_14002C448();
const char *sub_14002C450();
const char *sub_14002C458();
const char *sub_14002C460();
const char *sub_14002C468();
const char *sub_14002C470();
const char *sub_14002C478();
const char *sub_14002C480();
const char *sub_14002C488();
// __int64 __fastcall unknown_libname_508(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_509(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_511(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_512(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_514(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_517(_QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::format_validation_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(_QWORD); weak
// __int64 __fastcall __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::standard_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(_QWORD); weak
__int64 __fastcall sub_14002DAA4(__int64 a1);
// __int64 __fastcall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::format_validation_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(_QWORD); weak
__int64 __fastcall sub_14002E258(__int64 a1);
// __int64 __fastcall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::standard_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(_QWORD); weak
__int64 __fastcall sub_14002E788(__int64 a1);
char sub_14002E81C();
char sub_14002E820();
char sub_14002E824();
char sub_14002E828();
char __fastcall sub_14002EC74(__int64 a1);
char __fastcall sub_14002ED7C(__int64 a1);
char __fastcall sub_14002EDEC(__int64 a1);
char __fastcall sub_14002EEFC(__int64 a1);
// __int64 __fastcall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::stream_output_adapter<wchar_t>,__crt_stdio_output::positional_parameter_base<wchar_t,__crt_stdio_output::stream_output_adapter<wchar_t>>>::state_case_normal(_QWORD); weak
// __int64 __fastcall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::positional_parameter_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_normal(_QWORD); weak
char __fastcall sub_14002F1BC(__int64 a1);
char __fastcall sub_14002F218(__int64 a1);
char __fastcall sub_14002F274(__int64 a1);
char __fastcall sub_14002F2D0(__int64 a1);
char __fastcall sub_14002F330(__int64 a1);
char __fastcall sub_14002F390(__int64 a1);
// __int64 __fastcall unknown_libname_553(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_554(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_555(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_556(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_557(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_558(_QWORD, _QWORD); weak
char __fastcall sub_14002F978(__int64 a1);
char __fastcall sub_14002F980(__int64 a1);
char __fastcall sub_14002F988(__int64 a1);
char __fastcall sub_14002F990(__int64 a1);
char __fastcall sub_14002F998(__int64 a1);
char __fastcall sub_14002F9A0(__int64 a1);
char __fastcall sub_14002FAF8(__int64 a1);
char __fastcall sub_14002FBA4(__int64 a1);
char __fastcall sub_14002FC50(__int64 a1);
char __fastcall sub_14002FCFC(__int64 a1);
char __fastcall sub_14002FD78(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14002FEF4(__int64 a1);
char __fastcall sub_140030070(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400301EC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140030368(__int64 a1);
char __fastcall sub_1400304E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140030660(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140030804(__int64 a1);
char __fastcall sub_1400309A8(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140030B4C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140030CF0(__int64 a1);
char __fastcall sub_140030E94(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140031038(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400312B4(__int64 a1);
char __fastcall sub_140031544(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400317C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140031A3C(__int64 a1);
char __fastcall sub_140031CCC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140031F48(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140032214(__int64 a1);
char __fastcall sub_1400324F4(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400327C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140032A8C(__int64 a1);
char __fastcall sub_140032D6C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140033068(__int64 a1);
char __fastcall sub_1400330B8(__int64 a1);
char __fastcall sub_140033118(__int64 a1);
char __fastcall sub_140033168(__int64 a1);
char __fastcall sub_1400331C8(__int64 a1);
char __fastcall sub_14003327C(__int64 a1);
__int64 sub_140033300();
__int64 sub_140033308();
__int64 sub_140033310();
__int64 sub_140033318();
__int64 sub_140033320();
__int64 sub_140033328();
__int64 sub_140033330();
__int64 sub_140033338();
void *sub_140033340();
void *sub_140033348();
void *sub_140033350();
void *sub_140033358();
void *sub_140033360();
void *sub_140033368();
void *sub_140033370();
void *sub_140033378();
char __fastcall sub_1400333CC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400333DC(__int64 a1);
char __fastcall sub_1400333EC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400333FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14003340C(__int64 a1);
char __fastcall sub_14003341C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14003342C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14003343C(__int64 a1);
char __fastcall sub_14003344C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14003345C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14003346C(__int64 a1);
char __fastcall sub_14003347C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// __int64 unknown_libname_571(void); weak
char __fastcall sub_14003350C(__int64 a1);
// __int64 unknown_libname_572(void); weak
// __int64 unknown_libname_573(void); weak
char __fastcall sub_1400336A8(__int64 a1);
// __int64 unknown_libname_574(void); weak
// __int64 unknown_libname_575(void); weak
char __fastcall sub_140033844(__int64 a1);
// __int64 unknown_libname_576(void); weak
// __int64 unknown_libname_577(void); weak
char __fastcall sub_1400339E4(__int64 a1);
// __int64 unknown_libname_578(void); weak
// __int64 unknown_libname_579(void); weak
char __fastcall sub_140033D20(__int64 a1);
// __int64 unknown_libname_580(void); weak
// __int64 unknown_libname_581(void); weak
char __fastcall sub_1400343A4(__int64 a1);
// __int64 unknown_libname_582(void); weak
// __int64 unknown_libname_583(void); weak
char __fastcall sub_140034A50(__int64 a1);
// __int64 unknown_libname_584(void); weak
// __int64 unknown_libname_585(void); weak
char __fastcall sub_140035148(__int64 a1);
// __int64 unknown_libname_586(void); weak
// __int64 __fastcall unknown_libname_587(_QWORD, _QWORD); weak
char __fastcall sub_140035710(__int64 a1, __int64 a2);
// __int64 __fastcall unknown_libname_588(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_589(_QWORD, _QWORD); weak
char __fastcall sub_140035970(__int64 a1, __int64 a2);
// __int64 __fastcall unknown_libname_590(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_591(_QWORD, _QWORD); weak
char __fastcall sub_140035BC4(__int64 a1);
// __int64 __fastcall unknown_libname_592(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_593(_QWORD, _QWORD); weak
char __fastcall sub_140035DE0(__int64 a1);
// __int64 __fastcall unknown_libname_594(_QWORD, _QWORD); weak
char __fastcall sub_140036014(__int64 a1, unsigned int a2, char a3, __int64 a4);
char __fastcall sub_1400361B4(__int64 a1, unsigned int a2, char a3);
char __fastcall sub_1400363B8(__int64 a1, unsigned int a2, char a3, __int64 a4);
char __fastcall sub_140036558(__int64 a1, unsigned int a2, char a3, __int64 a4);
char __fastcall sub_1400366F8(__int64 a1, unsigned int a2, char a3);
char __fastcall sub_1400368FC(__int64 a1, unsigned int a2, char a3, __int64 a4);
char __fastcall sub_140036A9C(__int64 a1, unsigned int a2, char a3, __int64 a4);
char __fastcall sub_140036C3C(__int64 a1, unsigned int a2, char a3);
char __fastcall sub_140036E40(__int64 a1, unsigned int a2, char a3, __int64 a4);
char __fastcall sub_140036FE0(__int64 a1, unsigned int a2, char a3, __int64 a4);
char __fastcall sub_140037180(__int64 a1, unsigned int a2, char a3);
char __fastcall sub_140037384(__int64 a1, unsigned int a2, char a3, __int64 a4);
// __int64 unknown_libname_595(void); weak
char __fastcall sub_140037600(__int64 a1);
// __int64 unknown_libname_596(void); weak
// __int64 unknown_libname_597(void); weak
char __fastcall sub_1400378BC(__int64 a1);
// __int64 unknown_libname_598(void); weak
// __int64 unknown_libname_599(void); weak
char __fastcall sub_140037B78(__int64 a1);
// __int64 unknown_libname_600(void); weak
// __int64 unknown_libname_601(void); weak
char __fastcall sub_140037E34(__int64 a1);
// __int64 unknown_libname_602(void); weak
char __fastcall sub_140038194(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400381AC(__int64 a1);
char __fastcall sub_1400381C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400381DC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400381F4(__int64 a1);
char __fastcall sub_14003820C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140038224(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14003823C(__int64 a1);
char __fastcall sub_140038254(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14003826C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140038284(__int64 a1);
char __fastcall sub_14003829C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// __int64 unknown_libname_603(void); weak
char __fastcall sub_140038344(__int64 a1);
// __int64 unknown_libname_604(void); weak
// __int64 unknown_libname_605(void); weak
char __fastcall sub_14003850C(__int64 a1);
// __int64 unknown_libname_606(void); weak
// __int64 unknown_libname_607(void); weak
char __fastcall sub_14003870C(__int64 a1);
// __int64 unknown_libname_608(void); weak
// __int64 unknown_libname_609(void); weak
char __fastcall sub_14003897C(__int64 a1);
// __int64 unknown_libname_610(void); weak
char __fastcall sub_140038E84(__int64 a1);
char __fastcall sub_140038F98(__int64 a1);
char __fastcall sub_1400390AC(__int64 a1);
char __fastcall sub_1400391C4(__int64 a1);
char __fastcall sub_14003932C(__int64 a1);
char __fastcall sub_140039440(__int64 a1);
char __fastcall sub_140039554(__int64 a1);
char __fastcall sub_14003966C(__int64 a1);
char __fastcall sub_140039884(int a1, __int64 a2, int a3, char a4, int a5);
char __fastcall sub_1400398C4(int a1, __int64 a2, int a3, char a4, int a5);
char __fastcall sub_140039904(int a1, __int64 a2, int a3, __int16 a4, int a5);
char __fastcall sub_140039944(int a1, __int64 a2, int a3, __int16 a4, int a5);
// __int64 __fastcall unknown_libname_638(_QWORD); weak
// __int64 __fastcall unknown_libname_639(_QWORD); weak
char sub_140039DAC();
char sub_140039DB0();
char sub_140039DB4();
char sub_140039DB8();
// __int64 __fastcall unknown_libname_646(_QWORD); weak
// __int64 __fastcall unknown_libname_647(_QWORD); weak
char sub_14003A09C();
char sub_14003A0A0();
char sub_14003A0A4();
char sub_14003A0A8();
char __fastcall sub_14003A0AC(__int64 a1);
char __fastcall sub_14003A148(__int64 a1);
char __fastcall sub_14003A1E4(__int64 a1);
char __fastcall sub_14003A284(__int64 a1);
char sub_14003A324();
char sub_14003A328();
char sub_14003A32C();
char sub_14003A330();
char sub_14003A3C0();
const wchar_t *sub_14003A3C4();
const wchar_t *sub_14003A3CC();
const wchar_t *sub_14003A3D4();
const wchar_t *sub_14003A3DC();
const wchar_t *sub_14003A3E4();
const wchar_t *sub_14003A3EC();
const wchar_t *sub_14003A3F4();
const wchar_t *sub_14003A3FC();
const wchar_t *sub_14003A404();
const wchar_t *sub_14003A40C();
const wchar_t *sub_14003A414();
const wchar_t *sub_14003A41C();
// __int64 __fastcall unknown_libname_650(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_651(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_652(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_653(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_654(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_655(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_656(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_657(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_658(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_659(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_660(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_661(_QWORD, _QWORD); weak
// __int64 __fastcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
// __int64 __fastcall __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
// __int64 __fastcall __crt_stdio_output::string_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
// __int64 __fastcall __crt_stdio_output::string_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
__int64 __fastcall sub_14003B384(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14003B410(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14003B49C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14003B528(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14003B5B4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14003B640(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
// int __cdecl _stdio_common_vsprintf(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
__int64 __fastcall sub_14003C374(__int64 a1);
// int __cdecl getch();
__int64 __fastcall sub_14003C864(__int64 a1);
// int __cdecl isdigit(int C);
// int __cdecl isspace(int C);
__int64 __fastcall sub_14003D760(int a1);
__int64 __fastcall sub_14003D8A4(int a1);
// int __cdecl toupper(int C);
// int __cdecl strnicmp(const char *String1, const char *String2, size_t MaxCount);
__int64 __fastcall sub_14003DE1C(__int64 a1);
// char *__cdecl strupr(char *String);
// __int64 __fastcall unknown_libname_664(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_665(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(struct __crt_locale_pointers *); idb
// __int64 __fastcall __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<wchar_t>>(struct __crt_locale_pointers *); idb
// __int64 __fastcall __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<char>>(struct __crt_locale_pointers *); idb
// __int64 __fastcall __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(struct __crt_locale_pointers *); idb
__int64 __fastcall sub_14003F450(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14003F48C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14003F4C8(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14003F504(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
char __fastcall sub_14003F840(_QWORD *a1, __int64 a2);
char __fastcall sub_14003F848(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14003F850(__int64 a1);
__int64 __fastcall sub_14003F854(__int64 a1);
__int64 __fastcall sub_14003FA94(__int64 a1);
__int64 __fastcall sub_14003FBE8(__int64 a1, struct __crt_locale_pointers *a2);
__int64 __fastcall sub_14003FC1C(__int64 a1, struct __crt_locale_pointers *a2);
__int64 __fastcall sub_14003FC7C(__int64 a1, struct __crt_locale_pointers *a2);
__int64 __fastcall sub_14003FCDC(__int64 a1, struct __crt_locale_pointers *a2);
__int64 __fastcall sub_14003FD10(__int64 a1);
__int64 __fastcall sub_14003FD3C(__int64 a1);
__int64 __fastcall sub_14003FD68(__int64 a1);
// int __cdecl fclose(FILE *Stream);
// __int64 __fastcall common_fsopen<wchar_t>(wchar_t *FileName); idb
__int64 __fastcall sub_1400400F0(char **a1);
__int64 __fastcall sub_140040104(wchar_t **a1);
void __fastcall sub_140040118(__int64 *a1);
__int64 __fastcall sub_140040128(wchar_t *a1);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
void __fastcall sub_140040624(__int64 a1, void *a2);
__int64 __fastcall sub_1400408C0(__int64 a1);
// uintptr_t __cdecl beginthread(_beginthread_proc_type StartAddress, unsigned int StackSize, void *ArgList);
// uintptr_t __cdecl beginthreadex(void *Security, unsigned int StackSize, _beginthreadex_proc_type StartAddress, void *ArgList, unsigned int InitFlag, unsigned int *ThrdAddr);
// __int64 __fastcall __crt_seh_guarded_call<unsigned __int64>::operator()<_lambda_5d4c3fee44080f75d5d9762853974fe0_,_lambda_532e024f4337e6fc7ad266c2bef9f4ed_ &,_lambda_c87bdc10097eb2402edb8ba9bdf0697b_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140040B88(__int64 a1, __int64 a2);
void __fastcall sub_140040C44(__int64 *a1);
void __fastcall sub_140040C4C(__int64 *a1);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
int __fastcall sub_1400411B8(FILE **a1);
wint_t __fastcall sub_1400411C0(FILE **a1);
//__int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD); // weak
void __fastcall sub_1400411D8(__int64 a1, void *a2);
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140041260(__int64 a1, __int64 a2);
__int64 __fastcall sub_140041288(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400413D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_140041458(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
unsigned __int64 __fastcall sub_140049E3C(const wchar_t **a1, wchar_t ***a2, int *a3);
unsigned __int64 __fastcall sub_140049E4C(const char **a1, char ***a2, int *a3);
int __fastcall sub_140049E68(int *a1, FILE **a2);
void __fastcall sub_14004A7F8(__int64 *a1);
void __fastcall sub_14004ABF0(__int64 *a1);
void __fastcall sub_14004ABF8(__int64 *a1);
void __fastcall sub_14004AC78(__int64 *a1);
__int64 __fastcall sub_14004DD64(__int64 a1);
__int64 __fastcall sub_14004E2A0(__int64 a1);
__int64 __fastcall sub_14004E2A4(__int64 a1);
__int64 __fastcall sub_14004E2B8(__int64 a1);
char __fastcall sub_14004E664(__int64 a1);
__int64 __fastcall sub_14004E6F0(__int64 a1);
__int64 __fastcall sub_14004E6F4(__int64 a1);
char __fastcall sub_14004E830(__int64 a1);
char __fastcall sub_14004E83C(__int64 a1);
__int64 __fastcall sub_14004E88C(__int64 a1);
__int64 __fastcall sub_14004E890(__int64 a1);
char sub_140050258();
char sub_14005025C();
char sub_1400513E4();
char __fastcall sub_140051B1C(__int64 a1);
char __fastcall sub_140051B20(__int64 a1);
__int64 __fastcall sub_140052478(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140052504(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
// int __cdecl _stdio_common_vsscanf(unsigned __int64 Options, const char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// char *__cdecl strdup(const char *Source);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// int __cdecl fflush(FILE *Stream);
// int __cdecl fgetpos(FILE *Stream, fpos_t *Position);
// int __cdecl fsetpos(FILE *Stream, const fpos_t *Position);
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140052D24(__int64 a1, __int64 a2);
void __fastcall sub_140052D7C(__int64 *a1);
void __fastcall sub_140052D84(__int64 *a1);
// int __cdecl setvbuf(FILE *Stream, char *Buffer, int Mode, size_t Size);
__int64 sub_1400533AC();
void __fastcall sub_1400533B4(int a1);
__int64 __fastcall sub_14005342C(__int64 a1);
void __fastcall sub_140053450(__int64 a1);
void __fastcall sub_1400534C8(__int64 a1, void *a2);
void __fastcall sub_1400534D0(__int64 a1, void *a2);
__int64 __fastcall sub_140053B20(__int64 *a1);
__int64 __fastcall sub_140053B2C(__int64 *a1);
__int64 __fastcall sub_140053BFC(__int64 a1);
__int64 __fastcall sub_140053C00(__int64 a1);
__int64 __fastcall sub_140053C04(__int64 a1);
__int64 __fastcall sub_140053C08(__int64 a1);
void **sub_140053C0C();
void **sub_140053C14();
__int64 sub_140053C1C();
__int64 sub_140053C24();
void __fastcall sub_140053FD0(__int64 a1);
void __fastcall sub_140053FD8(__int64 a1);
void __fastcall sub_140053FE0(__int64 a1, void *a2);
void *sub_140054030();
void *sub_140054078();
// __int64 common_initialize_environment_nolock<char>(void); weak
// __int64 common_initialize_environment_nolock<wchar_t>(void); weak
// __int64 __fastcall unknown_libname_785(void *Block); idb
// __int64 __fastcall unknown_libname_786(void *Block); idb
// __int64 initialize_environment_by_cloning_nolock<char>(void); weak
// __int64 initialize_environment_by_cloning_nolock<wchar_t>(void); weak
__int64 __fastcall sub_140054608(char **a1);
__int64 __fastcall sub_140054614(wchar_t **a1);
errno_t __fastcall sub_140054620(char **a1, rsize_t *a2, const char **a3);
errno_t __fastcall sub_140054630(wchar_t **a1, rsize_t *a2, const wchar_t **a3);
__int64 __fastcall sub_1400546F8(void **a1);
__int64 __fastcall sub_140054714(void **a1);
__int64 __fastcall sub_14005482C(__int64 a1);
void **sub_140054830();
void **sub_140054838();
void **sub_140054840();
void **sub_140054848();
void **sub_140054850();
void **sub_140054858();
__int64 __fastcall sub_140054914(__int64 a1);
__int64 __fastcall sub_140054918(__int64 a1);
void **sub_140054964();
void **sub_14005496C();
__int64 sub_140054A98();
__int64 sub_140054AA0();
__int64 __fastcall sub_140054C48(unsigned int *a1);
__int64 __fastcall sub_140054C4C(_DWORD *a1);
__int64 sub_140054E94();
void __fastcall sub_140054E98(__int64 a1, void *a2);
void __fastcall sub_140054EA0(__int64 a1, void *a2);
void __fastcall sub_140054EA8(__int64 a1, void *a2);
// __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_3e0436e1742da57cd73032a8c01babf8_,_lambda_b7fb1a997d3ebc0cc0186c5835178808_ &,_lambda_eece23d6871d1810c6784d81edd5a05e_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_d67e8342c384adda8f857579ab50b2ae_,_lambda_30712929f77e709619002f448b6a9510_ &,_lambda_4525336fd7e478d965fb7ca7a337cad8_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_ede63489d7330338e618311e15f0c366_,_lambda_176e34f99554166dd2fac165c457248c_ &,_lambda_b0463272cb7667df9361a74a62ea8ca5_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14005509C(int a1, __int64 a2);
__int64 __fastcall sub_1400550C4(int a1, __int64 a2);
__int64 __fastcall sub_1400550EC(int a1, __int64 a2);
void __fastcall sub_140055260(__int64 a1);
void __fastcall sub_140055410(int *a1);
void __fastcall sub_140055418(int *a1);
void __fastcall sub_140055424(int *a1);
void __fastcall sub_14005543C(int *a1);
void __fastcall sub_140055444(int *a1);
void __fastcall sub_14005544C(int *a1);
__int64 __fastcall sub_14005547C(__int64 a1);
__int64 __fastcall sub_140055480(__int64 a1);
__int64 __fastcall sub_140055484(__int64 a1);
__int64 __fastcall sub_140055500(__int64 a1);
__int64 __fastcall sub_140056960(__int64 a1);
__int64 sub_140056964();
int *sub_140056998();
void __fastcall sub_1400569BC(__int64 a1, void *a2);
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_b8c45f8f788dd370798f47cfe8ac3a86_,_lambda_4e60a939b0d047cfe11ddc22648dfba9_ &,_lambda_332c3edc96d0294ec56c57d38c1cdfd5_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_e24bbb7b643b32fcea6fa61b31d4c984_,_lambda_275893d493268fdec8709772e3fcec0e_ &,_lambda_9d71df4d7cf3f480f8d633942495c3b0_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140056BA0(int a1, __int64 a2);
__int64 __fastcall sub_140056BC8(int a1, __int64 a2);
void __fastcall sub_140056DB8(int *a1);
void __fastcall sub_140056F9C(int *a1);
void __fastcall sub_140056FA4(int *a1);
void __fastcall sub_140056FAC(int *a1);
int __fastcall sub_140056FE8(_onexit_t Function);
// int __cdecl register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_1400570F4();
char sub_1400570F8();
char sub_14005710C();
char sub_140057110();
__vcrt_bool sub_140057168();
char sub_140057200();
// void __noreturn terminate(void); weak
// errno_t __cdecl strcpy_s(char *Destination, rsize_t SizeInBytes, const char *Source);
// void __cdecl __noreturn abort();
// int __cdecl wcsncmp(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
__int64 __fastcall sub_140057568(__int64 a1);
void __fastcall sub_1400576C8(__int64 a1);
// void __cdecl invalid_parameter_noinfo();
// unsigned int *__cdecl _doserrno();
// int *__cdecl errno();
void __fastcall sub_140057B34(__int64 a1, void *a2);
// __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_46352004c1216016012b18bd6f87e700_,_lambda_3bd07e1a1191394380780325891bf33f_ &,_lambda_334532d3f185bcaa59b5be82d7d22bff_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_5e887d1dcbef67a5eb4283622ba103bf_,_lambda_4466841279450cc726390878d4a41900_ &,_lambda_341c25c0346d94847f1f3c463c57e077_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_72d1df2b273a38828b1ce30cbf4cdab5_,_lambda_876a65b173b8412d3a47c70a915b0cf4_ &,_lambda_41932305e351933ebe8f8be3ed8bb5dc_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_fb3a7dec4e47f37f22dae91bb15c9095_,_lambda_698284760c8add0bfb0756c19673e34b_ &,_lambda_dfb8eca1e75fef3034a8fb18dd509707_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140057C64(int a1, __int64 a2);
__int64 __fastcall sub_140057C8C(int a1, __int64 a2);
__int64 __fastcall sub_140057CB4(int a1, __int64 a2);
__int64 __fastcall sub_140057CDC(int a1, __int64 a2);
void __fastcall sub_140057DA8(DWORD *a1);
void __fastcall sub_140057DC0(int *a1);
void __fastcall sub_140057DC8(int *a1);
void __fastcall sub_140057E08(int *a1);
void __fastcall sub_140057E28(int *a1);
void __fastcall sub_140057E30(int *a1);
void __fastcall sub_140057E48(int *a1);
void __fastcall sub_140057E64(int *a1);
void __fastcall sub_140057E6C(int *a1);
__int64 __fastcall sub_14005800C(__int64 a1);
__int64 __fastcall sub_140058228(__int64 a1);
__int64 __fastcall sub_1400585C0(__int64 a1, __int64 *a2);
__int64 __fastcall sub_1400585F4(__int64 a1, __int64 *a2);
__int64 __fastcall sub_140058658(volatile __int64 *a1, __int64 a2);
HANDLE sub_140058660();
// void __cdecl free_base(void *Block);
void __fastcall sub_1400587BC(int a1);
void __fastcall sub_140058810(int a1);
void sub_14005882C();
void sub_14005883C();
// BOOL __stdcall _lambda_e2bb8337c48846e80c921ea5ddadc92d_::_helper_func_cdecl_(LPWSTR); idb
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_630b2aca97f6d20d5b5ea6529ea6b6af_,_lambda_af91936f1d075d609f72d9d8cba980af_ &,_lambda_e82fa975f615b5c7c7b0e4d178fdae67_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140058944(int a1, __int64 a2);
BOOL (__stdcall *sub_1400589BC())(LPWSTR);
void __fastcall sub_1400589C4(int *a1);
void __fastcall sub_140058A34(int *a1);
__int64 sub_140058B04();
__int64 sub_140058B24();
__int64 sub_140058BC4();
__int64 sub_140058BE4();
__int64 sub_140058C04();
__int64 sub_140058C24();
__int64 sub_140058C44();
__int64 sub_140058C64();
__int64 sub_140058C84();
__int64 sub_140058CA4();
__int64 sub_140058CC4();
__int64 sub_140058CE4();
__int64 sub_140058D04();
__int64 sub_140058D24();
__int64 sub_140058D44();
__int64 sub_140058D64();
__int64 sub_140058D84();
__int64 sub_140058DA4();
__int64 sub_140058DC4();
__int64 sub_140058DE4();
__int64 sub_140058E04();
__int64 sub_140058E24();
__int64 sub_140058E44();
__int64 sub_140058E64();
__int64 sub_140058E84();
// __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140059DF0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
// __int64 __fastcall _acrt_MessageBoxW(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 _acrt_can_show_message_box(void); weak
// __int64 _acrt_get_parent_window(void); weak
// __int64 _acrt_is_interactive(void); weak
// __int64 _acrt_is_packaged_app(void); weak
// void *__cdecl calloc_base(size_t Count, size_t Size);
// __int64 __fastcall unknown_libname_849(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14005A788(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005A7C4(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005A83C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005A878(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005A8B4(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005A92C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005A998(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005A9D4(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005AA10(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005AA4C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005ABD8(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005AC14(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005AC50(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005AC8C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005ACF8(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005AD34(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005AD70(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
__int64 __fastcall sub_14005ADAC(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4);
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// unsigned __int64 __cdecl strtoui64_0(const char *String, char **EndPtr, int Radix);
// int __cdecl wcstol(const wchar_t *String, wchar_t **EndPtr, int Radix);
// unsigned __int64 __cdecl wcstoui64_0(const wchar_t *String, wchar_t **EndPtr, int Radix);
// int __cdecl mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// errno_t __cdecl wctomb_s(int *SizeConverted, char *MbCh, rsize_t SizeInBytes, wchar_t WCh);
// size_t __cdecl strnlen(const char *String, size_t MaxCount);
// size_t __cdecl wcsnlen(const wchar_t *Source, size_t MaxCount);
// __int64 __fastcall _acrt_fp_format(double *, char *, unsigned __int64, char *, unsigned __int64, int, int, __int64, struct __crt_locale_pointers *); idb
// __int64 __fastcall unknown_libname_857(_QWORD, _QWORD); weak
// int __cdecl get_printf_count_output();
// __int64 __fastcall _acrt_stdio_end_temporary_buffering_nolock(_QWORD, _QWORD); weak
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_5118a789131033a5646699a06bf2b47a_,_lambda_6c868b97557875bf03ef8ae33acccf48_ &,_lambda_c7e520e7ba699ee0395251f697dddb81_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14005D140(int a1, __int64 a2);
void __fastcall sub_14005D180(int *a1);
int __fastcall sub_14005D188(int **a1);
void __fastcall sub_14005D194(int *a1);
// int __cdecl putch_nolock(int Ch);
HANDLE sub_14005D290();
int sub_14005D2CC();
//void *sub_14005D31C();
int __fastcall sub_14005D4F0(wint_t a1);
int __fastcall sub_14005D4FC(wint_t a1);
int __fastcall sub_14005D520(wint_t a1);
int __fastcall sub_14005D590(wint_t a1);
int __fastcall sub_14005D59C(wint_t a1);
int __fastcall sub_14005D5A8(wint_t a1);
int __fastcall sub_14005D5B4(wint_t a1);
int __fastcall sub_14005D5C0(wint_t a1);
int __fastcall sub_14005D5CC(wint_t a1);
int __fastcall sub_14005D5D8(wint_t a1);
int __fastcall sub_14005D628(wint_t a1);
int __fastcall sub_14005D634(wint_t a1);
int __fastcall sub_14005D668(wint_t a1);
int __fastcall sub_14005D674(wint_t a1);
int __fastcall sub_14005D680(wint_t a1);
int __fastcall sub_14005D68C(wint_t a1);
int __fastcall sub_14005D698(wint_t a1);
int __fastcall sub_14005D6A4(wint_t a1);
int __fastcall sub_14005D6B0(wint_t a1);
int __fastcall sub_14005D6BC(wint_t a1);
int __fastcall sub_14005D6C8(wint_t a1);
__int64 __fastcall sub_14005DA70(__int64 a1);
// int __cdecl iswctype(wint_t C, wctype_t Type);
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_bfedae4ebbf01fab1bb6dcc6a9e276e0_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_237c231691f317818eb88cc1d5d642d6_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14005DBF8(int a1, __int64 a2);
void __fastcall sub_14005DC38(int *a1);
void __fastcall sub_14005DC8C(int *a1);
__int64 __fastcall sub_14005DD10(int a1);
void __fastcall sub_14005DE70(__int64 a1, void *a2);
void __fastcall sub_14005E044(__int64 *a1);
int __fastcall sub_14005E748(const char **a1, const char *a2, size_t *a3);
int __fastcall sub_14005E754(const wchar_t **a1, const wchar_t *a2, size_t *a3);
int __fastcall sub_14005E760(const char **a1, const char *a2, size_t *a3);
int __fastcall sub_14005E76C(const char **a1, const char *a2, size_t *a3);
int __fastcall sub_14005E778(const char **a1, const char *a2, size_t *a3);
int __fastcall sub_14005E784(const wchar_t **a1, const wchar_t *a2, size_t *a3);
int __fastcall sub_14005E790(const wchar_t **a1, const wchar_t *a2, size_t *a3);
int __fastcall sub_14005E79C(const wchar_t **a1, const wchar_t *a2, size_t *a3);
// __int64 __fastcall openfile(char *FileName); idb
// __int64 __fastcall wopenfile(wchar_t *FileName); idb
wint_t __cdecl j__fgetwc_nolock(FILE *Stream);
int __cdecl j__fgetc_nolock(FILE *Stream);
// int __cdecl ungetc_nolock(int Character, FILE *Stream);
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_b521505b218e5242e90febf6bfebc422_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_314360699dd331753a4119843814e9a7_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140061658(int a1, __int64 a2);
void __fastcall sub_140061698(int *a1);
void __fastcall sub_14006170C(int *a1);
// errno_t __cdecl wcscpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// errno_t __cdecl wcsncpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
__int64 __fastcall sub_140062404(LPCSTR lpOutputString, __int64 a2, unsigned int a3);
__int64 __fastcall sub_140062520(LPCWSTR lpOutputString, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14006263C(__int64 *a1, __int64 *a2, __int64 *a3, unsigned int *a4);
__int64 __fastcall sub_140062650(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int *a4);
__int64 __fastcall sub_140062664(__int64 *a1, __int64 *a2, __int64 *a3, unsigned int *a4);
__int64 __fastcall sub_140062678(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int *a4);
__int64 __fastcall sub_14006268C(__int64 *a1, __int64 *a2, __int64 *a3, unsigned int *a4);
__int64 __fastcall sub_1400626A0(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int *a4);
__int64 __fastcall sub_1400626B4(LPVOID lpThreadParameter);
// DWORD __stdcall message_box_wait_thread<wchar_t>(LPVOID lpThreadParameter); idb
void __fastcall sub_140062704(LPCSTR *a1);
void __fastcall sub_140062710(LPCWSTR *a1);
bool __fastcall sub_140062774(void *a1);
__int64 __fastcall sub_140062788(__int64 a1);
__int64 __fastcall sub_14006279C(LPCSTR lpOutputString, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400628B8(LPCWSTR lpOutputString, __int64 a2, unsigned int a3);
// int __cdecl CompareFunction(const void *, const void *); idb
// int __cdecl unknown_libname_870(const void *, const void *); idb
HANDLE __fastcall sub_1400633B8(LPCSTR *a1, FINDEX_INFO_LEVELS *a2, LPVOID *a3, FINDEX_SEARCH_OPS *a4, LPVOID *a5, DWORD *a6);
HANDLE __fastcall sub_1400633E4(LPCWSTR *a1, FINDEX_INFO_LEVELS *a2, LPVOID *a3, FINDEX_SEARCH_OPS *a4, LPVOID *a5, DWORD *a6);
BOOL __fastcall sub_140063410(HANDLE *a1, LPWIN32_FIND_DATAA *a2);
BOOL __fastcall sub_140063420(HANDLE *a1, LPWIN32_FIND_DATAW *a2);
errno_t __fastcall sub_140063430(char **a1, rsize_t *a2, const char **a3, rsize_t *a4);
errno_t __fastcall sub_140063444(wchar_t **a1, rsize_t *a2, const wchar_t **a3, rsize_t *a4);
errno_t __fastcall sub_140063458(char **a1, rsize_t *a2, const char **a3, rsize_t *a4);
errno_t __fastcall sub_14006346C(char **a1, rsize_t *a2, const char **a3, rsize_t *a4);
errno_t __fastcall sub_140063480(wchar_t **a1, rsize_t *a2, const wchar_t **a3, rsize_t *a4);
errno_t __fastcall sub_140063494(wchar_t **a1, rsize_t *a2, const wchar_t **a3, rsize_t *a4);
__int64 __fastcall sub_1400634A8(_QWORD *a1);
wchar_t *__fastcall sub_1400634B0(const wchar_t **a1, const wchar_t *a2);
int (__cdecl *sub_140063584())(const void *, const void *);
int (__cdecl *sub_14006358C())(const void *, const void *);
__int64 __fastcall sub_1400635DC(__int64 a1, void *a2);
__int64 __fastcall sub_140063628(__int64 a1, void *a2);
__int64 __fastcall sub_140063674(__int64 a1);
__int64 __fastcall sub_140063678(__int64 a1);
bool __fastcall sub_1400636A0(void *a1);
// __int64 unknown_libname_877(void); weak
// __int64 unknown_libname_878(void); weak
__int64 __fastcall sub_140063854(__int64 a1);
__int64 __fastcall sub_140063868(__int64 a1, __int64 a2);
// __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_99476a1ad63dd22509b5d3e65b0ffc95_,_lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c_ &,_lambda_f7424dd8d45958661754dc4f2697e9c3_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_1400638E0(int a1, __int64 a2);
void __fastcall sub_140063920(int *a1);
void __fastcall sub_140063B40(int *a1);
// __int64 _acrt_update_thread_multibyte_data(void); weak
void *sub_140064118();
void *sub_140064120();
char sub_1400647C0();
int *sub_1400647C4();
void **sub_1400647CC();
void **sub_1400647D4();
__int64 *sub_1400647DC();
__int64 *sub_1400647E4();
__int64 *sub_1400647EC();
__int64 *sub_1400647F4();
__int64 __fastcall sub_1400647FC(_QWORD *a1);
__int64 __fastcall sub_140064834(_QWORD *a1);
__int64 __fastcall sub_140064900(__int64 a1);
BOOL __fastcall sub_140065390(LPCSTR *a1, LPCSTR *a2);
BOOL __fastcall sub_1400653A0(LPCWSTR *a1, LPCWSTR *a2);
errno_t __fastcall sub_1400653C8(char **a1, rsize_t *a2, const char **a3);
errno_t __fastcall sub_1400653D8(wchar_t **a1, rsize_t *a2, const wchar_t **a3);
errno_t __fastcall sub_1400653E8(char **a1, rsize_t *a2, const char **a3);
errno_t __fastcall sub_1400653F8(wchar_t **a1, rsize_t *a2, const wchar_t **a3);
int __fastcall sub_140065430(const char **a1, const char **a2, size_t *a3);
int __fastcall sub_140065440(const wchar_t **a1, const wchar_t **a2, size_t *a3);
void **sub_140065450();
void **sub_140065458();
void **sub_140065460();
void **sub_140065468();
void **sub_140065470();
void **sub_140065478();
//__int64 __fastcall common_set_variable_in_environment_nolock<char>(char *String1); // idb
//__int64 __fastcall common_set_variable_in_environment_nolock<wchar_t>(wchar_t *String1); // idb
void __fastcall sub_1400654A0(__int64 a1, void *a2);
__int64 __fastcall sub_1400654E0(__int64 a1);
void __fastcall sub_1400656AC(int a1);
void __fastcall sub_140065790(int a1);
int *sub_140065B14();
void __fastcall sub_140065B1C(__int64 a1, void *a2);
void __fastcall sub_140065B24(__int64 a1, void *a2);
void __fastcall sub_140066CBC(__int64 a1, void *a2);
void __fastcall sub_140066CC4(const void **a1);
void __fastcall sub_140066CD0(const void **a1);
void __fastcall sub_140066CDC(const void **a1);
void __fastcall sub_140066CE8(const void **a1);
void __fastcall sub_140066CF4(const void **a1);
void __fastcall sub_140066D00(const void **a1);
// void __fastcall free_crt_array_internal(const void **const, unsigned __int64); idb
__int64 __fastcall sub_140066D9C(__int64 a1);
// wchar_t *__cdecl wcspbrk(const wchar_t *String, const wchar_t *Control);
// __int64 _acrt_update_thread_locale_data(void); weak
HANDLE sub_140069098();
char sub_1400690BC();
HANDLE sub_1400690C8();
__int64 __fastcall sub_140069260(__int64 a1);
void __fastcall sub_140069264(__int64 a1);
// __int64 __fastcall __crt_seh_guarded_call<void (*)(int)>::operator()<_lambda_c36588078e9f5dfd39652860aa6b3aaf_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_dc9d2797ccde5d239b4a0efae8ebd7db_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_1400693A0(int a1, __int64 a2);
void __fastcall sub_140069410(int *a1);
void __fastcall sub_140069418(int *a1);
__int64 __fastcall sub_1400695A0(__int64 a1);
// __int64 __fastcall __crt_seh_guarded_call<unsigned short>::operator()<_lambda_9fda798407f8391327e99fec20084266_,_lambda_6e3e78bb6855d1e4040e022c1b427e22_ &,_lambda_5d54a80e00f5dcce6acfc22736ebf0cf_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14006C5CC(int a1, __int64 a2);
void __fastcall sub_14006C60C(int *a1);
void __fastcall sub_14006C620(int *a1);
// int __cdecl wcsnicmp(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
__int64 __fastcall sub_14006DDE8(unsigned int a1);
// errno_t __cdecl strncpy_s(char *Destination, rsize_t SizeInBytes, const char *Source, rsize_t MaxCount);
// __int64 __fastcall unknown_libname_917(_QWORD); weak
// int __cdecl wcsnicoll(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// int __cdecl strnicoll(const char *String1, const char *String2, size_t MaxCount);
HANDLE sub_14006FBBC();
int sub_14006FBF8();
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_702c71755a341b84ce26a812eea27a9e_,_lambda_1cffa78e445b1da5fba1a2e0e533226f_ &,_lambda_77b15b24eaa4cf6d702b2f4e7ca8df95_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14006FE90(int a1, __int64 a2);
void __fastcall sub_14006FF28(int *a1);
void __fastcall sub_14006FF30(int *a1);
__int64 sub_140070344();
// __int64 __fastcall set_fpsr(_QWORD); weak
__int64 sub_140071070();
void **__fastcall sub_140072170(_QWORD *a1);
_QWORD *__fastcall sub_14007217C(_QWORD *a1, char a2);
void __cdecl j_j_j__free_base_0(void *Block);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *InitializeSecurityDescriptor)(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
// extern BOOL (__stdcall *StartServiceA)(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);
// extern BOOL (__stdcall *QueryServiceStatus)(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *DeleteService)(SC_HANDLE hService);
// extern SC_HANDLE (__stdcall *CreateServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword);
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *LookupPrivilegeValueA)(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegDeleteValueA)(HKEY hKey, LPCSTR lpValueName);
// extern LSTATUS (__stdcall *RegDeleteKeyA)(HKEY hKey, LPCSTR lpSubKey);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCreateKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern void (__stdcall *InitCommonControls)();
// extern HWND (__stdcall *CreateToolbarEx)(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons, int dxButton, int dyButton, int dxBitmap, int dyBitmap, UINT uStructSize);
// extern HWND (__stdcall *FindTextA)(LPFINDREPLACEA);
// extern BOOL (__stdcall *ChooseColorA)(LPCHOOSECOLORA);
// extern BOOL (__stdcall *GetSaveFileNameA)(LPOPENFILENAMEA);
// extern BOOL (__stdcall *PrintDlgA)(LPPRINTDLGA pPD);
// extern BOOL (__stdcall *ChooseFontA)(LPCHOOSEFONTA);
// extern BOOL (__stdcall *GetOpenFileNameA)(LPOPENFILENAMEA);
// extern int (__stdcall *AbortDoc)(HDC hdc);
// extern int (__stdcall *SetAbortProc)(HDC hdc, ABORTPROC proc);
// extern BOOL (__stdcall *TextOutA)(HDC hdc, int x, int y, LPCSTR lpString, int c);
// extern BOOL (__stdcall *GetTextExtentPointA)(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz);
// extern HFONT (__stdcall *CreateFontA)(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
// extern BOOL (__stdcall *GetTextExtentPoint32A)(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl);
// extern int (__stdcall *GetDeviceCaps)(HDC hdc, int index);
// extern int (__stdcall *SetMapMode)(HDC hdc, int iMode);
// extern int (__stdcall *StartDocA)(HDC hdc, const DOCINFOA *lpdi);
// extern int (__stdcall *EndDoc)(HDC hdc);
// extern int (__stdcall *StartPage)(HDC hdc);
// extern int (__stdcall *EndPage)(HDC hdc);
// extern HBITMAP (__stdcall *CreateCompatibleBitmap)(HDC hdc, int cx, int cy);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern HFONT (__stdcall *CreateFontIndirectA)(const LOGFONTA *lplf);
// extern HBRUSH (__stdcall *CreateSolidBrush)(COLORREF color);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern int (__stdcall *SetBkMode)(HDC hdc, int mode);
// extern BOOL (__stdcall *StretchBlt)(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern BOOL (__stdcall *GetTextMetricsA)(HDC hdc, LPTEXTMETRICA lptm);
// extern int (__stdcall *GetObjectA)(HANDLE h, int c, LPVOID pv);
// extern BOOL (__stdcall *ExtTextOutA)(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx);
// extern COLORREF (__stdcall *SetBkColor)(HDC hdc, COLORREF color);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern UINT (__stdcall *GetSystemDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern DWORD (__stdcall *GetCurrentDirectoryA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern DWORD (__stdcall *GetFullPathNameA)(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern DWORD (__stdcall *SearchPathA)(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern BOOL (__stdcall *QueryPerformanceFrequency)(LARGE_INTEGER *lpFrequency);
// extern int (__stdcall *GetTimeFormatA)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime);
// extern BOOL (__stdcall *GetOverlappedResult)(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern LPVOID (__stdcall *LockResource)(HGLOBAL hResData);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern DWORD (__stdcall *SizeofResource)(HMODULE hModule, HRSRC hResInfo);
// extern HRSRC (__stdcall *FindResourceA)(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern void (__stdcall *RaiseException)(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// extern DWORD (__stdcall *GetTickCount)();
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern HGLOBAL (__stdcall *GlobalReAlloc)(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);
// extern LPVOID (__stdcall *GlobalLock)(HGLOBAL hMem);
// extern BOOL (__stdcall *GlobalUnlock)(HGLOBAL hMem);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern int (__stdcall *GetDateFormatA)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate);
// extern HGLOBAL (__stdcall *GlobalFree)(HGLOBAL hMem);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern BOOL (__stdcall *WriteFileEx)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// extern DWORD (__stdcall *QueueUserAPC)(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);
// extern DWORD (__stdcall *SleepEx)(DWORD dwMilliseconds, BOOL bAlertable);
// extern DWORD (__stdcall *ExpandEnvironmentStringsA)(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
// extern void (__stdcall *OutputDebugStringA)(LPCSTR lpOutputString);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *IsDebuggerPresent)();
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern HANDLE (__stdcall *OpenMutexA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern HANDLE (__stdcall *FindFirstFileExW)(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern LPSTR (__stdcall *lstrcpynA)(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern LPVOID (__stdcall *MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// extern DWORD (__stdcall *FormatMessageA)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern BOOL (__stdcall *SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// extern void (__stdcall *GetSystemTime)(LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern BOOL (__stdcall *TerminateThread)(HANDLE hThread, DWORD dwExitCode);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern void (__stdcall *GlobalMemoryStatus)(LPMEMORYSTATUS lpBuffer);
// extern DWORD (__stdcall *GetVersion)();
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern DWORD (__stdcall *GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// extern DWORD (__stdcall *GetLastError)();
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern void (__stdcall *OutputDebugStringW)(LPCWSTR lpOutputString);
// extern DWORD (__stdcall *WaitForSingleObjectEx)(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
// extern HANDLE (__stdcall *FindFirstFileExA)(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *SetEnvironmentVariableA)(LPCSTR lpName, LPCSTR lpValue);
// extern BOOL (__stdcall *SetEnvironmentVariableW)(LPCWSTR lpName, LPCWSTR lpValue);
// extern HRESULT (__stdcall *SHGetSpecialFolderLocation)(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);
// extern HRESULT (__stdcall *SHGetMalloc)(IMalloc **ppMalloc);
// extern BOOL (__stdcall *Shell_NotifyIconA)(DWORD dwMessage, PNOTIFYICONDATAA lpData);
// extern BOOL (__stdcall *ShellExecuteExA)(SHELLEXECUTEINFOA *pExecInfo);
// extern HINSTANCE (__stdcall *ShellExecuteA)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
// extern LPITEMIDLIST (__stdcall *SHBrowseForFolderA)(LPBROWSEINFOA lpbi);
// extern HANDLE (__stdcall *SetClipboardData)(UINT uFormat, HANDLE hMem);
// extern BOOL (__stdcall *CloseClipboard)();
// extern BOOL (__stdcall *OpenClipboard)(HWND hWndNewOwner);
// extern LRESULT (__stdcall *CallWindowProcA)(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HWND (__stdcall *GetParent)(HWND hWnd);
// extern BOOL (__stdcall *DrawFocusRect)(HDC hDC, const RECT *lprc);
// extern int (__stdcall *GetDialogBaseUnits)();
// extern UINT (__stdcall *IsDlgButtonChecked)(HWND hDlg, int nIDButton);
// extern BOOL (__stdcall *CheckRadioButton)(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton);
// extern ATOM (__stdcall *RegisterClassExA)(const WNDCLASSEXA *);
// extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern BOOL (__stdcall *IsDialogMessageA)(HWND hDlg, LPMSG lpMsg);
// extern BOOL (__stdcall *EmptyClipboard)();
// extern HICON (__stdcall *LoadIconA)(HINSTANCE hInstance, LPCSTR lpIconName);
// extern HBITMAP (__stdcall *LoadBitmapA)(HINSTANCE hInstance, LPCSTR lpBitmapName);
// extern HWND (__stdcall *FindWindowA)(LPCSTR lpClassName, LPCSTR lpWindowName);
// extern DWORD (__stdcall *GetSysColor)(int nIndex);
// extern HWND (__stdcall *ChildWindowFromPoint)(HWND hWndParent, POINT Point);
// extern BOOL (__stdcall *GetCursorPos)(LPPOINT lpPoint);
// extern BOOL (__stdcall *GetWindowRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern int (__stdcall *GetWindowTextA)(HWND hWnd, LPSTR lpString, int nMaxCount);
// extern BOOL (__stdcall *InvalidateRgn)(HWND hWnd, HRGN hRgn, BOOL bErase);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern BOOL (__stdcall *SetForegroundWindow)(HWND hWnd);
// extern HWND (__stdcall *GetFocus)();
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern int (__stdcall *DrawTextA)(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern HDC (__stdcall *BeginPaint)(HWND hWnd, LPPAINTSTRUCT lpPaint);
// extern BOOL (__stdcall *EndPaint)(HWND hWnd, const PAINTSTRUCT *lpPaint);
// extern BOOL (__stdcall *ClientToScreen)(HWND hWnd, LPPOINT lpPoint);
// extern int (__stdcall *LoadStringA)(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax);
// extern BOOL (__stdcall *UpdateWindow)(HWND hWnd);
// extern BOOL (__stdcall *TrackPopupMenu)(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// extern LONG (__stdcall *GetMenuCheckMarkDimensions)();
// extern BOOL (__stdcall *SetMenuItemBitmaps)(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked);
// extern BOOL (__stdcall *DeleteMenu)(HMENU hMenu, UINT uPosition, UINT uFlags);
// extern BOOL (__stdcall *AppendMenuA)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// extern LONG_PTR (__stdcall *SetWindowLongPtrA)(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern int (__stdcall *TranslateAcceleratorA)(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// extern HACCEL (__stdcall *LoadAcceleratorsA)(HINSTANCE hInstance, LPCSTR lpTableName);
// extern BOOL (__stdcall *KillTimer)(HWND hWnd, UINT_PTR uIDEvent);
// extern UINT_PTR (__stdcall *SetTimer)(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// extern DWORD (__stdcall *MsgWaitForMultipleObjects)(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);
// extern BOOL (__stdcall *ReleaseCapture)();
// extern HWND (__stdcall *SetCapture)(HWND hWnd);
// extern HWND (__stdcall *SetFocus)(HWND hWnd);
// extern LRESULT (__stdcall *SendDlgItemMessageA)(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern UINT (__stdcall *GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax);
// extern BOOL (__stdcall *SetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPCSTR lpString);
// extern INT_PTR (__stdcall *DialogBoxParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern HWND (__stdcall *CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern BOOL (__stdcall *IsZoomed)(HWND hWnd);
// extern BOOL (__stdcall *IsIconic)(HWND hWnd);
// extern BOOL (__stdcall *SetWindowPos)(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// extern BOOL (__stdcall *MoveWindow)(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern BOOL (__stdcall *IsWindow)(HWND hWnd);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern void (__stdcall *PostQuitMessage)(int nExitCode);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *AttachThreadInput)(DWORD idAttach, DWORD idAttachTo, BOOL fAttach);
// extern BOOL (__stdcall *PostMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern UINT (__stdcall *RegisterWindowMessageA)(LPCSTR lpString);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern BOOL (__stdcall *InsertMenuItemA)(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi);
// extern int (__stdcall *GetMenuItemCount)(HMENU hMenu);
// extern HMENU (__stdcall *GetSubMenu)(HMENU hMenu, int nPos);
// extern DWORD (__stdcall *CheckMenuItem)(HMENU hMenu, UINT uIDCheckItem, UINT uCheck);
// extern HMENU (__stdcall *GetMenu)(HWND hWnd);
// extern HCURSOR (__stdcall *LoadCursorA)(HINSTANCE hInstance, LPCSTR lpCursorName);
// extern BOOL (__stdcall *InflateRect)(LPRECT lprc, int dx, int dy);
// extern HBRUSH (__stdcall *GetSysColorBrush)(int nIndex);
// extern HCURSOR (__stdcall *SetCursor)(HCURSOR hCursor);
// extern BOOL (__stdcall *SetWindowTextA)(HWND hWnd, LPCSTR lpString);
// extern HWND (__stdcall *GetDlgItem)(HWND hDlg, int nIDDlgItem);
// extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult);
// extern INT_PTR (__stdcall *DialogBoxIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern LRESULT (__stdcall *SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern DWORD (__stdcall *GetWindowThreadProcessId)(HWND hWnd, LPDWORD lpdwProcessId);
// extern BOOL (__stdcall *ScreenToClient)(HWND hWnd, LPPOINT lpPoint);
// extern BOOL (__stdcall *EnableMenuItem)(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
// extern BOOL (__stdcall *CheckDlgButton)(HWND hDlg, int nIDButton, UINT uCheck);
// extern BOOL (__stdcall *InvalidateRect)(HWND hWnd, const RECT *lpRect, BOOL bErase);
const LPARAM WindowName = 5476377146882523136i64; // idb
const CHAR pszFaceName[] = { 'C', 'o', 'u', 'r', 'i', 'e', 'r', ' ' }; // idb
const char byte_14007B310 = '\x01'; // idb
const CHAR asc_14007BD58[] = "*"; // idb
//__int128 xmmword_14007CBE0 = 16i64; // weak
__int16 word_14007CF34 = 2573; // weak
const CHAR a0_0[] = "0"; // idb
_UNKNOWN unk_14007D5B0; // weak
__int64 qword_14007D5C8 = 8589934593i64; // weak
//void *DNameNode::`vftable' = &purecall; // weak
//void *std::exception::`vftable' = &unknown_libname_53; // weak
//void *std::bad_exception::`vftable' = &unknown_libname_52; // weak
_UNKNOWN unk_14007E7A0; // weak
unsigned __int8 byte_14007E800[92] =
{
  6u,
  128u,
  128u,
  134u,
  128u,
  129u,
  128u,
  0u,
  0u,
  16u,
  3u,
  134u,
  128u,
  134u,
  130u,
  128u,
  20u,
  5u,
  5u,
  69u,
  69u,
  69u,
  133u,
  133u,
  133u,
  5u,
  0u,
  0u,
  48u,
  48u,
  128u,
  80u,
  128u,
  136u,
  0u,
  8u,
  0u,
  40u,
  39u,
  56u,
  80u,
  87u,
  128u,
  0u,
  7u,
  0u,
  55u,
  48u,
  48u,
  80u,
  80u,
  136u,
  7u,
  0u,
  0u,
  32u,
  40u,
  128u,
  136u,
  128u,
  128u,
  0u,
  0u,
  0u,
  96u,
  104u,
  96u,
  104u,
  104u,
  104u,
  8u,
  8u,
  7u,
  120u,
  119u,
  112u,
  119u,
  112u,
  112u,
  8u,
  8u,
  0u,
  0u,
  8u,
  7u,
  8u,
  0u,
  7u,
  8u,
  0u,
  7u,
  0u
}; // weak
_UNKNOWN unk_140080B80; // weak
_UNKNOWN unk_140080B98; // weak
_UNKNOWN unk_140080C10; // weak
_UNKNOWN unk_140080C50; // weak
_UNKNOWN unk_140080C78; // weak
_UNKNOWN unk_140080C98; // weak
_UNKNOWN unk_140080CB0; // weak
_UNKNOWN unk_140080CD4; // weak
_UNKNOWN unk_140080CF8; // weak
_UNKNOWN unk_140080D10; // weak
_UNKNOWN unk_140080D38; // weak
_UNKNOWN unk_140080DA8; // weak
_UNKNOWN unk_140080DC8; // weak
_UNKNOWN unk_140080DE0; // weak
_UNKNOWN unk_140080E00; // weak
_UNKNOWN unk_140080E40; // weak
_UNKNOWN unk_140080E58; // weak
_UNKNOWN unk_140080E84; // weak
_UNKNOWN unk_140080E98; // weak
//void *type_info::`vftable' = &sub_14007217C; // weak
void (*qword_1400881C0[2])(void) = { NULL, NULL }; // weak
void (*qword_1400881D0)(void) = NULL; // weak

char off_140092000_001[]{"{\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033{\\fonttbl{\\f0\\fswiss\\fprq2\\fcharset0 Tahoma;}{\\f1\\fnil\\fcharset0 Calibri;}}"};
char off_140092000_002[]{"{\\colortbl ;\\red0\\green0\\blue255;\\red0\\green0\\blue0;}"};
char off_140092000_003[]{"{\\*\\generator Riched20 10.0.10240}\\viewkind4\\uc1 "};
char off_140092000_004[]{"\\pard\\brdrb\\brdrs\\brdrw10\\brsp20 \\sb120\\sa120\\b\\f0\\fs24 SYSINTERNALS SOFTWARE LICENSE TERMS\\fs28\\par"};
char off_140092000_005[]{"\\pard\\sb120\\sa120\\b0\\fs19 These license terms are an agreement between Sysinternals (a wholly owned subsidiary of Microsoft Corporation) and you.  Please read them.  They apply to the software you are downloading from Systinternals.com, which includes the media on which you received it, if any.  The terms also apply to any Sysinternals\\par"};
char off_140092000_006[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\tx720\\'b7\\tab updates,\\par"};
char off_140092000_007[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\'b7\\tab supplements,\\par"};
char off_140092000_008[]{"\\'b7\\tab Internet-based services, and \\par"};
char off_140092000_009[]{"\\'b7\\tab support services\\par"};
char off_140092000_010[]{"\\pard\\sb120\\sa120 for this software, unless other terms accompany those items.  If so, those terms apply.\\par"};
char off_140092000_011[]{"\\b BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.  IF YOU DO NOT ACCEPT THEM, DO NOT USE THE SOFTWARE.\\par"};
char off_140092000_012[]{"\\pard\\brdrt\\brdrs\\brdrw10\\brsp20 \\sb120\\sa120 If you comply with these license terms, you have the rights below.\\par"};
char off_140092000_013[]{"\\pard\\fi-357\\li357\\sb120\\sa120\\tx360\\fs20 1.\\tab\\fs19 INSTALLATION AND USE RIGHTS.  \\b0 You may install and use any number of copies of the software on your devices.\\b\\par"};
char off_140092000_014[]{"\\caps\\fs20 2.\\tab\\fs19 Scope of License\\caps0 .\\b0   The software is licensed, not sold. This agreement only gives you some rights to use the software.  Sysinternals reserves all other rights.  Unless applicable law gives you more rights despite this limitation, you may use the software only as expressly permitted in this agreement.  In doing so, you must comply with any technical limitations in the software that only allow you to use it in certain ways.    You may not\\b\\par"};
char off_140092000_015[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\tx720\\b0\\'b7\\tab work around any technical limitations in the binary versions of the software;\\par"};
char off_140092000_016[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\'b7\\tab reverse engineer, decompile or disassemble the binary versions of the software, except and only to the extent that applicable law expressly permits, despite this limitation;\\par"};
char off_140092000_017[]{"\\'b7\\tab make more copies of the software than specified in this agreement or allowed by applicable law, despite this limitation;\\par"};
char off_140092000_018[]{"\\'b7\\tab publish the software for others to copy;\\par"};
char off_140092000_019[]{"\\'b7\\tab rent, lease or lend the software;\\par"};
char off_140092000_020[]{"\\'b7\\tab transfer the software or this agreement to any third party; or\\par"};
char off_140092000_021[]{"\\'b7\\tab use the software for commercial software hosting services.\\par"};
char off_140092000_022[]{"\\pard\\fi-357\\li357\\sb120\\sa120\\tx360\\b\\fs20 3.\\tab SENSITIVE INFORMATION. \\b0  Please be aware that, similar to other debug tools that capture \\ldblquote process state\\rdblquote  information, files saved by Sysinternals tools may include personally identifiable or other sensitive information (such as usernames, passwords, paths to files accessed, and paths to registry accessed). By using this software, you acknowledge that you are aware of this and take sole responsibility for any personally identifiable or other sensitive information provided to Microsoft or any other party through your use of the software.\\b\\par"};
char off_140092000_023[]{"5. \\tab\\fs19 DOCUMENTATION.\\b0   Any person that has valid access to your computer or internal network may copy and use the documentation for your internal, reference purposes.\\b\\par"};
char off_140092000_024[]{"\\caps\\fs20 6.\\tab\\fs19 Export Restrictions\\caps0 .\\b0   The software is subject to United States export laws and regulations.  You must comply with all domestic and international export laws and regulations that apply to the software.  These laws include restrictions on destinations, end users and end use.  For additional information, see {\\cf1\\ul{\\field{\\*\\fldinst{HYPERLINK www.microsoft.com/exporting }}{\\fldrslt{www.microsoft.com/exporting}}}}\\cf1\\ul\\f0\\fs19  <{{\\field{\\*\\fldinst{HYPERLINK \"http://www.microsoft.com/exporting\"}}{\\fldrslt{http://www.microsoft.com/exporting}}}}\\f0\\fs19 >\\cf0\\ulnone .\\b\\par"};
char off_140092000_025[]{"\\caps\\fs20 7.\\tab\\fs19 SUPPORT SERVICES.\\caps0  \\b0 Because this software is \"as is, \" we may not provide support services for it.\\b\\par"};
char off_140092000_026[]{"\\caps\\fs20 8.\\tab\\fs19 Entire Agreement.\\b0\\caps0   This agreement, and the terms for supplements, updates, Internet-based services and support services that you use, are the entire agreement for the software and support services.\\par"};
char off_140092000_027[]{"\\pard\\keepn\\fi-360\\li360\\sb120\\sa120\\tx360\\cf2\\b\\caps\\fs20 9.\\tab\\fs19 Applicable Law\\caps0 .\\par"};
char off_140092000_028[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\tx720\\cf0\\fs20 a.\\tab\\fs19 United States.\\b0   If you acquired the software in the United States, Washington state law governs the interpretation of this agreement and applies to claims for breach of it, regardless of conflict of laws principles.  The laws of the state where you live govern all other claims, including claims under state consumer protection laws, unfair competition laws, and in tort.\\b\\par"};
char off_140092000_029[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\fs20 b.\\tab\\fs19 Outside the United States.\\b0   If you acquired the software in any other country, the laws of that country apply.\\b\\par"};
char off_140092000_030[]{"\\pard\\fi-357\\li357\\sb120\\sa120\\tx360\\caps\\fs20 10.\\tab\\fs19 Legal Effect.\\b0\\caps0   This agreement describes certain legal rights.  You may have other rights under the laws of your country.  You may also have rights with respect to the party from whom you acquired the software.  This agreement does not change your rights under the laws of your country if the laws of your country do not permit it to do so.\\b\\caps\\par"};
char off_140092000_031[]{"\\fs20 11.\\tab\\fs19 Disclaimer of Warranty.\\caps0    \\caps The software is licensed \"as - is.\"  You bear the risk of using it.  SYSINTERNALS gives no express warranties, guarantees or conditions.  You may have additional consumer rights under your local laws which this agreement cannot change.  To the extent permitted under your local laws, SYSINTERNALS excludes the implied warranties of merchantability, fitness for a particular purpose and non-infringement.\\par"};
char off_140092000_032[]{"\\pard\\fi-360\\li360\\sb120\\sa120\\tx360\\fs20 12.\\tab\\fs19 Limitation on and Exclusion of Remedies and Damages.  You can recover from SYSINTERNALS and its suppliers only direct damages up to U.S. $5.00.  You cannot recover any other damages, including consequential, lost profits, special, indirect or incidental damages.\\par"};
char off_140092000_033[]{"\\pard\\li357\\sb120\\sa120\\b0\\caps0 This limitation applies to\\par"};
char off_140092000_034[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\tx720\\'b7\\tab anything related to the software, services, content (including code) on third party Internet sites, or third party programs; and\\par"};
char off_140092000_035[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\'b7\\tab claims for breach of contract, breach of warranty, guarantee or condition, strict liability, negligence, or other tort to the extent permitted by applicable law.\\par"};
char off_140092000_036[]{"\\pard\\li360\\sb120\\sa120 It also applies even if Sysinternals knew or should have known about the possibility of the damages.  The above limitation or exclusion may not apply to you because your country may not allow the exclusion or limitation of incidental, consequential or other damages.\\par"};
char off_140092000_037[]{"\\pard\\b Please note: As this software is distributed in Quebec, Canada, some of the clauses in this agreement are provided below in French.\\par"};
char off_140092000_038[]{"\\pard\\sb240\\lang1036 Remarque : Ce logiciel \\'e9tant distribu\\'e9 au Qu\\'e9bec, Canada, certaines des clauses dans ce contrat sont fournies ci-dessous en fran\\'e7ais.\\par"};
char off_140092000_039[]{"\\pard\\sb120\\sa120 EXON\\'c9RATION DE GARANTIE.\\b0  Le logiciel vis\\'e9 par une licence est offert \\'ab tel quel \\'bb. Toute utilisation de ce logiciel est \\'e0 votre seule risque et p\\'e9ril. Sysinternals n'accorde aucune autre garantie expresse. Vous pouvez b\\'e9n\\'e9ficier de droits additionnels en vertu du droit local sur la protection dues consommateurs, que ce contrat ne peut modifier. La ou elles sont permises par le droit locale, les garanties implicites de qualit\\'e9 marchande, d'ad\\'e9quation \\'e0 un usage particulier et d'absence de contrefa\\'e7on sont exclues.\\par"};
char off_140092000_040[]{"\\pard\\keepn\\sb120\\sa120\\b LIMITATION DES DOMMAGES-INT\\'c9R\\'caTS ET EXCLUSION DE RESPONSABILIT\\'c9 POUR LES DOMMAGES.\\b0   Vous pouvez obtenir de Sysinternals et de ses fournisseurs une indemnisation en cas de dommages directs uniquement \\'e0 hauteur de 5,00 $ US. Vous ne pouvez pr\\'e9tendre \\'e0 aucune indemnisation pour les autres dommages, y compris les dommages sp\\'e9ciaux, indirects ou accessoires et pertes de b\\'e9n\\'e9fices.\\par"};
char off_140092000_041[]{"\\lang1033 Cette limitation concerne :\\par"};
char off_140092000_042[]{"\\pard\\keepn\\fi-360\\li720\\sb120\\sa120\\tx720\\lang1036\\'b7\\tab tout  ce qui est reli\\'e9 au logiciel, aux services ou au contenu (y compris le code) figurant sur des sites Internet tiers ou dans des programmes tiers ; et\\par"};
char off_140092000_043[]{"\\pard\\fi-363\\li720\\sb120\\sa120\\tx720\\'b7\\tab les r\\'e9clamations au titre de violation de contrat ou de garantie, ou au titre de responsabilit\\'e9 stricte, de n\\'e9gligence ou d'une autre faute dans la limite autoris\\'e9e par la loi en vigueur.\\par"};
char off_140092000_044[]{"\\pard\\sb120\\sa120 Elle s'applique \\'e9galement, m\\'eame si Sysinternals connaissait ou devrait conna\\'eetre l'\\'e9ventualit\\'e9 d'un tel dommage.  Si votre pays n'autorise pas l'exclusion ou la limitation de responsabilit\\'e9 pour les dommages indirects, accessoires ou de quelque nature que ce soit, il se peut que la limitation ou l'exclusion ci-dessus ne s'appliquera pas \\'e0 votre \\'e9gard.\\par"};
char off_140092000_045[]{"\\b EFFET JURIDIQUE.\\b0   Le pr\\'e9sent contrat d\\'e9crit certains droits juridiques. Vous pourriez avoir d'autres droits pr\\'e9vus par les lois de votre pays.  Le pr\\'e9sent contrat ne modifie pas les droits que vous conf\\'e8rent les lois de votre pays si celles-ci ne le permettent pas.\\b\\par"};
char off_140092000_046[]{"\\pard\\b0\\fs20\\lang1033\\par"};
char off_140092000_047[]{"\\pard\\sa200\\sl276\\slmult1\\f1\\fs22\\lang9\\par"};
char off_140092000_048[]{"}"};
char *off_140092000[48]{
    off_140092000_001,
    off_140092000_002,
    off_140092000_003,
    off_140092000_004,
    off_140092000_005,
    off_140092000_006,
    off_140092000_007,
    off_140092000_008,
    off_140092000_009,
    off_140092000_010,
    off_140092000_011,
    off_140092000_012,
    off_140092000_013,
    off_140092000_014,
    off_140092000_015,
    off_140092000_016,
    off_140092000_017,
    off_140092000_018,
    off_140092000_019,
    off_140092000_020,
    off_140092000_021,
    off_140092000_022,
    off_140092000_023,
    off_140092000_024,
    off_140092000_025,
    off_140092000_026,
    off_140092000_027,
    off_140092000_028,
    off_140092000_029,
    off_140092000_030,
    off_140092000_031,
    off_140092000_032,
    off_140092000_033,
    off_140092000_034,
    off_140092000_035,
    off_140092000_036,
    off_140092000_037,
    off_140092000_038,
    off_140092000_039,
    off_140092000_040,
    off_140092000_041,
    off_140092000_042,
    off_140092000_043,
    off_140092000_044,
    off_140092000_045,
    off_140092000_046,
    off_140092000_047,
    off_140092000_048,
}; // weak
wchar_t const *off_140092188 = L"SYSINTERNALS SOFTWARE LICENSE TERMS\nThese license terms are an agreement between Sysinternals(a wholly owned subsidiary of Microsoft Corporation) and you.Please read them.They apply to the software you are downloading from technet.microsoft.com / sysinternals, which includes the media on which you received it, if any.The terms also apply to any Sysinternals\n* updates,\n*supplements,\n*Internet - based services,\n*and support services\nfor this software, unless other terms accompany those items.If so, those terms apply.\nBY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.IF YOU DO NOT ACCEPT THEM, DO NOT USE THE SOFTWARE.\n\nIf you comply with these license terms, you have the rights below.\nINSTALLATION AND USER RIGHTS\nYou may install and use any number of copies of the software on your devices.\n\nSCOPE OF LICENSE\nThe software is licensed, not sold.This agreement only gives you some rights to use the software.Sysinternals reserves all other rights.Unless applicable law gives you more rights despite this limitation, you may use the software only as expressly permitted in this agreement.In doing so, you must comply with any technical limitations in the software that only allow you to use it in certain ways.You may not\n* work around any technical limitations in the software;\n*reverse engineer, decompile or disassemble the software, except and only to the extent that applicable law expressly permits, despite this limitation;\n*make more copies of the software than specified in this agreement or allowed by applicable law, despite this limitation;\n*publish the software for others to copy;\n*rent, lease or lend the software;\n*transfer the software or this agreement to any third party; or\n* use the software for commercial software hosting services.\n\nSENSITIVE INFORMATION\nPlease be aware that, similar to other debug tools that capture "; // weak
BYTE Data[] =
{
  83u,
  121u,
  115u,
  116u,
  101u,
  109u,
  32u,
  66u,
  117u,
  115u,
  32u,
  69u,
  120u,
  116u,
  101u,
  110u,
  100u,
  101u,
  114u,
  0u
}; // idb
char byte_1400921B0 = '\x01'; // weak
char byte_1400921B1 = '\x01'; // weak
char byte_1400921B2 = '\x01'; // weak
char byte_1400921B3 = '\x01'; // weak
int dword_1400921B4 = -1; // weak
HANDLE hThread = (HANDLE)0xFFFFFFFFFFFFFFFFi64; // idb
HANDLE hDevice = (HANDLE)0xFFFFFFFFFFFFFFFFi64; // idb
char byte_1400921C8 = '\x01'; // weak
char byte_1400921C9 = '\x01'; // weak
char byte_1400921CA = '\x01'; // weak
char byte_1400921CB = '\x01'; // weak
char byte_1400921CC = '\x01'; // weak
char byte_1400921CD = '\x01'; // weak
char byte_1400921CE = '\x01'; // weak
int dword_1400921D0 = 1; // weak
int nIDButton = 1039; // idb
HANDLE qword_1400921D8 = (HANDLE)0xFFFFFFFFFFFFFFFFi64; // idb
int dword_1400921E0 = -1; // weak
CHAR aMemoryDmp[] = "memory.dmp"; // idb
_UNKNOWN unk_140092300; // weak
TBBUTTON Buttons = { 0, 0, 4u, 1u, { 0u, 0u, 0u, 0u, 0u, 0u }, 0ui64, 0i64 }; // idb
int dword_140092840 = 200; // weak
CHAR aDbgvclnt[] = "DBGVCLNT"; // idb
char aFiltersIni[] = "Filters.ini"; // idb
CHAR String2[] = "..."; // idb
CHAR asc_14009296C[] = ".."; // idb
CHAR asc_140092970[] = "."; // idb
char const *off_140092978 = "#"; // weak
int dword_140092980 = 20; // weak
int dword_140092990 = 90; // weak
int dword_1400929A0 = 200; // weak
uintptr_t _security_cookie = 47936899621426ui64;
__int64 qword_1400929D8 = 8239i64; // weak
HANDLE hConsoleHandle = (HANDLE)0xFFFFFFFFFFFFFFFEi64; // idb
//void *off_140092CF0 = &unk_140081542; // weak
void *off_140093028 = nullptr; //&unk_140092E00; // idb
_UNKNOWN unk_140093130; // weak
_UNKNOWN unk_140093240; // weak
int dword_1400933E8 = -2; // weak
HANDLE hConsoleOutput = (HANDLE)0xFFFFFFFFFFFFFFFEi64; // idb
_UNKNOWN unk_140093580; // weak
HWND qword_140093590 = NULL; // idb
HWND qword_140093598 = NULL; // idb
char byte_1400935A0 = '\0'; // weak
char byte_1400935A1 = '\0'; // weak
char byte_1400935A2 = '\0'; // weak
char byte_1400935A3 = '\0'; // weak
char byte_1400935A4 = '\0'; // weak
char byte_1400935A5 = '\0'; // weak
char byte_1400935A6 = '\0'; // weak
char byte_1400935A7 = '\0'; // weak
_UNKNOWN unk_1400935A8; // weak
char byte_1400935AC = '\0'; // weak
char byte_1400935AD = '\0'; // weak
char byte_1400935AE = '\0'; // weak
char byte_1400935AF = '\0'; // weak
LPARAM ArgList = 0i64; // idb
int dword_1400935B4 = 0; // weak
__int64 (__fastcall *qword_1400935B8)(_QWORD) = NULL; // weak
int dword_1400935C0 = 0; // weak
int dword_1400935C4 = 0; // weak
HWND qword_1400935C8 = NULL; // idb
char byte_1400935D0 = '\0'; // weak
char byte_1400935D1 = '\0'; // weak
FILE *Stream = NULL; // idb
void *qword_1400935E0 = NULL; // idb
HWND hWnd = NULL; // idb
int dword_1400935F8 = 0; // weak
char byte_1400935FC = '\0'; // weak
__int64 qword_140093600; // weak
HGDIOBJ h; // idb
HCURSOR hCursor; // idb
__int64 qword_140093618; // weak
char byte_140093620[4192]; // weak
char byte_140094680[264]; // weak
LPCSTR lpString; // idb
HWND qword_140094790; // idb
CHAR Buffer[4128]; // idb
LPARAM qword_1400957C0[33]; // weak
HWND qword_1400958C8; // idb
HWND hDlg; // idb
HWND qword_1400958D8; // idb
HWND qword_1400958E0; // idb
char byte_1400958F0; // weak
char byte_1400958F1; // weak
char byte_1400958F2; // weak
char byte_1400958F3; // weak
char byte_1400958F4; // weak
HANDLE hObject; // idb
__int64 qword_140095900; // weak
int dword_140095908; // weak
CHAR xmmword_140095910[]; // idb
HWND qword_140096930; // idb
HANDLE qword_140096938; // idb
char byte_140096940[4192]; // weak
HWND qword_1400979A0; // idb
COLORREF dword_1400979A8; // idb
LPARAM color; // idb
int dword_1400979B0; // weak
UINT Msg; // idb
int dword_1400979B8; // weak
int dword_1400979BC; // weak
char byte_1400979C0[256]; // weak
char byte_140097AC0; // weak
char byte_140097BC0; // weak
char byte_140097CC0; // weak
char byte_140097DC0; // weak
char byte_140097EC0; // weak
char byte_140097FC0; // weak
char byte_1400980C0; // weak
char byte_1400981C0; // weak
char byte_1400982C0; // weak
char byte_1400983C0; // weak
char byte_1400984C0; // weak
char byte_1400985C0; // weak
char byte_1400986C0; // weak
char byte_1400987C0; // weak
char byte_1400988C0; // weak
char byte_1400989C0; // weak
char byte_140098AC0; // weak
char byte_140098BC0; // weak
char byte_140098CC0; // weak
char byte_140098DC0[5120]; // weak
HWND qword_14009A1C0; // idb
HWND qword_14009A1C8; // idb
HWND qword_14009A1D0; // idb
HWND qword_14009A1D8; // idb
SC_HANDLE hSCObject; // idb
int dword_14009A1F0; // weak
int dword_14009A1F4; // weak
__int64 qword_14009A1F8; // weak
CHAR chText[4128]; // idb
int dword_14009B220; // weak
int dword_14009B224; // idb
int dword_14009B228; // weak
int dword_14009B22C; // weak
struct tagRECT rc; // idb
int dword_14009B240; // weak
int dword_14009B244; // weak
HANDLE hHandle; // idb
int dword_14009B250; // weak
int dword_14009B254; // weak
__int64 qword_14009B258; // weak
__int64 qword_14009B260; // weak
int dword_14009B268; // weak
HMODULE hModule; // idb
int dword_14009B278; // weak
HMODULE qword_14009B280; // idb
union _SLIST_HEADER stru_14009B850[2]; // weak
int dword_14009B870; // weak
int dword_14009B874; // weak
__int64 qword_14009B878; // weak
_UNKNOWN unk_14009B910; // weak
__int64 qword_14009B9C8; // weak
int dword_14009B9F0; // weak
__int64 qword_14009B9F8; // weak
int dword_14009BA1C; // weak
__int64 qword_14009C048; // weak
void *qword_14009C370; // idb
void *qword_14009C378; // idb
void *qword_14009C380; // idb
void *qword_14009C388; // idb
int dword_14009C39C; // weak
int dword_14009C3A0; // weak
_onexit_table_t stru_14009C3A8; // idb
__int64 qword_14009C3D8; // weak
__int64 qword_14009C3E0; // weak
_UNKNOWN unk_14009C3F0; // weak
_UNKNOWN unk_14009C490; // weak
__int64 qword_14009C7B0[128]; // weak
int dword_14009CBB0; // weak
int dword_14009CBFC; // weak
void *qword_14009CC00; // idb
void *qword_14009CC08; // idb
__int64 qword_14009CC10; // weak
__int64 qword_14009CC18; // weak
__int64 qword_14009CC20; // weak
__int64 qword_14009CC28; // weak
int dword_14009CC30; // weak
HANDLE hHeap; // idb
__int64 qword_14009CC48; // weak
int dword_14009CC80; // weak
_UNKNOWN unk_14009CC88; // weak
int dword_14009CCA0; // weak
_UNKNOWN unk_14009CCA4; // weak
HANDLE qword_14009DC98; // idb
SOCKET s; // idb
HWND qword_14009DCA8; // idb
__int64 qword_14009DCB0; // weak
_BYTE byte_14009DCC0[257]; // weak
char byte_14009DDC1; // weak
char byte_14009DEC2; // weak
char byte_14009DFC3; // weak
char byte_14009E0C4; // weak
int dword_14009E1C8; // weak
DWORD dwErrCode; // idb
HANDLE hEvent; // idb
HANDLE qword_14009E1D8; // idb
char byte_14009E1E0; // weak
char byte_14009E1E1; // weak
__int64 qword_14009E1E8; // weak
HWND qword_14009E1F0; // idb
__int64 qword_14009E1F8; // weak
int dword_14009E200; // weak
HANDLE qword_14009E208; // idb
__int64 qword_14009E210; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
char byte_14009E248; // weak
CHAR DateStr[64]; // idb
CHAR String[260]; // idb
int dword_14009E3A4; // weak
int dword_14009E3A8; // weak
_BYTE byte_14009E3C0[260]; // weak
char byte_14009E4C4; // weak
char byte_14009E4C5; // weak
_BYTE byte_14009E4E0[4128]; // weak
char byte_14009F500; // weak
struct tagFINDREPLACEA stru_14009F520; // idb
_BYTE byte_14009F580[4128]; // weak
HCURSOR qword_1400A05A0; // idb
HCURSOR qword_1400A05A8; // idb
HBITMAP qword_1400A05B0; // idb
__int64 qword_1400A05B8; // weak
__int64 qword_1400A05C0; // weak
HBITMAP hBitmapUnchecked; // idb
HBITMAP hBitmapChecked; // idb
LPARAM lParam[516]; // weak
CHAR TimeStr[]; // idb
__int64 qword_1400A2620; // weak
_UNKNOWN unk_1400A2640; // weak
char byte_1400A2641[]; // weak
char byte_1400A2642; // weak
HWND qword_1400A2648; // idb
char byte_1400A2650[280]; // idb
LARGE_INTEGER Frequency; // idb
char byte_1400A2770[]; // weak
char byte_1400A2772; // weak
char byte_1400A2773; // weak
char byte_1400A2776; // weak
_UNKNOWN unk_1400A2777; // weak
char byte_1400A277C; // weak
_UNKNOWN unk_1400A2780; // weak
_UNKNOWN unk_1400A2784; // weak
_UNKNOWN unk_1400A2790; // weak
_UNKNOWN unk_1400A27C8; // weak
_UNKNOWN unk_1400A2938; // weak
CHAR byte_1400A3540; // idb
_UNKNOWN unk_1400A3541; // weak
__int64 qword_1400A3648; // weak
void *Block; // idb
__int64 qword_1400A3660[]; // weak
char algn_1400A3668[24]; // weak
HANDLE qword_1400A3680; // idb
HANDLE qword_1400A3688; // idb
HANDLE qword_1400A3690; // idb
HANDLE qword_1400A3698; // idb
_UNKNOWN unk_1400A36A0; // weak
LARGE_INTEGER PerformanceCount; // idb
__int64 qword_1400A36B8; // weak
__int64 qword_1400A36C0; // weak
CHAR byte_1400A36E0[264]; // idb
HWND qword_1400A37E8; // idb
WNDPROC lpPrevWndFunc; // idb
HWND qword_1400A37F8; // idb
int dword_1400A3800; // weak
DWORD idAttachTo; // idb
HMENU qword_1400A3808; // idb
HMENU hMenu; // idb
HWND hWndParent; // idb
LOGFONTA lf; // idb
HGDIOBJ wParam; // idb
int dword_1400A3868; // weak
HINSTANCE hInstance; // idb
DWORD NumberOfBytesRead; // idb
_UNKNOWN unk_1400A3880; // weak
LPARAM byte_1400A4880; // idb
char byte_1400A4881; // weak
LPARAM String1[160]; // weak
char qword_1400A6180[1280]; // weak
char qword_1400A6680[1280]; // weak
_UNKNOWN unk_1400A6B80; // weak
_UNKNOWN unk_1400A6B81; // weak
__int64 qword_1400A7F80[5]; // weak
_UNKNOWN unk_1400A7FA8; // weak
_UNKNOWN unk_1400A7FD0; // weak
int dword_1400A8020[]; // weak
int dword_1400A8024; // weak
int dword_1400A8028; // weak
int dword_1400A802C; // weak
int dword_1400A8030; // weak
int dword_1400A8034[]; // weak
int dword_1400A8038; // weak
int dword_1400A803C; // weak
int dword_1400A8040; // weak
int dword_1400A8044; // weak
int dword_1400A8048[]; // weak
int dword_1400A804C; // weak
int dword_1400A8050; // weak
int dword_1400A8054; // weak
int dword_1400A8058; // weak
int dword_1400A805C; // weak
int dword_1400A8060; // weak
int dword_1400A8064; // weak
int dword_1400A8068; // weak
int dword_1400A806C; // weak
int dword_1400A8080[]; // weak
int dword_1400A8084; // weak
int dword_1400A8088; // weak
int dword_1400A808C; // weak
int dword_1400A8090; // weak
__int64 qword_1400A8094; // weak
__int64 qword_1400A809C; // weak
int dword_1400A80A4; // weak
int dword_1400A80A8[]; // weak
int dword_1400A80AC; // weak
int dword_1400A80B0; // weak
int dword_1400A80B4; // weak
__int64 qword_1400A80B8; // weak
__int64 qword_1400A80C0; // weak
__int64 qword_1400A80C8; // weak
char Source; // idb
char byte_1400A80E1; // weak
char byte_1400A81E0; // idb
char byte_1400A81E1; // weak
char byte_1400A82E0; // weak
BYTE dword_1400A8300; // idb
int X; // idb
int Y; // idb
int nWidth; // idb
int nHeight; // idb
int dword_1400A8314; // weak
int dword_1400A8318; // weak
__int64 qword_1400A831C; // weak
__int16 word_1400A8324; // weak
char byte_1400A8326; // weak
char byte_1400A8327; // weak
char byte_1400A8328; // weak
char byte_1400A8329; // weak
char byte_1400A832C[60]; // weak
int dword_1400A8368; // weak
int dword_1400A836C; // weak
int dword_1400A8370; // weak
int dword_1400A8374; // weak
int dword_1400A8378; // weak
int dword_1400A837C; // weak
int dword_1400A8380; // weak
int dword_1400A8384; // weak
int dword_1400A8388; // weak
int dword_1400A838C; // weak
int dword_1400A8390; // weak
char byte_1400A8394; // weak
int dword_1400A8398; // weak
__int16 word_1400A839C; // weak
char byte_1400A839E; // weak
char byte_1400A84A2; // weak
__int64 qword_1400A84A4; // weak
__int64 qword_1400A84AC; // weak
int dword_1400A84B4; // weak
int dword_1400A84B8; // weak
int dword_1400A84BC; // weak
int dword_1400A84C0; // weak
int dword_1400A84C4; // weak
int dword_1400A84C8; // weak
char byte_1400A84CC; // weak
char byte_1400A84CD; // weak
int dword_1400A84D0; // weak
int dword_1400A84D4; // weak
int dword_1400A84D8; // weak
int dword_1400A84DC; // weak
__int64 qword_1400A84E0; // weak
__int64 qword_1400A84E8; // weak
__int64 qword_1400A84F0; // weak
int dword_1400A84F8; // weak
int dword_1400A84FC; // weak
int dword_1400A8500; // weak
int dword_1400A8504; // weak
int dword_1400A8508; // weak
int dword_1400A850C; // weak
int dword_1400A8510; // weak
int dword_1400A8514; // weak
int dword_1400A8518; // weak
int dword_1400A851C; // weak
char byte_1400A8520; // weak
__int64 qword_1400A8528; // weak
_UNKNOWN unk_1400A8530; // weak
_UNKNOWN unk_1400A8540; // weak
_UNKNOWN unk_1400A8548; // weak


//----- (0000000140001000) ----------------------------------------------------
__int64 __fastcall sub_140001000(_BYTE *a1, __int64 a2, _QWORD *a3, _BYTE *a4, __int64 a5)
{
  __int64 result; // rax
  __int64 v6; // r10

  result = 0i64;
  v6 = 0i64;
  if ( !a2 )
    goto LABEL_6;
  do
  {
    if ( !a5 )
      break;
    if ( !*a4 )
      break;
    *a1 = *a4++;
    --a5;
    ++a1;
    ++v6;
    --a2;
  }
  while ( a2 );
  if ( !a2 )
  {
LABEL_6:
    --a1;
    result = 2147942522i64;
    --v6;
  }
  *a1 = 0;
  if ( a3 )
    *a3 = v6;
  return result;
}

//----- (00000001400010D4) ----------------------------------------------------
__int64 __fastcall sub_1400010D4(LPSTR lpDst)
{
  unsigned int v2; // ebx
  __int64 v3; // rsi
  int v4; // ecx
  signed __int64 v5; // rdx
  CHAR v6; // al
  DWORD Type; // [rsp+30h] [rbp-138h] BYREF
  DWORD cbData; // [rsp+34h] [rbp-134h] BYREF
  HKEY hKey; // [rsp+38h] [rbp-130h] BYREF
  BYTE Bytes[272]; // [rsp+40h] [rbp-128h] BYREF

  v2 = 0;
  if ( RegOpenKeyExA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{ADB880A6-D8FF-11CF-9377-00AA003B7A11}\\InprocServer32",
         0,
         0x20019u,
         &hKey) )
  {
    return 0i64;
  }
  v3 = 260i64;
  Type = 1;
  cbData = 260;
  if ( !RegQueryValueExA(hKey, 0i64, 0i64, &Type, Bytes, &cbData) )
  {
    Bytes[259] = 0;
    if ( Type == 2 )
    {
      LOBYTE(v2) = ExpandEnvironmentStringsA((LPCSTR)Bytes, lpDst, 0x104u) - 1 <= 0x103;
    }
    else
    {
      v4 = 0;
      v5 = Bytes - (BYTE *)lpDst;
      do
      {
        if ( v3 == -2147483386 )
          break;
        v6 = lpDst[v5];
        if ( !v6 )
          break;
        *lpDst++ = v6;
        --v3;
      }
      while ( v3 );
      if ( !v3 )
      {
        --lpDst;
        v4 = -2147024774;
      }
      *lpDst = 0;
      LOBYTE(v2) = v4 >= 0;
    }
  }
  RegCloseKey(hKey);
  return v2;
}

//----- (0000000140001208) ----------------------------------------------------
__int64 __fastcall sub_140001208(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  HMODULE LibraryA; // rax
  FARPROC ProcAddress; // r10
  CHAR LibFileName[272]; // [rsp+20h] [rbp-148h] BYREF

  LibraryA = hModule;
  if ( hModule
    || dword_14009B268
    || (!(unsigned int)sub_1400010D4(LibFileName)
      ? (LibraryA = hModule)
      : (LibraryA = LoadLibraryA(LibFileName), hModule = LibraryA),
        LibraryA || (LibraryA = LoadLibraryA("hhctrl.ocx"), (hModule = LibraryA) != 0i64)) )
  {
    ProcAddress = (FARPROC)qword_14009B260;
    if ( qword_14009B260 )
      return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64))ProcAddress)(a1, a2, a3, a4);
    ProcAddress = GetProcAddress(LibraryA, (LPCSTR)0xF);
    qword_14009B260 = (__int64)ProcAddress;
    if ( ProcAddress )
      return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64))ProcAddress)(a1, a2, a3, a4);
  }
  dword_14009B268 = 1;
  return 0i64;
}
// 14009B260: using guessed type __int64 qword_14009B260;
// 14009B268: using guessed type int dword_14009B268;

//----- (00000001400012F0) ----------------------------------------------------
__int64 __fastcall sub_1400012F0(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  HMODULE LibraryA; // rax
  FARPROC ProcAddress; // r10
  CHAR LibFileName[272]; // [rsp+20h] [rbp-148h] BYREF

  LibraryA = qword_14009B280;
  if ( qword_14009B280
    || dword_14009B278
    || (!(unsigned int)sub_1400010D4(LibFileName)
      ? (LibraryA = qword_14009B280)
      : (LibraryA = LoadLibraryA(LibFileName), qword_14009B280 = LibraryA),
        LibraryA || (LibraryA = LoadLibraryA("hhctrl.ocx"), (qword_14009B280 = LibraryA) != 0i64)) )
  {
    ProcAddress = (FARPROC)qword_14009B258;
    if ( qword_14009B258 )
      return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64))ProcAddress)(a1, a2, a3, a4);
    ProcAddress = GetProcAddress(LibraryA, (LPCSTR)0xE);
    qword_14009B258 = (__int64)ProcAddress;
    if ( ProcAddress )
      return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64))ProcAddress)(a1, a2, a3, a4);
  }
  dword_14009B278 = 1;
  return 0i64;
}
// 14009B258: using guessed type __int64 qword_14009B258;
// 14009B278: using guessed type int dword_14009B278;

//----- (00000001400013E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400013E0(__int64 a1)
{
  return (a1 + 3) & 0xFFFFFFFFFFFFFFFCui64;
}

//----- (00000001400013F0) ----------------------------------------------------
__int64 __fastcall sub_1400013F0(__int64 a1, wchar_t const *a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  __int64 v4; // r8
  __int16 v5; // cx

  v2 = -1i64;
  do
    ++v2;
  while ( a2[v2] );
  result = (unsigned int)(v2 + 1);
  v4 = a1 - (_QWORD)a2;
  do
  {
    v5 = *a2;
    *(__int16 *)((char *)a2 + v4) = *a2;
    ++a2;
  }
  while ( v5 );
  return result;
}

//----- (0000000140001430) ----------------------------------------------------
HBRUSH __fastcall DialogFunc(HWND a1, int a2, __int16 a3, const char *a4)
{
  int v6; // edx
  int v7; // edx
  HWND DlgItem; // rax
  void *v10; // rbx
  HWND v11; // rax
  HWND v12; // rax
  void *v13; // [rsp+20h] [rbp-148h] BYREF
  LPARAM lParam0; // [rsp+28h] [rbp-140h] BYREF
  int v15; // [rsp+30h] [rbp-138h]
  __int64 (__fastcall *v16)(const __m128i **, __m128i *, int, _DWORD *); // [rsp+34h] [rbp-134h]
  CHAR szBuf[272]; // [rsp+40h] [rbp-128h] BYREF

  v6 = a2 - 272;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( v7 )
    {
      if ( v7 == 39 && a4 == (const char *)GetDlgItem(a1, 500) )
        return GetSysColorBrush(5);
      return 0i64;
    }
    switch ( a3 )
    {
      case 1:
        EndDialog(a1, 1i64);
        break;
      case 2:
        EndDialog(a1, 0i64);
        break;
      case 501:
        DlgItem = GetDlgItem(a1, 500);
        sub_140001A40(DlgItem);
        break;
      default:
        return 0i64;
    }
  }
  else
  {
    v10 = sub_1400015C0();
    v13 = v10;
    v15 = 0;
    v16 = sub_1400023B0;
    lParam0 = (LPARAM)&v13;
    sub_140002490(szBuf, "%s License Agreement", a4);
    SetWindowTextA(a1, szBuf);
    v11 = GetDlgItem(a1, 500);
    SendMessageA(v11, 0x435u, 0i64, 0x100000i64);
    v12 = GetDlgItem(a1, 500);
    SendMessageA(v12, 0x449u, 2ui64, (LPARAM)&lParam0);
    j__free_base(v10);
  }
  return (HBRUSH)1;
}

//----- (00000001400015C0) ----------------------------------------------------
void *sub_1400015C0()
{
  char *v0; // rcx
  unsigned int v1; // ebx
  unsigned int v2; // r8d
  __int64 v3; // rdx
  __int64 v4; // rax
  void *v5; // rax
  char *v6; // r8
  void *v7; // r11
  __int64 v8; // r10
  char *v9; // rcx
  char v10; // al
  __int64 v11; // rax

  v0 = off_140092000[0];
  v1 = 0;
  v2 = 1;
  if ( off_140092000[0] )
  {
    v3 = 0i64;
    do
    {
      v4 = -1i64;
      do
        ++v4;
      while ( v0[v4] );
      v0 = off_140092000[++v3];
      v2 += v4;
    }
    while ( v0 );
  }
  v5 = j__malloc_base(v2);
  v6 = off_140092000[0];
  v7 = v5;
  if ( off_140092000[0] )
  {
    v8 = 0i64;
    do
    {
      v9 = v6;
      do
      {
        v10 = *v9;
        v9[(_QWORD)v7 + v1 - (_QWORD)v6] = *v9;
        ++v9;
      }
      while ( v10 );
      v11 = -1i64;
      do
        ++v11;
      while ( v6[v11] );
      v6 = off_140092000[++v8];
      v1 += v11;
    }
    while ( v6 );
  }
  *((_BYTE *)v7 + v1) = 0;
  return v7;
}
// 140092000: using guessed type char *off_140092000[48];

//----- (0000000140001690) ----------------------------------------------------
__int64 __fastcall sub_140001690(const char *a1, int *a2, __int64 a3)
{
  __int64 result; // rax

  if ( sub_140001780(a1) )
    return 1i64;
  result = sub_140001830(a2, a3);
  if ( (_DWORD)result )
    return 1i64;
  return result;
}

//----- (00000001400016E0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400016E0(HKEY a1, const CHAR *a2)
{
  LSTATUS v2; // ebx
  _BOOL8 result; // rax
  HKEY hKey; // [rsp+30h] [rbp-18h] BYREF
  int intData; // [rsp+60h] [rbp+18h] BYREF
  DWORD cbData; // [rsp+68h] [rbp+20h] BYREF

  hKey = 0i64;
  intData = 0;
  result = 0;
  if ( !RegOpenKeyExA(a1, a2, 0, 0x101u, &hKey) )
  {
    cbData = 4;
    v2 = RegQueryValueExA(hKey, "EulaAccepted", 0i64, 0i64, (LPBYTE)&intData, &cbData);
    RegCloseKey(hKey);
    if ( !v2 )
    {
      if ( intData )
        return 1;
    }
  }
  return result;
}

//----- (0000000140001780) ----------------------------------------------------
_BOOL8 __fastcall sub_140001780(const char *a1)
{
  _BOOL8 result; // rax
  char Buffer[272]; // [rsp+20h] [rbp-128h] BYREF

  sub_140002490(Buffer, "%s\\%s", "Software\\Sysinternals", a1);
  if ( sub_1400016E0(HKEY_LOCAL_MACHINE, "Software\\Sysinternals") )
    return 1i64;
  if ( sub_1400016E0(HKEY_CURRENT_USER, "Software\\Sysinternals") )
    return 1i64;
  result = sub_1400016E0(HKEY_CURRENT_USER, Buffer);
  if ( result )
    return 1i64;
  return result;
}

//----- (0000000140001830) ----------------------------------------------------
__int64 __fastcall sub_140001830(int *a1, __int64 a2)
{
  const char **v3; // rbx
  int v4; // edi

  if ( *a1 <= 1 )
    return 0i64;
  v3 = (const char **)(a2 + 8);
  v4 = 1;
  while ( stricmp(*v3, "/accepteula") && stricmp(*v3, "-accepteula") )
  {
    ++v4;
    ++v3;
    if ( v4 >= *a1 )
      return 0i64;
  }
  return 1i64;
}

//----- (00000001400018B0) ----------------------------------------------------
_BOOL8 sub_1400018B0()
{
  BOOL v0; // ebx
  DWORD cbData; // [rsp+30h] [rbp-238h] BYREF
  DWORD Type; // [rsp+34h] [rbp-234h] BYREF
  HKEY phkResult; // [rsp+38h] [rbp-230h] BYREF
  wchar_t szData[264]; // [rsp+40h] [rbp-228h] BYREF

  v0 = 0;
  cbData = 520;
  phkResult = 0i64;
  Type = 0;
  if ( !RegOpenKeyA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\windows nt\\currentversion", &phkResult) )
  {
    if ( !RegQueryValueExW(phkResult, L"ProductName", 0i64, &Type, (LPBYTE)szData, &cbData) )
      v0 = wcsicmp(L"iotuap", szData) == 0;
    RegCloseKey(phkResult);
  }
  return v0;
}
// 1400018B0: using guessed type wchar_t Data[264];

//----- (0000000140001970) ----------------------------------------------------
_BOOL8 sub_140001970()
{
  BOOL v0; // ebx
  DWORD Type; // [rsp+40h] [rbp+8h] BYREF
  int Data; // [rsp+48h] [rbp+10h] BYREF
  DWORD cbData; // [rsp+50h] [rbp+18h] BYREF
  HKEY phkResult; // [rsp+58h] [rbp+20h] BYREF

  v0 = 0;
  cbData = 4;
  phkResult = 0i64;
  Data = 0;
  Type = 0;
  if ( !RegOpenKeyA(
          HKEY_LOCAL_MACHINE,
          "Software\\Microsoft\\Windows NT\\CurrentVersion\\Server\\ServerLevels",
          &phkResult) )
  {
    if ( !RegQueryValueExA(phkResult, "NanoServer", 0i64, &Type, (LPBYTE)&Data, &cbData) && Type == 4 )
      v0 = Data == 1;
    RegCloseKey(phkResult);
  }
  return v0;
}

//----- (0000000140001A10) ----------------------------------------------------
_BOOL8 sub_140001A10()
{
  HANDLE StdHandle; // rax

  StdHandle = GetStdHandle(0xFFFFFFF5);
  return GetFileType(StdHandle) == 3;
}

//----- (0000000140001A40) ----------------------------------------------------
BOOL __fastcall sub_140001A40(HWND hWnd)
{
  HINSTANCE ModuleHandleA; // rax
  BOOL result; // eax
  HCURSOR CursorA; // rax
  HCURSOR v5; // r12
  int DeviceCaps; // r14d
  int v7; // edi
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  unsigned int v11; // ebx
  DOCINFOA v12; // [rsp+20h] [rbp-E0h] BYREF
  struct tagPDA pPD; // [rsp+50h] [rbp-B0h] BYREF
  LPARAM lParam; // [rsp+D0h] [rbp-30h] BYREF
  HDC hDC; // [rsp+D8h] [rbp-28h]
  struct tagRECT rc; // [rsp+E0h] [rbp-20h] BYREF
  struct tagRECT v17; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v18; // [rsp+100h] [rbp+0h]

  sub_140016650((__int64)&pPD, 0, 0x78ui64);
  pPD.lStructSize = 120;
  pPD.hwndOwner = hWnd;
  ModuleHandleA = GetModuleHandleA(0i64);
  pPD.Flags = 332;
  pPD.hInstance = ModuleHandleA;
  result = PrintDlgA(&pPD);
  if ( result )
  {
    CursorA = LoadCursorA(0i64, (LPCSTR)0x7F02);
    v5 = SetCursor(CursorA);
    DeviceCaps = GetDeviceCaps(pPD.hDC, 8);
    v7 = GetDeviceCaps(pPD.hDC, 10);
    v8 = GetDeviceCaps(pPD.hDC, 88);
    v9 = GetDeviceCaps(pPD.hDC, 90);
    lParam = 0i64;
    hDC = 0i64;
    *(_QWORD *)&rc.left = 0i64;
    *(_QWORD *)&rc.right = 0i64;
    v17 = (struct tagRECT)0i64;
    v18 = 0i64;
    *(&v12.cbSize + 1) = 0;
    memset(&v12.lpszOutput, 0, 24);
    SetMapMode(pPD.hDC, 1);
    lParam = (LPARAM)pPD.hDC;
    hDC = pPD.hDC;
    *(_QWORD *)&v17.left = 0i64;
    v17.bottom = 1440 * (v7 / v9);
    v17.right = 1440 * (DeviceCaps / v8);
    rc = v17;
    InflateRect(&rc, -1440, -1440);
    v12.lpszDocName = "Sysinternals License";
    v18 = 0xFFFFFFFF00000000ui64;
    v12.cbSize = 40;
    StartDocA(pPD.hDC, &v12);
    v10 = SendMessageA(hWnd, 0xEu, 0i64, 0i64);
    StartPage(pPD.hDC);
    v11 = SendMessageA(hWnd, 0x439u, 1ui64, (LPARAM)&lParam);
    EndPage(pPD.hDC);
    while ( (int)v11 < v10 )
    {
      v18 = v11 | 0xFFFFFFFF00000000ui64;
      StartPage(pPD.hDC);
      v11 = SendMessageA(hWnd, 0x439u, 1ui64, (LPARAM)&lParam);
      EndPage(pPD.hDC);
    }
    SendMessageA(hWnd, 0x439u, 0i64, 0i64);
    EndDoc(pPD.hDC);
    SetCursor(v5);
    return 1;
  }
  return result;
}

//----- (0000000140001CF0) ----------------------------------------------------
__int64 __fastcall sub_140001CF0(const char *dwInitParam, int *a2, __int64 a3)
{
  unsigned int v3; // r15d
  int v7; // edi
  int v8; // ebx
  __int64 v9; // rbp
  __int64 v10; // rsi
  int v11; // ecx

  v3 = 0;
  v7 = 0;
  if ( !a2 || !a3 )
    return sub_140002270(dwInitParam, 0i64, 0i64);
  v8 = 0;
  if ( *a2 > 0 )
  {
    v9 = 0i64;
    while ( 1 )
    {
      v10 = a3 + 8 * v9;
      if ( !stricmp(*(const char **)v10, "/accepteula") || (v7 = 0, !stricmp(*(const char **)v10, "-accepteula")) )
        v7 = 1;
      v11 = *a2;
      if ( v7 )
        break;
      ++v8;
      ++v9;
      if ( v8 >= v11 )
        goto LABEL_14;
    }
    if ( v8 < v11 - 1 )
    {
      do
      {
        ++v8;
        *(_QWORD *)v10 = *(_QWORD *)(v10 + 8);
        v10 += 8i64;
        v11 = *a2;
      }
      while ( v8 < *a2 - 1 );
    }
    *a2 = v11 - 1;
  }
LABEL_14:
  if ( (unsigned int)sub_140001EC0(dwInitParam, v7) )
    v7 = 1;
  LOBYTE(v3) = v7 != 0;
  return v3;
}

//----- (0000000140001E00) ----------------------------------------------------
__int64 sub_140001E00()
{
  unsigned int v0; // esi
  char v1; // di
  char v2; // bl

  v0 = 0;
  v1 = 0;
  sub_1400024F0((__int64)off_140092188);
  do
  {
    sub_140002430((__int64)"Accept Eula (Y/N)?");
    v2 = getch();
    sub_140002430((__int64)"%c\n", (unsigned int)v2);
    if ( ((v2 - 89) & 0xDF) == 0 )
    {
      v0 = 1;
      v1 = 1;
    }
  }
  while ( ((v2 - 78) & 0xDF) != 0 && v1 != 1 );
  return v0;
}
// 140092188: using guessed type wchar_t *off_140092188;

//----- (0000000140001E80) ----------------------------------------------------
void __noreturn sub_140001E80()
{
  sub_140002550((__int64)L"%ls", off_140092188);
  sub_140002550((__int64)L"This is the first run of this program. You must accept EULA to continue.\n");
  sub_140002550((__int64)L"Use -accepteula to accept EULA.\n\n");
  exit(1);
}
// 14007AE20: using guessed type wchar_t aLs[4];
// 14007AE30: using guessed type wchar_t aThisIsTheFirst[74];
// 14007AED0: using guessed type wchar_t aUseAccepteulaT[34];
// 140092188: using guessed type wchar_t *off_140092188;

//----- (0000000140001EC0) ----------------------------------------------------
__int64 __fastcall sub_140001EC0(const char *dwInitParam, int a2)
{
  unsigned int v3; // esi
  char *v4; // rdi
  char *v5; // r9
  int v6; // eax
  __int64 v7; // r9
  unsigned __int64 v8; // rax
  int v9; // eax
  __int64 v10; // r9
  unsigned __int64 v11; // rax
  int v12; // eax
  __int64 v13; // r9
  unsigned __int64 v14; // rax
  int v15; // eax
  __int64 v16; // r9
  unsigned __int64 v17; // rax
  int v18; // eax
  __int64 v19; // r9
  unsigned __int64 v20; // rax
  int v21; // eax
  __int64 v22; // r9
  int v23; // eax
  __int64 v24; // r10
  bool v25; // zf
  BYTE Data[4]; // [rsp+30h] [rbp-168h] BYREF
  HKEY phkResult; // [rsp+38h] [rbp-160h] BYREF
  CHAR SubKey[272]; // [rsp+40h] [rbp-158h] BYREF

  *(_DWORD *)Data = a2;
  v3 = 0;
  phkResult = 0i64;
  sub_140002490(SubKey, "Software\\Sysinternals\\%s", dwInitParam);
  if ( *(_DWORD *)Data )
    goto LABEL_16;
  *(_DWORD *)Data = sub_140001780(dwInitParam);
  if ( *(_DWORD *)Data )
    goto LABEL_16;
  if ( sub_1400018B0() )
  {
    *(_DWORD *)Data = sub_140001E00();
  }
  else
  {
    if ( sub_140001970() || sub_140001A10() )
      sub_140001E80();
    v4 = (char *)LocalAlloc(0x40u, 0x3E8ui64);
    LoadLibraryA("Riched32.dll");
    *(_DWORD *)v4 = -2134374192;
    *(_DWORD *)(v4 + 10) = 0;
    *(_DWORD *)(v4 + 14) = 11796792;
    *((_WORD *)v4 + 4) = 0;
    *(_DWORD *)(v4 + 18) = 0;
    v5 = &v4[2 * (int)sub_1400013F0((__int64)(v4 + 22), L"License Agreement") + 22];
    *(_WORD *)v5 = 8;
    v6 = sub_1400013F0((__int64)(v5 + 2), L"MS Shell Dlg");
    v8 = sub_1400013E0(v7 + 2i64 * v6);
    *(_WORD *)(v8 + 16) = 502;
    *(_DWORD *)(v8 + 8) = 196615;
    *(_DWORD *)(v8 + 12) = 917802;
    *(_DWORD *)v8 = 1342177280;
    *(_DWORD *)(v8 + 18) = 8585215;
    v9 = sub_1400013F0(v8 + 22, L"You can also use the /accepteula command-line switch to accept the EULA.");
    v10 += 6i64;
    *(_WORD *)(v10 + 2i64 * v9 - 2) = 0;
    ++*((_WORD *)v4 + 4);
    v11 = sub_1400013E0(v10 + 2i64 * v9);
    *(_WORD *)(v11 + 16) = 1;
    *(_DWORD *)(v11 + 8) = 10420425;
    *(_DWORD *)(v11 + 12) = 917554;
    *(_DWORD *)v11 = 1342242816;
    *(_DWORD *)(v11 + 18) = 8454143;
    v12 = sub_1400013F0(v11 + 22, L"&Agree");
    v13 += 6i64;
    *(_WORD *)(v13 + 2i64 * v12 - 2) = 0;
    ++*((_WORD *)v4 + 4);
    v14 = sub_1400013E0(v13 + 2i64 * v12);
    *(_WORD *)(v14 + 16) = 2;
    *(_DWORD *)(v14 + 8) = 10420479;
    *(_DWORD *)(v14 + 12) = 917554;
    *(_DWORD *)v14 = 1342242816;
    *(_DWORD *)(v14 + 18) = 8454143;
    v15 = sub_1400013F0(v14 + 22, L"&Decline");
    v16 += 6i64;
    *(_WORD *)(v16 + 2i64 * v15 - 2) = 0;
    ++*((_WORD *)v4 + 4);
    v17 = sub_1400013E0(v16 + 2i64 * v15);
    *(_DWORD *)(v17 + 8) = 10420231;
    *(_DWORD *)(v17 + 12) = 917554;
    *(_WORD *)(v17 + 16) = 501;
    *(_DWORD *)v17 = 1342242816;
    *(_DWORD *)(v17 + 18) = 8454143;
    v18 = sub_1400013F0(v17 + 22, L"&Print");
    v19 += 6i64;
    *(_WORD *)(v19 + 2i64 * v18 - 2) = 0;
    ++*((_WORD *)v4 + 4);
    v20 = sub_1400013E0(v19 + 2i64 * v18);
    *(_WORD *)(v20 + 16) = 500;
    *(_DWORD *)(v20 + 8) = 917511;
    *(_DWORD *)(v20 + 12) = 9175338;
    *(_DWORD *)v20 = 1352734788;
    v21 = sub_1400013F0(v20 + 18, L"RICHEDIT");
    v23 = sub_1400013F0(v22 + 2i64 * v21, L"&Decline");
    *(_WORD *)(v24 + 2i64 * v23) = 0;
    ++*((_WORD *)v4 + 4);
    *(_DWORD *)Data = DialogBoxIndirectParamA(0i64, (LPCDLGTEMPLATEA)v4, 0i64, (DLGPROC)DialogFunc, (LPARAM)dwInitParam);
    LocalFree(v4);
  }
  v25 = *(_DWORD *)Data == 0;
  if ( *(_DWORD *)Data )
  {
LABEL_16:
    if ( !RegCreateKeyA(HKEY_CURRENT_USER, SubKey, &phkResult) )
    {
      RegSetValueExA(phkResult, "EulaAccepted", 0, 4u, Data, 4u);
      RegCloseKey(phkResult);
    }
    v25 = *(_DWORD *)Data == 0;
  }
  LOBYTE(v3) = !v25;
  return v3;
}
// 140001FEE: variable 'v7' is possibly undefined
// 140002032: variable 'v10' is possibly undefined
// 140002084: variable 'v13' is possibly undefined
// 1400020D6: variable 'v16' is possibly undefined
// 140002128: variable 'v19' is possibly undefined
// 14000217D: variable 'v22' is possibly undefined
// 14000219A: variable 'v24' is possibly undefined
// 14007AB90: using guessed type wchar_t aLicenseAgreeme[18];
// 14007ABB8: using guessed type wchar_t aMsShellDlg[13];
// 14007ABE0: using guessed type wchar_t aYouCanAlsoUseT[73];
// 14007AC78: using guessed type wchar_t aAgree[7];
// 14007AC88: using guessed type wchar_t aDecline[9];
// 14007ACA0: using guessed type wchar_t aPrint[7];
// 14007ACB0: using guessed type wchar_t aRichedit[9];

//----- (0000000140002270) ----------------------------------------------------
__int64 __fastcall sub_140002270(const char *dwInitParam, int *a2, __int64 a3)
{
  unsigned int v3; // r15d
  __int64 v4; // r12
  int *v5; // r14
  int v7; // edi
  HMODULE LibraryA; // rax
  FARPROC ProcAddress; // rbx
  LPWSTR CommandLineW; // rax
  int v11; // ebx
  __int64 v12; // rbp
  __int64 v13; // rsi
  int v14; // ecx

  v3 = 0;
  v4 = a3;
  v5 = a2;
  v7 = 0;
  if ( !a2 || !a3 )
  {
    LibraryA = LoadLibraryA("Shell32.dll");
    ProcAddress = GetProcAddress(LibraryA, "CommandLineToArgvW");
    if ( !ProcAddress )
      goto LABEL_16;
    v5 = (int *)&unk_140093580;
    CommandLineW = GetCommandLineW();
    v4 = ((__int64 (__fastcall *)(LPWSTR, void *))ProcAddress)(CommandLineW, &unk_140093580);
  }
  v11 = 0;
  if ( *v5 > 0 )
  {
    v12 = 0i64;
    while ( 1 )
    {
      v13 = v4 + 8 * v12;
      if ( !wcsicmp(*(const wchar_t **)v13, L"/accepteula")
        || (v7 = 0, !wcsicmp(*(const wchar_t **)v13, L"-accepteula")) )
      {
        v7 = 1;
      }
      v14 = *v5;
      if ( v7 )
        break;
      ++v11;
      ++v12;
      if ( v11 >= v14 )
        goto LABEL_16;
    }
    if ( v11 < v14 - 1 )
    {
      do
      {
        ++v11;
        *(_QWORD *)v13 = *(_QWORD *)(v13 + 8);
        v13 += 8i64;
        v14 = *v5;
      }
      while ( v11 < *v5 - 1 );
    }
    *v5 = v14 - 1;
  }
LABEL_16:
  if ( (unsigned int)sub_140001EC0(dwInitParam, v7) )
    v7 = 1;
  LOBYTE(v3) = v7 != 0;
  return v3;
}

//----- (00000001400023B0) ----------------------------------------------------
__int64 __fastcall sub_1400023B0(const __m128i **a1, __m128i *a2, int a3, _DWORD *a4)
{
  int v5; // edi
  const __m128i *v8; // rdx
  __int64 v9; // rax

  v5 = a3;
  v8 = *a1;
  v9 = -1i64;
  do
    ++v9;
  while ( v8->m128i_i8[v9] );
  if ( a3 > v9 )
    v5 = v9;
  sub_1400161F0(a2, v8, v5);
  *a4 = v5;
  *a1 = (const __m128i *)((char *)*a1 + v5);
  return 0i64;
}

//----- (0000000140002420) ----------------------------------------------------
void *sub_140002420()
{
  return &unk_1400A8530;
}

//----- (0000000140002430) ----------------------------------------------------
__int64 sub_140002430(__int64 a1, ...)
{
  FILE *v2; // rbx
  __int64 *v3; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, a1);
  v2 = _acrt_iob_func(1u);
  v3 = (__int64 *)sub_140002420();
  return sub_14003B384(*v3, (__int64)v2, a1, 0i64, (__int64)va);
}

//----- (0000000140002490) ----------------------------------------------------
int sub_140002490(char *Buffer, char const *Format, ...)
{
  _QWORD *v4; // rax
  int result; // eax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = sub_140002420();
  result = _stdio_common_vsprintf(*v4 | 1i64, Buffer, 0xFFFFFFFFFFFFFFFFui64, Format, 0i64, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (00000001400024F0) ----------------------------------------------------
__int64 sub_1400024F0(__int64 a1, ...)
{
  FILE *v2; // rbx
  __int64 *v3; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, a1);
  v2 = _acrt_iob_func(1u);
  v3 = (__int64 *)sub_140002420();
  return sub_14003B528(*v3, (__int64)v2, a1, 0i64, (__int64)va);
}

//----- (0000000140002550) ----------------------------------------------------
__int64 sub_140002550(__int64 a1, ...)
{
  FILE *v2; // rbx
  __int64 *v3; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, a1);
  v2 = _acrt_iob_func(1u);
  v3 = (__int64 *)sub_140002420();
  return sub_14003B640(*v3, (__int64)v2, a1, 0i64, (__int64)va);
}

//----- (00000001400025B0) ----------------------------------------------------
char __fastcall sub_1400025B0(BYTE a1)
{
  __int64 cbData; // rax
  BYTE v3[8]; // [rsp+30h] [rbp-258h] BYREF
  HKEY phkResult; // [rsp+38h] [rbp-250h] BYREF
  BYTE lpData[4]; // [rsp+40h] [rbp-248h] BYREF
  BYTE Data[4]; // [rsp+44h] [rbp-244h] BYREF
  CHAR SubKey[272]; // [rsp+50h] [rbp-238h] BYREF
  BYTE v8[272]; // [rsp+160h] [rbp-128h] BYREF

  v3[0] = a1;
  *(_DWORD *)Data = 0;
  if ( byte_1400A82E0 )
  {
    if ( RegCreateKeyA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Dbgv", &phkResult) )
      return 0;
    RegDeleteValueA(phkResult, "DeleteFlag");
    RegSetValueExA(phkResult, "Start", 0, 4u, Data, 4u);
    RegSetValueExA(phkResult, "Group", 0, 1u, ::Data, 0x14u);
    *(_DWORD *)lpData = 1;
    RegSetValueExA(phkResult, "Tag", 0, 4u, lpData, 4u);
    RegSetValueExA(phkResult, "Type", 0, 4u, lpData, 4u);
    sub_140002490((char *)v8, "System32\\Drivers\\%s", "Dbgv.sys");
    cbData = -1i64;
    do
      ++cbData;
    while ( v8[cbData] );
    RegSetValueExA(phkResult, "ImagePath", 0, 2u, v8, cbData);
    RegSetValueExA(phkResult, "LogVerbose", 0, 4u, v3, 1u);
    RegCloseKey(phkResult);
  }
  else
  {
    sub_140002490(SubKey, "%s\\Enum", "System\\CurrentControlSet\\Services\\Dbgv");
    RegDeleteKeyA(HKEY_LOCAL_MACHINE, SubKey);
    sub_140002490(SubKey, "%s\\Security", "System\\CurrentControlSet\\Services\\Dbgv");
    RegDeleteKeyA(HKEY_LOCAL_MACHINE, SubKey);
    RegDeleteKeyA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Dbgv");
  }
  return 1;
}
// 1400A82E0: using guessed type char byte_1400A82E0;
// 1400025B0: using guessed type BYTE var_258[8];
// 1400025B0: using guessed type BYTE var_128[272];

//----- (0000000140002810) ----------------------------------------------------
DWORD __fastcall sub_140002810(HWND hWnd, BYTE a2)
{
  DWORD result; // eax
  const CHAR *v5; // rcx
  UINT v6; // ebx
  HMENU Menu; // rax
  CHAR FileName[272]; // [rsp+20h] [rbp-238h] BYREF
  CHAR Buffer[272]; // [rsp+130h] [rbp-128h] BYREF

  byte_1400A82E0 = byte_1400A82E0 == 0;
  if ( !GetEnvironmentVariableA("SYSTEMROOT", Buffer, 0x104u) )
  {
    strcpy(TimeStr, "Could not resolve SYSTEMROOT environment variable");
    return MessageBoxA(hWnd, TimeStr, "DebugView", 0x10u);
  }
  sub_140002490(FileName, "%s\\System32\\Drivers\\%s", Buffer, "Dbgv.sys");
  if ( byte_1400A82E0 )
  {
    if ( qword_1400935B8 )
      qword_1400935B8(0i64);
    v5 = "RCDBGSYS";
    if ( dword_1400A3868 )
      v5 = "RCDBGSYS64";
    if ( !sub_14000CCC0(v5, FileName) && GetLastError() != 32 )
    {
      result = MessageBoxA(hWnd, "Could not install DebugView driver.", "DebugView", 0x10u);
      byte_1400A82E0 = 0;
      return result;
    }
    if ( qword_1400935B8 )
      qword_1400935B8(1i64);
    if ( !sub_1400025B0(a2) )
    {
      MessageBoxA(hWnd, "Could not configure DebugView boot log Registry key.", "DebugView", 0x10u);
      byte_1400A82E0 = 0;
      return DeleteFileA(FileName);
    }
    sub_140002490(TimeStr, "DebugView has been configured to buffer kernel debug output at the next boot.");
    MessageBoxA(hWnd, TimeStr, "DebugView", 0x40u);
  }
  else
  {
    sub_1400025B0(0);
    DeleteFileA(FileName);
  }
  v6 = byte_1400A82E0 != 0 ? 8 : 0;
  Menu = GetMenu(hWnd);
  return CheckMenuItem(Menu, 0x9C78u, v6);
}
// 1400935B8: using guessed type __int64 (__fastcall *qword_1400935B8)(_QWORD);
// 1400A3868: using guessed type int dword_1400A3868;
// 1400A82E0: using guessed type char byte_1400A82E0;

//----- (0000000140002A40) ----------------------------------------------------
DWORD __fastcall sub_140002A40(HWND hWnd)
{
  HMENU Menu; // rax
  HMENU SubMenu; // rax
  int MenuItemCount; // ebx
  HMENU v5; // rax
  HMENU v6; // rax
  HMENU v7; // rax
  HMENU v8; // rax
  int v9; // ebx
  HMENU v10; // rax
  HMENU v11; // rax
  char v12; // cl
  UINT v13; // ebx
  HMENU v14; // rax
  HKEY phkResult; // [rsp+30h] [rbp-68h] BYREF
  MENUITEMINFOA mi; // [rsp+40h] [rbp-58h] BYREF
  int Data; // [rsp+A8h] [rbp+10h] BYREF
  DWORD cbData; // [rsp+B0h] [rbp+18h] BYREF
  DWORD Type; // [rsp+B8h] [rbp+20h] BYREF

  mi.cbSize = 80;
  mi.fMask = 16;
  mi.fType = 2048;
  Menu = GetMenu(hWnd);
  SubMenu = GetSubMenu(Menu, 2);
  MenuItemCount = GetMenuItemCount(SubMenu);
  v5 = GetMenu(hWnd);
  v6 = GetSubMenu(v5, 2);
  InsertMenuItemA(v6, MenuItemCount, 1, &mi);
  *(_QWORD *)&mi.fMask = 18i64;
  mi.dwTypeData = "Log &Boot";
  mi.wID = 40056;
  v7 = GetMenu(hWnd);
  v8 = GetSubMenu(v7, 2);
  v9 = GetMenuItemCount(v8);
  v10 = GetMenu(hWnd);
  v11 = GetSubMenu(v10, 2);
  InsertMenuItemA(v11, v9, 1, &mi);
  Data = 3;
  if ( !RegOpenKeyA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Dbgv", &phkResult) )
  {
    cbData = 4;
    RegQueryValueExA(phkResult, "Start", 0i64, &Type, (LPBYTE)&Data, &cbData);
    RegCloseKey(phkResult);
  }
  v12 = Data != 3;
  byte_1400A82E0 = Data != 3;
  if ( Data == 3 )
  {
    sub_1400025B0(0);
    v12 = byte_1400A82E0;
  }
  v13 = v12 != 0 ? 8 : 0;
  v14 = GetMenu(hWnd);
  return CheckMenuItem(v14, 0x9C78u, v13);
}
// 1400A82E0: using guessed type char byte_1400A82E0;

//----- (0000000140002BF0) ----------------------------------------------------
__int64 __fastcall sub_140002BF0(HWND hWnd, const char *a2)
{
  DWORD LastError; // eax
  HLOCAL Buffer[2]; // [rsp+40h] [rbp-128h] BYREF
  CHAR Text[256]; // [rsp+50h] [rbp-118h] BYREF

  LastError = GetLastError();
  FormatMessageA(0x1100u, 0i64, LastError, 0x400u, (LPSTR)Buffer, 0, 0i64);
  sub_140002490(Text, "%s: %s", a2, (const char *)Buffer[0]);
  MessageBoxA(hWnd, Text, "DebugView", 0x10u);
  PostQuitMessage(1);
  LocalFree(Buffer[0]);
  return 0xFFFFFFFFi64;
}
// 140002BF0: using guessed type HLOCAL Buffer[2];

//----- (0000000140002CC0) ----------------------------------------------------
INT_PTR __fastcall sub_140002CC0(HWND a1, unsigned int a2, HDC a3, HWND a4)
{
  unsigned int v6; // edx
  unsigned int v7; // edx
  DWORD SysColor; // edx
  HGDIOBJ v10; // rdx
  unsigned int v11; // edx
  HWND v12; // rax
  int v13; // ecx
  bool v14; // zf
  int v15; // eax
  HCURSOR v16; // rcx
  POINT Point; // [rsp+30h] [rbp-58h]
  POINT Pointa; // [rsp+30h] [rbp-58h]
  LOGFONTA pv; // [rsp+38h] [rbp-50h] BYREF

  if ( a2 > 0x138 )
  {
    v11 = a2 - 512;
    if ( v11 )
    {
      if ( v11 == 1 )
      {
        Point.x = (unsigned __int16)a4;
        Point.y = WORD1(a4);
        if ( ChildWindowFromPoint(a1, Point) == hWnd )
          ShellExecuteA(a1, "open", "http://www.sysinternals.com", 0i64, 0i64, 1);
      }
    }
    else
    {
      Pointa.x = (unsigned __int16)a4;
      Pointa.y = WORD1(a4);
      v12 = ChildWindowFromPoint(a1, Pointa);
      v13 = 0;
      v14 = v12 == hWnd;
      v15 = dword_1400935F8;
      if ( dword_1400935F8 == v14 )
      {
        LOBYTE(v13) = dword_1400935F8 == 0;
        dword_1400935F8 = v13;
        InvalidateRect(hWnd, 0i64, 0);
        v15 = dword_1400935F8;
      }
      v16 = (HCURSOR)qword_140093618;
      if ( !v15 )
        v16 = hCursor;
      SetCursor(v16);
    }
    return 0i64;
  }
  if ( a2 != 312 )
  {
    v6 = a2 - 16;
    if ( !v6 )
    {
LABEL_8:
      EndDialog(a1, 0i64);
      return 1i64;
    }
    v7 = v6 - 256;
    if ( !v7 )
    {
      dword_1400935F8 = 1;
      hWnd = GetDlgItem(a1, 1030);
      qword_140093600 = (__int64)GetStockObject(17);
      GetObjectA((HANDLE)qword_140093600, 60, &pv);
      pv.lfUnderline = 1;
      h = CreateFontIndirectA(&pv);
      hCursor = LoadCursorA(hInstance, "HAND");
      qword_140093618 = (__int64)LoadCursorA(0i64, (LPCSTR)0x7F00);
      return 1i64;
    }
    if ( v7 == 1 && (a3 == (HDC)2 || a3 == (HDC)1005) )
      goto LABEL_8;
    return 0i64;
  }
  if ( a4 != hWnd )
    return 0i64;
  SetBkMode(a3, 1);
  if ( GetSysColorBrush(26) )
    SysColor = GetSysColor(26);
  else
    SysColor = 16711680;
  SetTextColor(a3, SysColor);
  v10 = (HGDIOBJ)qword_140093600;
  if ( dword_1400935F8 )
    v10 = h;
  SelectObject(a3, v10);
  return (INT_PTR)GetSysColorBrush(15);
}
// 1400935F8: using guessed type int dword_1400935F8;
// 140093600: using guessed type __int64 qword_140093600;
// 140093618: using guessed type __int64 qword_140093618;

//----- (0000000140002F30) ----------------------------------------------------
BOOL __fastcall sub_140002F30(HWND a1, unsigned int a2, unsigned int a3)
{
  __int64 v4; // rdx
  __int64 v5; // rsi
  HMENU v6; // rax
  UINT v7; // r8d
  HMENU Menu; // rax
  _DWORD *v9; // rax
  __int64 v10; // rbx
  HMENU v11; // rax
  HMENU SubMenu; // rax
  HMENU v13; // rax
  HMENU v14; // rax
  MENUITEMINFOA mi; // [rsp+20h] [rbp-58h] BYREF

  v4 = 384i64 * a2;
  v5 = 384i64 * a3;
  *((_BYTE *)&unk_1400A2640 + v4 + 304) = byte_1400921B2;
  *((_BYTE *)&unk_1400A2640 + v4 + 308) = byte_1400921CA;
  *((_BYTE *)&unk_1400A2640 + v4 + 306) = byte_1400921C9;
  *((_BYTE *)&unk_1400A2640 + v4 + 307) = byte_1400935A2;
  *((_BYTE *)&unk_1400A2640 + v4 + 310) = byte_1400935A3;
  *((_BYTE *)&unk_1400A2640 + v4 + 305) = byte_1400921C8;
  *((_BYTE *)&unk_1400A2640 + v4 + 309) = byte_1400921B0;
  *((_BYTE *)&unk_1400A2640 + v4 + 311) = byte_1400921CB;
  byte_1400921B2 = *((_BYTE *)&unk_1400A2640 + v5 + 304);
  byte_1400921CA = *((_BYTE *)&unk_1400A2640 + v5 + 308);
  byte_1400921C9 = *((_BYTE *)&unk_1400A2640 + v5 + 306);
  byte_1400935A2 = *((_BYTE *)&unk_1400A2640 + v5 + 307);
  byte_1400935A3 = *((_BYTE *)&unk_1400A2640 + v5 + 310);
  byte_1400921C8 = *((_BYTE *)&unk_1400A2640 + v5 + 305);
  byte_1400921B0 = *((_BYTE *)&unk_1400A2640 + v5 + 309);
  byte_1400921CB = *((_BYTE *)&unk_1400A2640 + v5 + 311);
  if ( !a3 && !byte_1400921B1 )
    goto LABEL_6;
  if ( !*((_BYTE *)&unk_1400A2640 + v5 + 1) )
  {
    Menu = GetMenu(a1);
    EnableMenuItem(Menu, 0x9C63u, 0);
    v9 = (_DWORD *)qword_14009E1E8;
    if ( *(_DWORD *)qword_14009E1E8 != -1 )
    {
      v10 = 0i64;
      do
      {
        SendMessageA(qword_1400A37E8, 0x401u, (int)v9[1], 1i64);
        ++v10;
        v9 = (_DWORD *)(32 * v10 + qword_14009E1E8);
      }
      while ( *v9 != -1 );
    }
    EnableMenuItem(hMenu, 0x9C52u, 0);
    CheckMenuItem(hMenu, 0x9C52u, byte_1400921B2 != 0 ? 8 : 0);
    SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C52ui64, (byte_1400921B2 != 0) + 1i64);
    CheckMenuItem(hMenu, 0x9C6Du, byte_1400921CB != 0 ? 8 : 0);
    EnableMenuItem(hMenu, 0x9C5Cu, 0);
    CheckMenuItem(hMenu, 0x9C5Cu, byte_1400921C9 != 0 ? 8 : 0);
    SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Cui64, 13i64 - (byte_1400921C9 != 0));
    if ( !*((_BYTE *)&unk_1400A2640 + v5 + 2) )
    {
      EnableMenuItem(hMenu, 0x9C5Fu, 0);
      CheckMenuItem(hMenu, 0x9C5Fu, byte_1400921CA != 0 ? 8 : 0);
      SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Fui64, 18i64 - (byte_1400921CA != 0));
      EnableMenuItem(hMenu, 0x9C5Au, 0);
      CheckMenuItem(hMenu, 0x9C5Au, byte_1400921C8 != 0 ? 8 : 0);
      SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Aui64, 10i64 - (byte_1400921C8 != 0));
    }
    mi.cbSize = 80;
    *(_QWORD *)&mi.fMask = 19i64;
    if ( a3 || !byte_14009E1E0 )
    {
      SubMenu = GetSubMenu(hMenu, 2);
      DeleteMenu(SubMenu, 0x9C7Cu, 0);
      if ( a3 )
        goto LABEL_20;
    }
    else
    {
      mi.wID = 40060;
      mi.dwTypeData = "Enable &Verbose Kernel Output";
      mi.fState = byte_1400935A3 != 0 ? 8 : 0;
      v11 = GetSubMenu(hMenu, 2);
      InsertMenuItemA(v11, 3u, 1, &mi);
    }
    if ( byte_1400935A0 )
    {
      mi.wID = 40054;
      mi.dwTypeData = "Capture &Global Win32";
      mi.fState = byte_1400935A2 != 0 ? 8 : 0;
      v13 = GetSubMenu(hMenu, 2);
      InsertMenuItemA(v13, 1u, 1, &mi);
      goto LABEL_21;
    }
LABEL_20:
    v14 = GetSubMenu(hMenu, 2);
    DeleteMenu(v14, 0x9C76u, 0);
    goto LABEL_21;
  }
  if ( a3 || byte_1400921B1 )
  {
    v6 = GetMenu(a1);
    v7 = 0;
    goto LABEL_8;
  }
LABEL_6:
  v6 = GetMenu(a1);
  v7 = 1;
LABEL_8:
  EnableMenuItem(v6, 0x9C63u, v7);
  SendMessageA(qword_1400A37E8, 0x401u, 0x9C52ui64, 0i64);
  CheckMenuItem(hMenu, 0x9C52u, 0);
  EnableMenuItem(hMenu, 0x9C52u, 1u);
  CheckMenuItem(hMenu, 0x9C6Du, byte_1400921CB != 0 ? 8 : 0);
  SendMessageA(qword_1400A37E8, 0x401u, 0x9C5Cui64, 0i64);
  CheckMenuItem(hMenu, 0x9C5Cu, 0);
  EnableMenuItem(hMenu, 0x9C5Cu, 1u);
  SendMessageA(qword_1400A37E8, 0x401u, 0x9C5Fui64, 0i64);
  CheckMenuItem(hMenu, 0x9C5Fu, 0);
  EnableMenuItem(hMenu, 0x9C5Fu, 1u);
  SendMessageA(qword_1400A37E8, 0x401u, 0x9C5Aui64, 0i64);
  CheckMenuItem(hMenu, 0x9C5Au, 0);
  EnableMenuItem(hMenu, 0x9C5Au, 1u);
LABEL_21:
  CheckMenuItem(hMenu, 0x9C74u, byte_1400921B0 != 0 ? 8 : 0);
  return InvalidateRect(qword_1400A37E8, 0i64, 1);
}
// 1400921B0: using guessed type char byte_1400921B0;
// 1400921B1: using guessed type char byte_1400921B1;
// 1400921B2: using guessed type char byte_1400921B2;
// 1400921C8: using guessed type char byte_1400921C8;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400921CB: using guessed type char byte_1400921CB;
// 1400935A0: using guessed type char byte_1400935A0;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935A3: using guessed type char byte_1400935A3;
// 14009E1E0: using guessed type char byte_14009E1E0;
// 14009E1E8: using guessed type __int64 qword_14009E1E8;

//----- (0000000140003540) ----------------------------------------------------
char __fastcall sub_140003540(HWND hwnd, char *String1)
{
  CHAR *v4; // rbx
  LPITEMIDLIST v5; // rax
  char *v6; // rcx
  char v7; // dl
  struct _browseinfoA bi; // [rsp+20h] [rbp-48h] BYREF
  IMalloc *ppMalloc; // [rsp+80h] [rbp+18h] BYREF
  LPITEMIDLIST ppidl; // [rsp+88h] [rbp+20h] BYREF

  SHGetMalloc(&ppMalloc);
  v4 = (CHAR *)((__int64 (__fastcall *)(IMalloc *, __int64))ppMalloc->lpVtbl->Alloc)(ppMalloc, 260i64);
  if ( !v4 )
    return 0;
  if ( SHGetSpecialFolderLocation(hwnd, 18, &ppidl) < 0 )
  {
LABEL_10:
    ((void (__fastcall *)(IMalloc *, CHAR *))ppMalloc->lpVtbl->Free)(ppMalloc, v4);
    return 0;
  }
  bi.pidlRoot = ppidl;
  bi.lpszTitle = "Select Remote Computer";
  bi.lpfn = 0i64;
  bi.lParam = 0i64;
  bi.hwndOwner = hwnd;
  bi.pszDisplayName = v4;
  bi.ulFlags = 4096;
  v5 = SHBrowseForFolderA(&bi);
  if ( !v5 )
  {
    ((void (__fastcall *)(IMalloc *, LPITEMIDLIST))ppMalloc->lpVtbl->Free)(ppMalloc, ppidl);
    goto LABEL_10;
  }
  v6 = v4;
  do
  {
    v7 = *v6;
    v6[String1 - v4] = *v6;
    ++v6;
  }
  while ( v7 );
  ((void (__fastcall *)(IMalloc *, LPITEMIDLIST))ppMalloc->lpVtbl->Free)(ppMalloc, v5);
  ((void (__fastcall *)(IMalloc *, LPITEMIDLIST))ppMalloc->lpVtbl->Free)(ppMalloc, ppidl);
  ((void (__fastcall *)(IMalloc *, CHAR *))ppMalloc->lpVtbl->Free)(ppMalloc, v4);
  if ( stricmp(String1, &byte_1400A3540) )
    return 1;
  MessageBoxA(0i64, "The local computer cannot be selected for remote monitoring.", "DebugView", 0x10u);
  return 0;
}

//----- (00000001400036E0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400036E0(HWND a1, int a2)
{
  HANDLE v4; // rax
  unsigned int v5; // edx

  if ( a2 != 16 )
    return a2 == 272;
  EnterCriticalSection(&CriticalSection);
  v4 = hThread;
  if ( hThread != (HANDLE)-1i64 )
  {
    TerminateThread(hThread, 0);
    v4 = hThread;
  }
  v5 = dword_1400921B4;
  if ( dword_1400921B4 != -1 )
  {
    byte_1400A2641[384 * dword_1400921B4] = 1;
    sub_140005030(a1, v5, 1);
    v4 = hThread;
  }
  if ( v4 == (HANDLE)-1i64 )
  {
    LeaveCriticalSection(&CriticalSection);
  }
  else
  {
    ShowWindow(a1, 0);
    LeaveCriticalSection(&CriticalSection);
    MessageBoxA(a1, "Connection attempt was terminated", "DebugView", 0x30u);
  }
  dword_1400921B4 = -1;
  hThread = (HANDLE)-1i64;
  EndDialog(a1, 1i64);
  return 1i64;
}
// 1400921B4: using guessed type int dword_1400921B4;

//----- (00000001400037E0) ----------------------------------------------------
char __fastcall sub_1400037E0(HWND hWnd)
{
  HANDLE v2; // rcx
  DWORD v3; // edx
  DWORD v4; // edx
  HANDLE v5; // rcx
  HMENU SubMenu; // rax
  HMENU v8; // rax
  HBITMAP v9; // rdi
  HBITMAP v10; // rbx
  HMENU v11; // rax
  DWORD BytesReturned; // [rsp+40h] [rbp-248h] BYREF
  int OutBuffer[3]; // [rsp+44h] [rbp-244h] BYREF
  char Buffer[272]; // [rsp+50h] [rbp-238h] BYREF
  CHAR Text[272]; // [rsp+160h] [rbp-128h] BYREF

  byte_1400A2642 = 0;
  if ( byte_1400921CA )
    sub_14000A080(hWnd);
  if ( hDevice != (HANDLE)-1i64 )
  {
    if ( !DeviceIoControl(hDevice, 0x83050024, 0i64, 0, OutBuffer, 4u, &BytesReturned, 0i64) || OutBuffer[0] != 800 )
    {
      MessageBoxA(
        hWnd,
        "DebugView has found a previously loaded DebugView driver with a version incompatable with the\n"
        "user interface. Please reboot the system and restart DebugView to synchronize the interface and driver.",
        "DebugView",
        0x10u);
      return 0;
    }
    v2 = hDevice;
    if ( hDevice != (HANDLE)-1i64 )
      goto LABEL_8;
  }
  qword_1400A36C0 = (__int64)&unk_1400935A8;
  byte_1400921CA = 0;
  byte_1400A2642 = 1;
  CheckMenuItem(hMenu, 0x9C5Fu, 0);
  v2 = hDevice;
  if ( hDevice != (HANDLE)-1i64 )
  {
LABEL_8:
    v3 = -2096824304;
    if ( byte_1400921C8 )
      v3 = -2096824300;
    if ( !DeviceIoControl(v2, v3, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
      goto LABEL_19;
    if ( hDevice != (HANDLE)-1i64 )
    {
      v4 = -2096824264;
      if ( byte_1400921B0 )
        v4 = -2096824268;
      if ( !DeviceIoControl(hDevice, v4, 0i64, 0, 0i64, 0, &BytesReturned, 0i64)
        || hDevice != (HANDLE)-1i64 && !DeviceIoControl(hDevice, 0x83050008, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
      {
        goto LABEL_19;
      }
    }
  }
  QueryPerformanceFrequency(&Frequency);
  QueryPerformanceCounter(&PerformanceCount);
  v5 = hDevice;
  if ( hDevice != (HANDLE)-1i64 )
  {
    if ( !DeviceIoControl(hDevice, 0x83050020, 0i64, 0, &qword_1400A36C0, 8u, &BytesReturned, 0i64) )
    {
LABEL_19:
      MessageBoxA(hWnd, "Couldn't access device driver", "DebugView", 0x10u);
      return 0;
    }
    v5 = hDevice;
  }
  if ( byte_1400921CA && v5 != (HANDLE)-1i64 )
  {
    if ( DeviceIoControl(v5, 0x83050000, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
    {
      if ( byte_1400935A3 )
        DeviceIoControl(hDevice, 0x8305003C, 0i64, 0, 0i64, 0, &BytesReturned, 0i64);
    }
    else
    {
      MessageBoxA(
        hWnd,
        "Unable to hook kernel debug prints. This version of DebugView is not compatible\n"
        "with this version of Windows.\n"
        "Check the Sysinternals site for updates.",
        "DebugView",
        0x10u);
      CloseHandle(hDevice);
      hDevice = (HANDLE)-1i64;
      byte_1400921CA = 0;
    }
  }
  if ( byte_1400921C9 || byte_1400935A2 )
  {
    if ( !DGBView_StartListener_140005710(0) )
    {
      sub_1400053E0(Buffer);
      sub_140002490(Text, "Unable to monitor Win32 debug output: %s\n", Buffer);
      MessageBoxA(0i64, Text, "DebugView", 0x30u);
      byte_1400921C9 = 0;
    }
    if ( byte_1400935A2 && !DGBView_StartListener_140005710(1u) )
    {
      sub_1400053E0(Buffer);
      sub_140002490(Text, "Unable to monitor Global Win32 debug output: %s\n", Buffer);
      MessageBoxA(0i64, Text, "DebugView", 0x30u);
      byte_1400935A2 = 0;
    }
  }
  byte_1400921B1 = 1;
  byte_1400A277C = 1;
  byte_1400A2641[0] = 0;
  sub_140002490(TimeStr, "%s (local)", byte_1400A2650);
  SubMenu = GetSubMenu(hMenu, 4);
  AppendMenuA(SubMenu, 0, 0xC350ui64, TimeStr);
  v8 = GetSubMenu(hMenu, 4);
  CheckMenuItem(v8, 0xC350u, 8u);
  v9 = (HBITMAP)qword_1400A05C0;
  v10 = (HBITMAP)qword_1400A05B8;
  if ( byte_1400921B2 )
  {
    v9 = hBitmapChecked;
    v10 = hBitmapUnchecked;
  }
  v11 = GetSubMenu(hMenu, 4);
  SetMenuItemBitmaps(v11, 0xC350u, 0, v10, v9);
  sub_14000A2C0(hWnd, 0);
  EnableMenuItem(hMenu, 0x9C71u, 1u);
  EnableMenuItem(hMenu, 0x9C78u, 0);
  return 1;
}
// 1400921B0: using guessed type char byte_1400921B0;
// 1400921B1: using guessed type char byte_1400921B1;
// 1400921B2: using guessed type char byte_1400921B2;
// 1400921C8: using guessed type char byte_1400921C8;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935A3: using guessed type char byte_1400935A3;
// 1400A05B8: using guessed type __int64 qword_1400A05B8;
// 1400A05C0: using guessed type __int64 qword_1400A05C0;
// 1400A2642: using guessed type char byte_1400A2642;
// 1400A277C: using guessed type char byte_1400A277C;
// 1400A36C0: using guessed type __int64 qword_1400A36C0;
// 1400037E0: using guessed type int OutBuffer[3];

//----- (0000000140003CF0) ----------------------------------------------------
int __fastcall sub_140003CF0(HWND hWnd, char *String2)
{
  int result; // eax
  HCURSOR v5; // r14
  DWORD CurrentThreadId; // eax
  unsigned int v7; // r12d
  __int64 v8; // rbx
  unsigned int v9; // esi
  __int64 v10; // rcx
  __int64 v11; // rcx
  char *v12; // r14
  unsigned __int64 v13; // rax
  struct hostent *v14; // rax
  struct hostent *v15; // rax
  HWND *v16; // rbx
  unsigned int v17; // r13d
  __int64 v18; // rbx
  _BYTE *v19; // rsi
  HANDLE EventA; // rax
  char *v21; // rcx
  char v22; // al
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // esi
  const CHAR *v29; // rdx
  char *v30; // r14
  UINT v31; // esi
  HMENU SubMenu; // rax
  HBITMAP hBitmapChecked; // rdi
  HBITMAP v34; // rbx
  HMENU v35; // rax
  int v36; // ebx
  HMENU v37; // rax
  HMENU v38; // rax
  HMENU Menu; // rax
  unsigned int v40; // edi
  unsigned int v41; // r9d
  unsigned int v42; // r10d
  char *v43; // rax
  char v44; // cl
  __int64 v45; // rbx
  char v46; // [rsp+40h] [rbp-C0h]
  int v47; // [rsp+44h] [rbp-BCh] BYREF
  DWORD NumberOfBytesRead; // [rsp+48h] [rbp-B8h] BYREF
  char addr[4]; // [rsp+4Ch] [rbp-B4h] BYREF
  HANDLE *v50; // [rsp+50h] [rbp-B0h]
  HWND hWnda; // [rsp+58h] [rbp-A8h]
  __int64 v52; // [rsp+60h] [rbp-A0h]
  struct WSAData WSAData; // [rsp+70h] [rbp-90h] BYREF
  char v54[256]; // [rsp+210h] [rbp+110h] BYREF

  hWnda = hWnd;
  v46 = 0;
  if ( !byte_1400935FC )
  {
    result = WSAStartup(0x202u, &WSAData);
    if ( result == -1 )
      return result;
    byte_1400935FC = 1;
  }
  v5 = SetCursor(qword_1400A05A0);
  v50 = (HANDLE *)v5;
  CurrentThreadId = GetCurrentThreadId();
  AttachThreadInput(CurrentThreadId, idAttachTo, 1);
  v7 = 0;
  v8 = -1i64;
  v9 = 0;
  v10 = -1i64;
  do
    ++v10;
  while ( String2[v10] );
  if ( v10 )
  {
    v11 = 0i64;
    do
    {
      v12 = &String2[v11];
      if ( !isdigit(String2[v11]) && *v12 != 46 )
        break;
      ++v9;
      v13 = -1i64;
      v11 = v9;
      do
        ++v13;
      while ( String2[v13] );
    }
    while ( v9 < v13 );
    v5 = (HCURSOR)v50;
  }
  do
    ++v8;
  while ( String2[v8] );
  if ( v9 == v8 )
  {
    *(_DWORD *)addr = inet_addr(String2);
    if ( *(_DWORD *)addr != -1 )
    {
      v14 = gethostbyaddr(addr, 4, 2);
      if ( v14 )
        strcpy(String2, v14->h_name);
    }
  }
  else
  {
    v15 = gethostbyname(String2);
    if ( !v15 )
    {
      SendMessageA(hWndParent, 0x403u, 0i64, 0i64);
      SetCursor(v5);
      sub_140002490(TimeStr, "DebugView could not resolve %s", String2);
      return MessageBoxA(hWnd, TimeStr, "DebugView", 0x10u);
    }
    v46 = 1;
    *(_DWORD *)addr = **(_DWORD **)v15->h_addr_list;
  }
  v16 = &qword_1400A2648;
  v17 = 0;
  while ( 1 )
  {
    if ( !*v16 )
    {
LABEL_27:
      if ( !*((_BYTE *)v16 - 7) )
        goto LABEL_29;
      goto LABEL_28;
    }
    if ( !stricmp(String2, &byte_1400A2650[384 * v17]) || *((_DWORD *)v16 + 67) == *(_DWORD *)addr )
      break;
    if ( !*v16 )
      goto LABEL_27;
LABEL_28:
    ++v17;
    v16 += 48;
    if ( v17 >= 0xA )
      goto LABEL_29;
  }
  if ( !v17 )
  {
    sub_140002490(TimeStr, "The specified computer is the local system");
LABEL_36:
    SendMessageA(hWndParent, 0x403u, 0i64, 0i64);
    SetCursor(v5);
    return MessageBoxA(hWnd, TimeStr, "DebugView", 0x10u);
  }
  if ( !*((_BYTE *)&unk_1400A2640 + 384 * v17 + 1) )
  {
    sub_140002490(TimeStr, "DebugView is already connected to %s", String2);
    goto LABEL_36;
  }
  sub_140005030(hWnd, v17, 1);
LABEL_29:
  if ( v17 == 10 )
  {
    SendMessageA(hWndParent, 0x403u, 0i64, 0i64);
    SetCursor(v5);
    return MessageBoxA(hWnd, "The maximum number of supported clients are already active.", "DebugView", 0x10u);
  }
  sub_140002490((char *)lParam, "Querying %s...", String2);
  SendMessageA(hWndParent, 0x402u, 0i64, (LPARAM)lParam);
  v18 = 384i64 * v17;
  v19 = (char *)&unk_1400A2640 + v18;
  v52 = v18;
  sub_140016650((__int64)&unk_1400A2640 + v18, 0, 0x180ui64);
  dword_1400921B4 = v17;
  EventA = CreateEventA(0i64, 1, 0, 0i64);
  *(_QWORD *)((char *)&unk_1400A2640 + v18 + 360) = EventA;
  v50 = (HANDLE *)((char *)&unk_1400A2640 + v18 + 368);
  *v50 = EventA;
  v21 = String2;
  do
  {
    v22 = *v21;
    v21[(_QWORD)&unk_1400A2640 + v18 - (_QWORD)String2 + 16] = *v21;
    ++v21;
  }
  while ( v22 );
  *(_DWORD *)((char *)&unk_1400A2640 + v18 + 276) = *(_DWORD *)addr;
  *((_BYTE *)&unk_1400A2640 + v18 + 316) = 1;
  if ( !v46 || (*v19 = 1, (v23 = sub_140004740(hWnd, v17, String2, v54)) == 0) )
  {
LABEL_51:
    if ( *v19
      || (*v19 = 0,
          sub_140002490((char *)lParam, "Searching for DebugView client on %s...", String2),
          SendMessageA(hWndParent, 0x402u, 0i64, (LPARAM)lParam),
          (v28 = sub_140004CC0(hWnd, v17)) == 0) )
    {
      *((_BYTE *)&unk_1400A2640 + v18 + 304) = byte_1400921B2;
      *((_BYTE *)&unk_1400A2640 + v18 + 308) = byte_1400921CA;
      *((_BYTE *)&unk_1400A2640 + v18 + 306) = byte_1400921C9;
      *((_BYTE *)&unk_1400A2640 + v18 + 305) = byte_1400921C8;
      *((_BYTE *)&unk_1400A2640 + v18 + 309) = byte_1400921B0;
      *((_BYTE *)&unk_1400A2640 + v18 + 311) = byte_1400921CB;
      v47 = -2096824316;
      if ( (unsigned int)sub_140014040(hWnd, v17, &v47, 4u, &NumberOfBytesRead, 1, 0)
        && (v47 = -2096824312, (unsigned int)sub_140014040(hWnd, v17, &v47, 4u, &NumberOfBytesRead, 1, 0))
        && (v47 = -2096824280, (unsigned int)sub_140014040(hWnd, v17, &v47, 4u, &NumberOfBytesRead, 1, 0))
        && ((sub_140013E70(hWnd, v17, (char *)&unk_1400A2640 + v18 + 296, 8u, &NumberOfBytesRead, 1, 0), !byte_1400921B2)
         || (!byte_1400921CA
          || (v47 = -2096824320, (unsigned int)sub_140014040(hWnd, v17, &v47, 4u, &NumberOfBytesRead, 1, 0)))
         && (!byte_1400921C9
          || (v47 = -2096824296, (unsigned int)sub_140014040(hWnd, v17, &v47, 4u, &NumberOfBytesRead, 1, 0)))) )
      {
        sub_140009460(*((HWND *)&unk_1400A2640 + 48 * (unsigned int)ArgList + 1), 0);
        ShowWindow(*((HWND *)&unk_1400A2640 + 48 * (unsigned int)ArgList + 1), 0);
        v30 = (char *)&unk_1400A2640 + v18;
        SendMessageA(hWndParent, 0x407u, 0i64, (LPARAM)&unk_1400A2640 + v18 + 8);
        sub_140009E50(hWnd, v17);
        v31 = v17 + 50000;
        SubMenu = GetSubMenu(hMenu, 4);
        AppendMenuA(SubMenu, 0, v17 + 50000, String2);
        hBitmapChecked = (HBITMAP)qword_1400A05C0;
        v34 = (HBITMAP)qword_1400A05B8;
        if ( byte_1400921B2 )
        {
          hBitmapChecked = ::hBitmapChecked;
          v34 = hBitmapUnchecked;
        }
        v35 = GetSubMenu(hMenu, 4);
        SetMenuItemBitmaps(v35, v31, 0, v34, hBitmapChecked);
        v36 = ArgList;
        v37 = GetSubMenu(hMenu, 4);
        CheckMenuItem(v37, v36 + 50000, 0);
        v38 = GetSubMenu(hMenu, 4);
        CheckMenuItem(v38, v31, 8u);
        Menu = GetMenu(hWnda);
        EnableMenuItem(Menu, 0x9C63u, 0);
        EnterCriticalSection(&CriticalSection);
        LODWORD(ArgList) = v17;
        *((_BYTE *)&unk_1400A2640 + v52 + 1) = 0;
        qword_1400A37F8 = (HWND)*((_QWORD *)v30 + 1);
        LeaveCriticalSection(&CriticalSection);
        sub_140002F30(hWnda, v17, v17);
        SendMessageA(hWndParent, 0x404u, 0i64, (LPARAM)String2);
        do
        {
          v40 = v7 + 1;
          if ( !stricmp((const char *)&byte_14009DCC0 + 257 * v7, String2) )
            break;
          ++v7;
        }
        while ( v40 < 5 );
        v41 = v40 - 2;
        if ( v40 != 1 )
        {
          v42 = v41 + 1;
          do
          {
            v43 = (char *)&byte_14009DCC0 + 257 * v41;
            do
            {
              v44 = *v43;
              v43[257i64 * v42 - 257i64 * v41] = *v43;
              ++v43;
            }
            while ( v44 );
            --v41;
            --v42;
          }
          while ( v41 != -1 );
        }
        v45 = (char *)&byte_14009DCC0 - String2;
        do
        {
          result = (unsigned __int8)*String2;
          String2[v45] = result;
          ++String2;
        }
        while ( (_BYTE)result );
      }
      else
      {
        SendMessageA(hWndParent, 0x403u, 0i64, 0i64);
        SetCursor(v5);
        return sub_140005030(hWnd, v17, 1);
      }
      return result;
    }
    SendMessageA(hWndParent, 0x403u, 0i64, 0i64);
    SetCursor(v5);
    if ( v28 == 2 )
    {
      sub_140002490(
        TimeStr,
        "The DebugView driver currently loaded on the remote system is of an incompatible version.\n"
        "Please reboot the target machine and reconnect to synchronize the driver.\n");
      v29 = TimeStr;
    }
    else
    {
      if ( v28 == 6 )
      {
        sub_140002490(TimeStr, "DebugView could not resolve the IP address of %s.", String2);
      }
      else
      {
        if ( v28 != 8 )
        {
          v29 = "DebugView did not locate a client on the target machine.\n"
                "\n"
                "Please start the DebugView client on the target machine before attempting to connect to it.";
          goto LABEL_61;
        }
        sub_140002490(TimeStr, "%s did not respond within the timeout period.", String2);
      }
      v29 = TimeStr;
    }
LABEL_61:
    MessageBoxA(hWnd, v29, "DebugView", 0x10u);
    return CloseHandle(*v50);
  }
  *v19 = 0;
  v24 = v23 - 1;
  if ( !v24 )
  {
    sub_140002490(TimeStr, "DebugView could not connect with %s %s\n", String2, v54);
    goto LABEL_51;
  }
  v25 = v24 - 1;
  if ( v25 )
  {
    v26 = v25 - 1;
    if ( v26 )
    {
      v27 = v26 - 1;
      if ( v27 )
      {
        if ( v27 == 1 )
          sub_140002490(TimeStr, "DebugView could not start on %s %s\n", String2, v54);
      }
      else
      {
        sub_140002490(TimeStr, "DebugView could not install on %s %s\n", String2, v54);
      }
    }
    else
    {
      sub_140002490(TimeStr, "DebugView could not install itself on %s %s\n", String2, v54);
    }
    goto LABEL_51;
  }
  SendMessageA(hWndParent, 0x403u, 0i64, 0i64);
  sub_140002490(
    TimeStr,
    "The DebugView driver currently loaded on the remote system is of an incompatible version.\n"
    "Please reboot the target machine and reconnect to synchronize the driver.\n");
  return MessageBoxA(hWnd, TimeStr, "DebugView", 0x10u);
}
// 1400921B0: using guessed type char byte_1400921B0;
// 1400921B2: using guessed type char byte_1400921B2;
// 1400921B4: using guessed type int dword_1400921B4;
// 1400921C8: using guessed type char byte_1400921C8;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400921CB: using guessed type char byte_1400921CB;
// 1400935FC: using guessed type char byte_1400935FC;
// 1400A05B8: using guessed type __int64 qword_1400A05B8;
// 1400A05C0: using guessed type __int64 qword_1400A05C0;
// 1400A05E0: using guessed type LPARAM lParam[516];

//----- (0000000140004740) ----------------------------------------------------
__int64 __fastcall sub_140004740(HWND hWnd, int a2, char *a3, char *a4)
{
  __int64 v4; // rsi
  DWORD LastError; // ebx
  HWND v9; // rcx
  __int64 v10; // r14
  const CHAR *v12; // rcx
  unsigned int v13; // ebx
  DWORD v14; // eax
  DWORD v15; // ecx
  struct hostent *v16; // rbx
  FILE *v17; // rax
  FILE *v18; // rbx
  __int64 v19; // rbp
  struct sockaddr v20; // [rsp+30h] [rbp-178h] BYREF
  CHAR FileName[272]; // [rsp+40h] [rbp-168h] BYREF

  v4 = a2;
  sub_140002490((char *)lParam, "Setting up %s...", a3);
  SendMessageA(hWndParent, 0x402u, 0i64, (LPARAM)lParam);
  sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\Dbgvsvc.exe", a3);
  if ( sub_14000CCC0("RCDBGSVC", FileName) )
  {
    v10 = v4;
  }
  else
  {
    LastError = GetLastError();
    SendMessageA(hWndParent, 0x406u, 0i64, 0i64);
    if ( LastError != 5 && LastError != 999
      || !DialogBoxParamA(hInstance, "LOGIN", hWnd, (DLGPROC)sub_1400091E0, (LPARAM)a3)
      || !sub_14000CCC0("RCDBGSVC", FileName) )
    {
      SendMessageA(hWndParent, 0x405u, 0i64, 0i64);
      sub_1400053E0(a4);
      *((_BYTE *)&unk_1400A2640 + 384 * v4 + 288) = 1;
      sub_140009390(v4);
      return 1i64;
    }
    v9 = hWndParent;
    v10 = v4;
    *((_BYTE *)&unk_1400A2640 + 384 * v4 + 288) = 1;
    SendMessageA(v9, 0x405u, 0i64, 0i64);
  }
  sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\Dbgv.sys", a3);
  v12 = "RCDBGSYS";
  if ( dword_1400A3868 )
    v12 = "RCDBGSYS64";
  if ( !sub_14000CCC0(v12, FileName) )
  {
    sub_1400053E0(a4);
    v13 = 3;
LABEL_24:
    sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\Dbgvsvc.exe", a3);
    DeleteFileA(FileName);
    sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\Dbgv.sys", a3);
    DeleteFileA(FileName);
    sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\dbgview.ini", a3);
    DeleteFileA(FileName);
    sub_140009390(v4);
    return v13;
  }
  sub_140002490((char *)lParam, "Starting DebugView on %s...", a3);
  SendMessageA(hWndParent, 0x402u, 0i64, (LPARAM)lParam);
  qword_14009E1D8 = (HANDLE)beginthread((_beginthread_proc_type)StartAddress, 0, a3);
  v14 = WaitForSingleObject(hEvent, 0xAFC8u);
  if ( !dword_14009E1C8 )
  {
    if ( v14 == 258 )
    {
      TerminateThread(qword_14009E1D8, 0xFFFFFFFF);
      v15 = 1053;
    }
    else
    {
      v15 = dwErrCode;
    }
    SetLastError(v15);
    sub_1400053E0(a4);
    v13 = 5;
    goto LABEL_24;
  }
  sub_140002490((char *)lParam, "Connecting with %s...", a3);
  SendMessageA(hWndParent, 0x402u, 0i64, (LPARAM)lParam);
  v16 = gethostbyname(a3);
  *(_QWORD *)&v20.sa_family = 0i64;
  *(_QWORD *)&v20.sa_data[6] = 0i64;
  sub_1400161F0((__m128i *)&v20.sa_data[2], *(const __m128i **)v16->h_addr_list, v16->h_length);
  v20.sa_family = v16->h_addrtype;
  sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\dbgview.ini", a3);
  v17 = fopen(FileName, "rb");
  v18 = v17;
  v19 = 384 * v10;
  if ( !v17 )
  {
    v13 = 4;
LABEL_23:
    sub_14000F320((const CHAR *)&unk_1400A2640 + v19 + 16, "DBGVSVC");
    goto LABEL_24;
  }
  fread(v20.sa_data, 2ui64, 1ui64, v17);
  fclose(v18);
  sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\dbgview.ini", a3);
  DeleteFileA(FileName);
  *(_QWORD *)((char *)&unk_1400A2640 + v19 + 280) = socket(2, 1, 0);
  v13 = sub_140004B90(hWnd, v4, &v20);
  if ( v13 )
  {
    closesocket(*(_QWORD *)((char *)&unk_1400A2640 + v19 + 280));
    if ( v13 != 2 )
      sub_1400053E0(a4);
    goto LABEL_23;
  }
  return 0i64;
}
// 14009E1C8: using guessed type int dword_14009E1C8;
// 1400A05E0: using guessed type LPARAM lParam[516];
// 1400A3868: using guessed type int dword_1400A3868;

//----- (0000000140004B90) ----------------------------------------------------
__int64 __fastcall sub_140004B90(HWND hWnd, signed int a2, const struct sockaddr *a3)
{
  __int64 v5; // rbx
  int Error; // eax
  unsigned int v7; // ecx
  int v9; // eax
  int v10[10]; // [rsp+40h] [rbp-28h] BYREF
  int v11; // [rsp+78h] [rbp+10h] BYREF
  DWORD NumberOfBytesRead; // [rsp+88h] [rbp+20h] BYREF

  v5 = 384i64 * a2;
  if ( connect(*(_QWORD *)((char *)&unk_1400A2640 + v5 + 280), a3, 16) == -1 )
  {
    Error = WSAGetLastError();
    v7 = 1;
    if ( Error == 10060 )
      return 8;
    return v7;
  }
  else
  {
    v11 = -2096824284;
    if ( (unsigned int)sub_140014040(hWnd, a2, &v11, 4u, &NumberOfBytesRead, 1, 0)
      && sub_140013E70(hWnd, a2, v10, 4u, &NumberOfBytesRead, 1, 0x7D0u) )
    {
      v9 = v10[0];
      *((_BYTE *)&unk_1400A2640 + v5 + 2) = 0;
      if ( v9 == 0x7FFFFFFF )
      {
        *((_BYTE *)&unk_1400A2640 + v5 + 2) = 1;
      }
      else if ( (v9 & 0x7FFFFFFF) != 800 )
      {
        return 2i64;
      }
      return 0i64;
    }
    WSAGetLastError();
    return 7i64;
  }
}
// 140004B90: using guessed type int var_28[10];

//----- (0000000140004CC0) ----------------------------------------------------
__int64 __fastcall sub_140004CC0(HWND hWnd, signed int a2)
{
  u_short v3; // bx
  __int64 v5; // rdi
  int v6; // eax
  struct sockaddr v8; // [rsp+20h] [rbp-48h] BYREF

  v3 = 2020;
  v5 = 384i64 * a2;
  while ( 1 )
  {
    *(_QWORD *)((char *)&unk_1400A2640 + v5 + 280) = socket(2, 1, 0);
    *(_QWORD *)&v8.sa_family = 0i64;
    *(_QWORD *)&v8.sa_data[6] = 0i64;
    *(_DWORD *)&v8.sa_data[2] = *(_DWORD *)((char *)&unk_1400A2640 + v5 + 276);
    v8.sa_family = 2;
    *(_WORD *)v8.sa_data = htons(v3);
    v6 = sub_140004B90(hWnd, a2, &v8);
    if ( !v6 )
      break;
    if ( v6 == 2 )
    {
      closesocket(*(_QWORD *)((char *)&unk_1400A2640 + v5 + 280));
      return 2i64;
    }
    if ( v6 != 1 )
    {
      if ( v6 == 8 )
        return 8i64;
      closesocket(*(_QWORD *)((char *)&unk_1400A2640 + v5 + 280));
      *(_QWORD *)((char *)&unk_1400A2640 + v5 + 280) = socket(2, 1, 0);
    }
    closesocket(*(_QWORD *)((char *)&unk_1400A2640 + v5 + 280));
    if ( (__int16)++v3 >= 2030 )
      return 1i64;
  }
  return 0i64;
}

//----- (0000000140004E00) ----------------------------------------------------
void __fastcall sub_140004E00(char *a1)
{
  sub_140003CF0(hWndParent, a1);
  EnterCriticalSection(&CriticalSection);
  dword_1400921B4 = -1;
  hThread = (HANDLE)-1i64;
  LeaveCriticalSection(&CriticalSection);
}
// 1400921B4: using guessed type int dword_1400921B4;

//----- (0000000140004E50) ----------------------------------------------------
int __fastcall sub_140004E50(HWND hWnd)
{
  unsigned int v1; // ebx
  HANDLE v3; // rcx
  HMENU SubMenu; // rax
  char *v6; // rax
  HMENU v7; // rax
  HMENU v8; // rax
  DWORD BytesReturned; // [rsp+58h] [rbp+10h] BYREF

  v1 = 0;
  byte_1400921B1 = 0;
  byte_1400A2641[0] = 1;
  if ( byte_1400921B2 && byte_1400921CA )
  {
    v3 = hDevice;
    if ( hDevice == (HANDLE)-1i64 )
      goto LABEL_7;
    if ( !DeviceIoControl(hDevice, 0x83050004, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
      return sub_140002BF0(hWnd, "Couldn't access device driver");
  }
  v3 = hDevice;
LABEL_7:
  if ( byte_1400921C9 )
  {
    DBGView_CloseListener(0);
    v3 = hDevice;
  }
  if ( byte_1400935A2 )
  {
    DBGView_CloseListener(1u);
    v3 = hDevice;
  }
  if ( byte_1400935A3 && v3 != (HANDLE)-1i64 )
  {
    DeviceIoControl(v3, 0x83050040, 0i64, 0, 0i64, 0, &BytesReturned, 0i64);
    v3 = hDevice;
  }
  CloseHandle(v3);
  SubMenu = GetSubMenu(hMenu, 4);
  DeleteMenu(SubMenu, 0xC350u, 0);
  SendMessageA(qword_1400A37F8, 0x1009u, 0i64, 0i64);
  EnableMenuItem(hMenu, 0x9C71u, 0);
  v6 = byte_1400A2641;
  while ( !*(_QWORD *)(v6 + 7) || *v6 )
  {
    ++v1;
    v6 += 384;
    if ( (__int64)v6 >= (__int64)&unk_1400A3541 )
      goto LABEL_20;
  }
  sub_14000A2C0(hWnd, v1);
LABEL_20:
  if ( v1 == 10 )
    sub_14000A2C0(hWnd, 0);
  v7 = GetSubMenu(hMenu, 2);
  DeleteMenu(v7, 0x9C76u, 0);
  v8 = GetSubMenu(hMenu, 2);
  return DeleteMenu(v8, 0x9C7Cu, 0);
}
// 1400921B1: using guessed type char byte_1400921B1;
// 1400921B2: using guessed type char byte_1400921B2;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935A3: using guessed type char byte_1400935A3;

//----- (0000000140005030) ----------------------------------------------------
int __fastcall sub_140005030(HWND hWnd, unsigned int a2, BOOL a3)
{
  __int64 v4; // rbp
  char v6; // r12
  __int64 v7; // rdi
  HWND v8; // r14
  HMENU SubMenu; // rax
  int v10; // eax
  void *v11; // rcx
  SOCKET v12; // rcx
  void *v13; // rcx
  HMENU v14; // rax
  int result; // eax
  int v16; // [rsp+40h] [rbp-168h] BYREF
  DWORD NumberOfBytesWritten[3]; // [rsp+44h] [rbp-164h] BYREF
  CHAR FileName[272]; // [rsp+50h] [rbp-158h] BYREF

  v4 = a2;
  v6 = 0;
  EnterCriticalSection(&CriticalSection);
  v7 = 384 * v4;
  v8 = (HWND)*((_QWORD *)&unk_1400A2640 + 48 * v4 + 1);
  *((_QWORD *)&unk_1400A2640 + 48 * v4 + 1) = 0i64;
  LeaveCriticalSection(&CriticalSection);
  SetCursor(qword_1400A05A0);
  if ( !a3 )
  {
    v6 = 1;
    sub_140002490((char *)lParam, "Disconnecting from %s...", (const char *)&unk_1400A2640 + v7 + 16);
    SendMessageA(hWndParent, 0x408u, 0i64, (LPARAM)lParam);
  }
  SubMenu = GetSubMenu(hMenu, 4);
  DeleteMenu(SubMenu, v4 + 50000, 0);
  if ( !a3 )
  {
    v16 = -2096824316;
    v10 = sub_140014040(hWnd, v4, &v16, 4u, NumberOfBytesWritten, 1, 0);
    v16 = -2096824276;
    a3 = v10 == 0;
    if ( !(unsigned int)sub_140014040(hWnd, v4, &v16, 4u, NumberOfBytesWritten, 1, 0) )
      a3 = 1;
  }
  v11 = *(void **)((char *)&unk_1400A2640 + v7 + 376);
  if ( v11 )
    j__free_base(v11);
  v12 = *(_QWORD *)((char *)&unk_1400A2640 + v7 + 280);
  if ( v12 )
    closesocket(v12);
  v13 = *(void **)((char *)&unk_1400A2640 + v7 + 368);
  if ( v13 )
    CloseHandle(v13);
  if ( !a3 && *((_BYTE *)&unk_1400A2640 + v7) )
  {
    sub_14000F320((const CHAR *)&unk_1400A2640 + v7 + 16, "DBGVSVC");
    sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\Dbgvsvc.exe", (const char *)&unk_1400A2640 + v7 + 16);
    DeleteFileA(FileName);
    sub_140002490(FileName, "\\\\%s\\ADMIN$\\System32\\Dbgv.sys", (const char *)&unk_1400A2640 + v7 + 16);
    DeleteFileA(FileName);
    sub_140009390(v4);
  }
  v14 = GetSubMenu(hMenu, 4);
  CheckMenuItem(v14, 0xC350u, 8u);
  result = sub_140009E50(hWnd, 0);
  if ( v8 )
  {
    ShowWindow(v8, 0);
    qword_1400A37F8 = qword_1400A2648;
    LODWORD(ArgList) = 0;
    ShowWindow(qword_1400A2648, 5);
    SendMessageA(v8, 0x10u, 0i64, 0i64);
    qword_1400A37F8 = qword_1400A2648;
    result = sub_140002F30(hWnd, v4, 0);
  }
  *((_BYTE *)&unk_1400A2640 + v7 + 1) = 0;
  if ( v6 )
    return SendMessageA(hWndParent, 0x409u, 0i64, 0i64);
  return result;
}
// 1400A05E0: using guessed type LPARAM lParam[516];

//----- (0000000140005300) ----------------------------------------------------
void __fastcall sub_140005300(void *a1)
{
  sub_140005030(hWndParent, (unsigned int)a1, 0);
}

//----- (0000000140005320) ----------------------------------------------------
__int64 __fastcall sub_140005320(const CHAR *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // ebx
  HMODULE LibraryA; // rax
  HMODULE v7; // rbp
  FARPROC ProcAddress; // rax
  int v10; // [rsp+20h] [rbp-38h] BYREF
  __int128 v11; // [rsp+24h] [rbp-34h]

  v3 = 0;
  *a2 = 0;
  *a3 = 0;
  LibraryA = LoadLibraryA(a1);
  v7 = LibraryA;
  if ( !LibraryA )
    return 2147500037i64;
  ProcAddress = GetProcAddress(LibraryA, "DllGetVersion");
  qword_1400A8528 = (__int64)ProcAddress;
  if ( ProcAddress )
  {
    v10 = 20;
    v11 = 0i64;
    v3 = ((__int64 (__fastcall *)(int *))ProcAddress)(&v10);
    if ( v3 >= 0 )
    {
      *a2 = v11;
      *a3 = DWORD1(v11);
      FreeLibrary(v7);
      return (unsigned int)v3;
    }
  }
  else
  {
    *a2 = 4;
    *a3 = 0;
  }
  FreeLibrary(v7);
  return (unsigned int)v3;
}
// 1400A8528: using guessed type __int64 qword_1400A8528;

//----- (00000001400053E0) ----------------------------------------------------
char *__fastcall sub_1400053E0(char *Buffer)
{
  DWORD LastError; // eax
  char *Buffera; // [rsp+50h] [rbp+8h] BYREF

  LastError = GetLastError();
  FormatMessageA(0x1100u, 0i64, LastError, 0x400u, (LPSTR)&Buffera, 0, 0i64);
  sub_140002490(Buffer, ": %s", Buffera);
  LocalFree(Buffera);
  return Buffer;
}

//----- (0000000140005450) ----------------------------------------------------
__int64 __fastcall DBGView_RegisterWndClass(HINSTANCE a1)
{
  WNDCLASSA WndClass; // [rsp+20h] [rbp-58h] BYREF

  WndClass.hInstance = a1;
  WndClass.style = 0;
  WndClass.lpfnWndProc = (WNDPROC)DBGView_WndProc_140005B80;
  *(_QWORD *)&WndClass.cbClsExtra = 0i64;
  WndClass.hIcon = LoadIconA(a1, "APPICON");
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.hCursor = LoadCursorA(0i64, (LPCSTR)0x7F00);
  WndClass.lpszMenuName = "LISTMENU";
  WndClass.lpszClassName = "dbgviewClass";
  if ( !RegisterClassA(&WndClass) )
    return 0i64;
  WndClass.lpszMenuName = 0i64;
  WndClass.lpfnWndProc = (WNDPROC)sub_14000F370;
  WndClass.hbrBackground = CreateSolidBrush(0xE0FFFFu);
  WndClass.lpszClassName = "BALLOON";
  RegisterClassA(&WndClass);
  return 1i64;
}

//----- (0000000140005520) ----------------------------------------------------
HWND __fastcall DBGView_CreateWnd(HINSTANCE hInstance, int a2)
{
  HWND result; // rax

  ::hInstance = hInstance;
  result = CreateWindowExA(
             0,
             "dbgviewClass",
             (LPCSTR)&WindowName,
             0xCF0000u,
             X,
             Y,
             nWidth,
             nHeight,
             0i64,
             0i64,
             hInstance,
             0i64);
  hWndParent = result;
  if ( result )
  {
    sub_140009E50(result, 0);
    if ( byte_1400935A1 )
      a2 = 0;
    ShowWindow(hWndParent, a2);
    UpdateWindow(hWndParent);
    // WM_CAP_DLG_VIDEODISPLAY
    SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Aui64, 10i64 - (byte_1400921C8 != 0));
    SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Fui64, 18i64 - (byte_1400921CA != 0));
    SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Cui64, 13i64 - (byte_1400921C9 != 0));
    SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Dui64, 15i64 - (byte_1400921CC != 0));
    InvalidateRect(qword_1400A37E8, 0i64, 1);
    if ( HIBYTE(word_1400A8324) && !byte_1400935A1 )
      ShowWindow(hWndParent, 3);
    if ( byte_1400935A5 )
    {
      SetWindowPos(hWndParent, HWND_MESSAGE|0x2, 0, 0, 0, 0, 3u);
      CheckMenuItem(hMenu, 0x9C61u, byte_1400935A5 != 0 ? 8 : 0);
    }
    return hWndParent;
  }
  return result;
}
// 1400921C8: using guessed type char byte_1400921C8;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400921CC: using guessed type char byte_1400921CC;
// 1400935A1: using guessed type char byte_1400935A1;
// 1400935A5: using guessed type char byte_1400935A5;
// 1400A8324: using guessed type __int16 word_1400A8324;

//----- (0000000140005710) ----------------------------------------------------
char __fastcall DGBView_StartListener_140005710(bool bGlobal)
{
  char *v2; // rcx
  const char *pszPrefix; // rdi
  HANDLE v4; // rax
  unsigned __int64 v5; // rbx
  HMODULE ModuleHandleA; // rax
  FARPROC ProcAddress; // rax
  __int64 v8; // rcx
  HANDLE v9; // rax
  LPVOID v11; // rax
  HANDLE v12; // rax
  HANDLE v13; // rax
  HANDLE v14; // rax
  HANDLE v15; // rax
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+40h] [rbp-C0h] BYREF
  struct _SECURITY_ATTRIBUTES MutexAttributes; // [rsp+48h] [rbp-B8h] BYREF
  char pSecurityDescriptor[48]; // [rsp+60h] [rbp-A0h] BYREF
  CHAR StringSecurityDescriptor[128]; // [rsp+90h] [rbp-70h] BYREF
  CHAR Name[272]; // [rsp+110h] [rbp+10h] BYREF

  strcpy(
    StringSecurityDescriptor,
    "D:(A;;GRGWGX;;;WD)(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGWGX;;;AN)(A;;GRGWGX;;;RC)(A;;GRGWGX;;;S-1-15-2-1)S:(ML;;NW;;;LW)");
  SecurityDescriptor = 0i64;
  if ( byte_14009E1E0 )
    ConvertStringSecurityDescriptorToSecurityDescriptorA(StringSecurityDescriptor, 1u, &SecurityDescriptor, 0i64);
  else
    InitializeSecurityDescriptor(pSecurityDescriptor, 1u);
  v2 = pSecurityDescriptor;
  MutexAttributes.nLength = 24;
  pszPrefix = (const char *)&WindowName;
  MutexAttributes.bInheritHandle = 1;
  if ( SecurityDescriptor )
    v2 = (char *)SecurityDescriptor;
  MutexAttributes.lpSecurityDescriptor = v2;
  if ( bGlobal )
    pszPrefix = "Global\\";
  sub_140002490(Name, "%sDBWinMutex", pszPrefix);
  v4 = OpenMutexA(0x10000000u, 0, Name);
  v5 = 8i64 * bGlobal;
  *(_QWORD *)&algn_1400A3668[v5 + 8] = v4;
  if ( v4 )
  {
    ModuleHandleA = GetModuleHandleA("Advapi32.dll");
    ProcAddress = GetProcAddress(ModuleHandleA, "SetSecurityInfo");
    v8 = *(_QWORD *)&algn_1400A3668[v5 + 8];
    qword_14009DCB0 = (__int64)ProcAddress;
    ((void (__fastcall *)(__int64, __int64, __int64))ProcAddress)(v8, 6i64, 4i64);
  }
  else
  {
    *(_QWORD *)&algn_1400A3668[v5 + 8] = CreateMutexA(&MutexAttributes, 0, Name);
  }
  sub_140002490(Name, "%sDBWIN_BUFFER", pszPrefix);
  v9 = CreateFileMappingA((HANDLE)0xFFFFFFFFFFFFFFFFi64, &MutexAttributes, 4u, 0, 0x1000u, Name);
  *(_QWORD *)((char *)&unk_1400A36A0 + v5) = v9;
  if ( !v9 )
  {
    v9 = CreateFileMappingA((HANDLE)0xFFFFFFFFFFFFFFFFi64, &MutexAttributes, 4u, 0, 0x1000u, Name);
    *(_QWORD *)((char *)&unk_1400A36A0 + v5) = v9;
    if ( !v9 )
    {
      if ( SecurityDescriptor )
        LocalFree(SecurityDescriptor);
      return 0;
    }
  }
  v11 = MapViewOfFile(v9, 6u, 0, 0, 0x1000ui64);
  qword_1400A3660[v5 / 8] = (__int64)v11;
  if ( !v11 )
  {
    if ( SecurityDescriptor )
      LocalFree(SecurityDescriptor);
LABEL_19:
    CloseHandle(*(HANDLE *)((char *)&unk_1400A36A0 + v5));
    return 0;
  }
  sub_140002490(Name, "%sDBWIN_DATA_READY", pszPrefix);
  v12 = CreateEventA(&MutexAttributes, 0, 0, Name);
  *(HANDLE *)((char *)&qword_1400A3680 + v5) = v12;
  if ( v12 == (HANDLE)-1i64 )
  {
    v13 = CreateEventA(&MutexAttributes, 0, 0, Name);
    *(HANDLE *)((char *)&qword_1400A3680 + v5) = v13;
    if ( v13 == (HANDLE)-1i64 )
    {
      if ( SecurityDescriptor )
        LocalFree(SecurityDescriptor);
      UnmapViewOfFile((LPCVOID)qword_1400A3660[v5 / 8]);
      goto LABEL_19;
    }
  }
  sub_140002490(Name, "%sDBWIN_BUFFER_READY", pszPrefix);
  v14 = CreateEventA(&MutexAttributes, 0, 0, Name);
  *(HANDLE *)((char *)&qword_1400A3690 + v5) = v14;
  if ( v14 == (HANDLE)-1i64 )
  {
    v15 = CreateEventA(&MutexAttributes, 0, 0, Name);
    *(HANDLE *)((char *)&qword_1400A3690 + v5) = v15;
    if ( v15 == (HANDLE)-1i64 )
    {
      if ( SecurityDescriptor )
        LocalFree(SecurityDescriptor);
      UnmapViewOfFile((LPCVOID)qword_1400A3660[v5 / 8]);
      CloseHandle(*(HANDLE *)((char *)&qword_1400A3680 + v5));
      goto LABEL_19;
    }
  }
  if ( SecurityDescriptor )
    LocalFree(SecurityDescriptor);
  SetEvent(*(HANDLE *)((char *)&qword_1400A3690 + v5));
  return 1;
}
// 14009DCB0: using guessed type __int64 qword_14009DCB0;
// 14009E1E0: using guessed type char byte_14009E1E0;
// 1400A3660: using guessed type __int64 qword_1400A3660[];

//----- (0000000140005AE0) ----------------------------------------------------
void __fastcall StartAddress(const CHAR *a1)
{
  char Buffer[272]; // [rsp+20h] [rbp-128h] BYREF

  dword_14009E1C8 = 0;
  sub_140002490(Buffer, "%%SystemRoot%%\\System32\\Dbgvsvc.exe");
  dword_14009E1C8 = sub_14000F050(a1, "DBGVSVC", Buffer);
  dwErrCode = GetLastError();
  SetEvent(hEvent);
}
// 14009E1C8: using guessed type int dword_14009E1C8;

//----- (0000000140005B80) ----------------------------------------------------
__int64 __fastcall DBGView_WndProc_140005B80(HWND hWnd, UINT Msg, WPARAM wParam, CHAR *lpString)
{
  LPCSTR v4; // rbx
  WPARAM v5; // r12
  UINT v6; // r13d
  HWND v7; // r14
  __int64 v8; // rdi
  const TBBUTTON *lpButtons; // rbx
  DWORD v10; // edx
  HWND v11; // rcx
  _DWORD *v12; // rax
  unsigned int i; // ebx
  HBITMAP BitmapA; // rax
  HBITMAP v15; // rax
  HBITMAP v16; // rax
  HBITMAP v17; // rax
  HBITMAP v18; // rax
  HWND v19; // rax
  __int64 result; // rax
  UINT v21; // r8d
  BOOL v22; // ebx
  HMENU Menu; // rax
  int v24; // eax
  int v25; // eax
  HWND v26; // rcx
  char *v27; // rax
  __int64 v28; // rdi
  __int64 v29; // rbx
  void *v30; // rcx
  __int64 v31; // rax
  __int64 v32; // rdi
  signed int v33; // eax
  CHAR *v34; // rdx
  CHAR j; // cl
  unsigned __int64 v36; // r9
  CHAR *v37; // r8
  CHAR *v38; // rcx
  __int64 v39; // rdx
  CHAR v40; // al
  __int64 v41; // rdi
  CHAR v42; // al
  const LPARAM *v43; // rcx
  const LPARAM *v44; // rax
  HWND v45; // rcx
  unsigned __int16 v46; // ax
  __int64 v47; // r14
  int v48; // edi
  HWND *v49; // rbx
  int v50; // r15d
  HDC DC; // rdi
  unsigned int v52; // esi
  _QWORD *v53; // rdi
  __int16 v54; // di
  __int64 v55; // rcx
  int v56; // eax
  HANDLE FirstFileA; // rax
  _DWORD *v58; // rax
  unsigned int k; // ebx
  HWND *v60; // rbx
  __int64 v61; // r14
  UINT v62; // r8d
  UINT v63; // edx
  DWORD v64; // eax
  UINT v65; // r8d
  int v66; // ebx
  HBITMAP v67; // rsi
  bool v68; // dl
  HBITMAP v69; // rdi
  HMENU SubMenu; // rax
  __int64 v71; // rdi
  int v72; // ecx
  DWORD v73; // edx
  const char *v74; // rdx
  const CHAR *v75; // rdx
  HICON IconA; // rax
  bool v77; // al
  HANDLE v78; // rcx
  DWORD v79; // edx
  WPARAM v80; // r8
  LPARAM v81; // r9
  char v82; // al
  bool v83; // al
  bool v84; // al
  bool v85; // al
  bool v86; // al
  UINT v87; // r8d
  BOOL v88; // edi
  HMENU v89; // rax
  UINT v90; // r8d
  __int64 v91; // rdx
  unsigned __int64 v92; // r8
  int v93; // eax
  unsigned int v94; // eax
  __int64 v95; // rdx
  UINT v96; // r8d
  char v97; // al
  HDC v98; // rbx
  HFONT FontIndirectA; // rax
  HWND *v100; // rbx
  __int64 v101; // r14
  int v102; // ecx
  unsigned __int64 v103; // r8
  unsigned int v104; // edi
  double dwAvailPageFile_low; // xmm2_8
  double dwTotalPageFile_low; // xmm0_8
  double v107; // xmm0_8
  char v108; // bl
  double dwAvailPhys_low; // xmm2_8
  double dwTotalPhys_low; // xmm0_8
  HWND DialogParamA; // rax
  HWND v112; // rcx
  HWND DlgItem; // rax
  int v114; // eax
  int iNumButtons; // [rsp+38h] [rbp-C8h]
  DWORD BytesReturned; // [rsp+70h] [rbp-90h] BYREF
  struct tagPOINT Point; // [rsp+78h] [rbp-88h] BYREF
  unsigned int v118; // [rsp+80h] [rbp-80h] BYREF
  unsigned int v119[3]; // [rsp+84h] [rbp-7Ch] BYREF
  CHOOSEFONTA v120; // [rsp+90h] [rbp-70h] BYREF
  LPSTR FilePart[2]; // [rsp+100h] [rbp+0h] BYREF
  _DWORD lParam[10]; // [rsp+110h] [rbp+10h] BYREF
  void *Block; // [rsp+138h] [rbp+38h]
  SHELLEXECUTEINFOA pExecInfo; // [rsp+160h] [rbp+60h] BYREF
  LPARAM v125; // [rsp+1D0h] [rbp+D0h] BYREF
  int v126; // [rsp+1D8h] [rbp+D8h]
  CHAR *v127; // [rsp+1E8h] [rbp+E8h]
  int v128; // [rsp+1F0h] [rbp+F0h]
  struct tagRECT Rect; // [rsp+220h] [rbp+120h] BYREF
  struct tagRECT v130; // [rsp+230h] [rbp+130h] BYREF
  LOGFONTA v131; // [rsp+240h] [rbp+140h] BYREF
  struct _MEMORYSTATUS v132; // [rsp+280h] [rbp+180h] BYREF
  struct tagTEXTMETRICA tm; // [rsp+2B8h] [rbp+1B8h] BYREF
  struct _WIN32_FIND_DATAA FindFileData; // [rsp+2F0h] [rbp+1F0h] BYREF
  CHAR TimeStr[64]; // [rsp+430h] [rbp+330h] BYREF
  CHAR Buffer[272]; // [rsp+470h] [rbp+370h] BYREF
  char v137[64]; // [rsp+580h] [rbp+480h] BYREF
  char v138[272]; // [rsp+5C0h] [rbp+4C0h] BYREF
  CHAR Text[272]; // [rsp+6D0h] [rbp+5D0h] BYREF

  v4 = lpString;
  v5 = wParam;
  v6 = Msg;
  v7 = hWnd;
  if ( Msg > 0x111 )
  {
    if ( Msg > 0x401 )
    {
      switch ( Msg )
      {
        case 0x402u:
          SetDlgItemTextA(hDlg, 1004, lpString);
          return 0i64;
        case 0x403u:
          DestroyWindow(hDlg);
          return 0i64;
        case 0x404u:
          qword_140093598 = hDlg;
          hDlg = CreateDialogParamA(hInstance, "CONNECTED", hWnd, (DLGPROC)sub_140002CC0, 0i64);
          DestroyWindow(qword_140093598);
          qword_140093598 = hDlg;
          sub_140002490(::TimeStr, "DebugView made a successful connection with %s", v4);
          SetDlgItemTextA(hDlg, 1004, ::TimeStr);
          DlgItem = GetDlgItem(hDlg, 1005);
          ShowWindow(DlgItem, 5);
          SendMessageA(hDlg, 0x401u, 0x3EDui64, 0i64);
          SetCursor(qword_1400A05A8);
LABEL_296:
          SetFocus(hDlg);
          return 0i64;
        case 0x405u:
          ShowWindow(hDlg, 5);
          return 0i64;
        case 0x406u:
          ShowWindow(hDlg, 0);
          return 0i64;
        case 0x407u:
          *(_QWORD *)lpString = sub_14000FDA0(hWnd);
          return 0i64;
        case 0x408u:
          DialogParamA = CreateDialogParamA(hInstance, "DISCONNECT", hWnd, (DLGPROC)sub_140002CC0, 0i64);
          qword_1400958E0 = DialogParamA;
          goto LABEL_289;
        case 0x409u:
          DestroyWindow(qword_1400958E0);
          qword_1400958E0 = 0i64;
          return 0i64;
        case 0x40Au:
          DialogParamA = CreateDialogParamA(hInstance, "PRINTING", hWnd, (DLGPROC)sub_140013040, 0i64);
          qword_1400958D8 = DialogParamA;
LABEL_289:
          v112 = DialogParamA;
          goto LABEL_290;
        case 0x40Bu:
          v112 = qword_1400958D8;
LABEL_290:
          SetDlgItemTextA(v112, 1004, v4);
          return 0i64;
        case 0x40Cu:
          DestroyWindow(qword_1400958D8);
          return 0i64;
        case 0x40Du:
          if ( lpString == (CHAR *)515 )
          {
            ShowWindow(hWnd, 1);
            sub_14000A4C0(v7, 1u);
            result = 0i64;
          }
          else
          {
            if ( lpString != (CHAR *)516 )
              return 0i64;
            GetCursorPos(&Point);
            SetForegroundWindow(v7);
            TrackPopupMenu(qword_1400A3808, 2u, Point.x, Point.y, 0, v7, 0i64);
            result = 0i64;
          }
          break;
        default:
          goto LABEL_301;
      }
    }
    else
    {
      if ( Msg == 1025 )
      {
        sub_14000A640(qword_14009E1F0, qword_14009E1F8, dword_14009E200, 0);
        SetEvent(qword_14009E208);
        return 0i64;
      }
      if ( Msg == 274 )
      {
        if ( wParam == 61472 && byte_1400935A1 )
        {
          sub_140007FC0(hWnd);
          return 0i64;
        }
        Msg = 274;
        return DefWindowProcA(hWnd, Msg, wParam, (LPARAM)lpString);
      }
      if ( Msg != 275 )
      {
        if ( Msg == 512 )
        {
LABEL_252:
          if ( qword_1400935C8 )
          {
            ShowWindow(qword_1400935C8, 0);
            return 0i64;
          }
          return 0i64;
        }
LABEL_301:
        if ( Msg == dword_1400A3800 )
        {
          v114 = *((_DWORD *)lpString + 6);
          if ( (v114 & 0x40) != 0 )
          {
            qword_140093590 = 0i64;
            dword_1400921D0 = stru_14009F520.Flags & 7;
            result = 0i64;
            byte_14009F500 = 0;
            return result;
          }
          if ( (v114 & 8) != 0 )
          {
            SetCapture(hWnd);
            qword_1400A05A8 = SetCursor(qword_1400A05A0);
            if ( sub_140010340(v7, (__int64)v4) )
            {
              DestroyWindow(qword_140093590);
              qword_140093590 = 0i64;
              byte_1400921B3 = 0;
              CheckMenuItem(hMenu, 0x9C53u, 0);
              SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C53ui64, 3i64);
              ReleaseCapture();
              return 0i64;
            }
LABEL_34:
            ReleaseCapture();
          }
          return 0i64;
        }
LABEL_80:
        hWnd = v7;
        return DefWindowProcA(hWnd, Msg, wParam, (LPARAM)lpString);
      }
      sub_140014250(0, 0);
      if ( qword_1400935C8 )
      {
        GetCursorPos(&Point);
        GetWindowRect(qword_1400A37F8, &v130);
        if ( Point.x < v130.left || Point.x > v130.right || Point.y < v130.top || Point.y > v130.bottom )
          ShowWindow(qword_1400935C8, 0);
      }
      GlobalMemoryStatus(&v132);
      if ( v132.dwTotalPageFile )
      {
        dwAvailPageFile_low = (double)SLODWORD(v132.dwAvailPageFile);
        if ( (v132.dwAvailPageFile & 0x8000000000000000ui64) != 0i64 )
          dwAvailPageFile_low = dwAvailPageFile_low + 1.844674407370955e19;
        dwTotalPageFile_low = (double)SLODWORD(v132.dwTotalPageFile);
        if ( (v132.dwTotalPageFile & 0x8000000000000000ui64) != 0i64 )
          dwTotalPageFile_low = dwTotalPageFile_low + 1.844674407370955e19;
        v107 = dwTotalPageFile_low * 0.1;
        v108 = dwAvailPageFile_low > v107;
        if ( dwAvailPageFile_low <= v107 )
        {
          dwAvailPhys_low = (double)SLODWORD(v132.dwAvailPhys);
          if ( (v132.dwAvailPhys & 0x8000000000000000ui64) != 0i64 )
            dwAvailPhys_low = dwAvailPhys_low + 1.844674407370955e19;
          dwTotalPhys_low = (double)SLODWORD(v132.dwTotalPhys);
          if ( (v132.dwTotalPhys & 0x8000000000000000ui64) != 0i64 )
            dwTotalPhys_low = dwTotalPhys_low + 1.844674407370955e19;
          v108 = dwAvailPhys_low > dwTotalPhys_low * 0.1;
        }
      }
      else
      {
        v108 = 1;
      }
      if ( v108 == byte_1400921CE )
        return 0i64;
      byte_1400921CE = v108;
      sub_140009E50(v7, ArgList);
      if ( v108 )
        DestroyWindow(qword_1400958C8);
      else
        qword_1400958C8 = CreateDialogParamA(hInstance, "WARNING", v7, (DLGPROC)sub_140002CC0, 0i64);
      return 0i64;
    }
  }
  else
  {
    if ( Msg != 273 )
    {
      switch ( Msg )
      {
        case 1u:
          idAttachTo = GetCurrentThreadId();
          hMenu = GetMenu(v7);
          qword_1400A3808 = GetSubMenu(hMenu, 2);
          qword_1400A05A0 = LoadCursorA(0i64, (LPCSTR)0x7F02);
          SetCapture(v7);
          v8 = 0i64;
          qword_1400A05A8 = SetCursor(qword_1400A05A0);
          if ( !byte_1400935D1
            && !byte_1400935A1
            && (byte_1400A81E0 != asc_14007BD58[0] || byte_1400A81E1 || Source && (Source != 32 || byte_1400A80E1)) )
          {
            DialogBoxParamA(hInstance, "InitFilter", v7, (DLGPROC)sub_14000D5D0, 0i64);
          }
          sub_140005320("comctl32.dll", &v118, v119);
          if ( v118 > 4 || v118 == 4 && v119[0] >= 0x46 )
          {
            lpButtons = (const TBBUTTON *)&unk_140092300;
            v10 = 1082132736;
            iNumButtons = 20;
          }
          else
          {
            lpButtons = &Buttons;
            v10 = 1082130688;
            iNumButtons = 18;
          }
          qword_1400A37E8 = CreateToolbarEx(
                              v7,
                              v10,
                              1u,
                              22,
                              hInstance,
                              0x190ui64,
                              lpButtons,
                              iNumButtons,
                              16,
                              16,
                              16,
                              15,
                              0x20u);
          v11 = qword_1400A37E8;
          qword_14009E1E8 = (__int64)lpButtons;
          if ( !qword_1400A37E8 )
          {
            MessageBoxA(0i64, "Toolbar not created!", 0i64, 0);
            v11 = qword_1400A37E8;
          }
          ShowWindow(v11, byte_1400921CD != 0 ? 5 : 0);
          v12 = (_DWORD *)qword_14009E1E8;
          for ( i = 0; *v12 != -1; v12 = (_DWORD *)(32i64 * i + qword_14009E1E8) )
          {
            SendMessageA(qword_1400A37E8, 0x404u, (int)v12[1], byte_1400921CD == 0);
            ++i;
          }
          BitmapA = LoadBitmapA(hInstance, "IDB_SELON");
          hBitmapChecked = sub_140009F60(v7, BitmapA);
          v15 = LoadBitmapA(hInstance, "IDB_SELOFF");
          qword_1400A05C0 = (__int64)sub_140009F60(v7, v15);
          v16 = LoadBitmapA(hInstance, "IDB_UNSELON");
          hBitmapUnchecked = sub_140009F60(v7, v16);
          v17 = LoadBitmapA(hInstance, "IDB_UNSELOFF");
          qword_1400A05B8 = (__int64)sub_140009F60(v7, v17);
          v18 = LoadBitmapA(hInstance, "IDB_DISCONN");
          qword_1400A05B0 = sub_140009F60(v7, v18);
          v19 = sub_14000FDA0(v7);
          qword_1400A37F8 = v19;
          if ( !v19 )
          {
            MessageBoxA(0i64, "List not created!", 0i64, 0);
            v19 = qword_1400A37F8;
          }
          qword_1400A2648 = v19;
          byte_1400A277C = 1;
          sub_140002490(byte_1400A2650, "%s", &byte_1400A3540);
          sub_140002A40(v7);
          if ( byte_1400921B1 )
          {
            if ( !sub_1400037E0(v7) )
              return -1i64;
          }
          else
          {
            sub_14000A2C0(v7, 0);
          }
          InitializeCriticalSection(&CriticalSection);
          qword_14009E208 = CreateEventA(0i64, 0, 0, 0i64);
          qword_14009E210 = beginthread((_beginthread_proc_type)sub_140014290, 0, 0i64);
          SetTimer(v7, 1ui64, 0x1F4u, 0i64);
          CheckMenuItem(hMenu, 0x9C77u, byte_1400935A4 != 0 ? 8 : 0);
          CheckMenuItem(hMenu, 0x9C5Du, byte_1400921CC != 0 ? 8 : 0);
          v21 = 8;
          if ( byte_1400921CD )
            v21 = 0;
          CheckMenuItem(hMenu, 0x9C69u, v21);
          v22 = byte_1400921CC == 0;
          Menu = GetMenu(v7);
          EnableMenuItem(Menu, 0x9C77u, v22);
          CheckMenuItem(hMenu, 0x9C53u, byte_1400921B3 != 0 ? 8 : 0);
          LOBYTE(v8) = byte_1400921B3 != 0;
          SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C53ui64, v8 + 3);
          InvalidateRect(qword_1400A37E8, 0i64, 1);
          CheckMenuItem(hMenu, 0x9C75u, byte_1400935A1 != 0 ? 8 : 0);
          if ( byte_1400935A1 )
          {
            CheckMenuItem(hMenu, 0x9C75u, 8u);
            sub_140007FC0(v7);
          }
          if ( byte_1400935AF )
            sub_140012BF0(v7, 0);
          goto LABEL_33;
        case 2u:
          PostQuitMessage(0);
          return 0i64;
        case 3u:
        case 8u:
          goto LABEL_252;
        case 5u:
          v46 = (unsigned __int16)lpString;
          if ( byte_1400921CD )
          {
            MoveWindow(qword_1400A37E8, 0, 0, (unsigned __int16)lpString, WORD1(lpString), 1);
            v46 = (unsigned __int16)v4;
          }
          v47 = 10i64;
          v48 = WORD1(v4);
          v49 = &qword_1400A2648;
          v50 = v46;
          do
          {
            MoveWindow(*v49, 0, byte_1400921CD != 0 ? 0x1C : 0, v50, v48 - (byte_1400921CD != 0 ? 0x1C : 0), 1);
            v49 += 48;
            --v47;
          }
          while ( v47 );
          goto LABEL_252;
        case 6u:
        case 7u:
          v45 = qword_1400A37F8;
          goto LABEL_70;
        case 0x10u:
          v52 = 1;
          KillTimer(hWnd, 1ui64);
          if ( byte_1400921B1 )
            sub_140004E50(v7);
          v53 = &unk_1400A27C8;
          do
          {
            if ( *v53 )
              sub_140005030(v7, v52, 0);
            ++v52;
            v53 += 48;
          }
          while ( v52 < 0xA );
          sub_140009460(v7, 1);
          goto LABEL_79;
        case 0x2Bu:
          sub_140010090((__int64)lpString);
          return 0i64;
        case 0x2Cu:
          if ( *(_DWORD *)lpString != 102 )
            goto LABEL_79;
          DC = GetDC(qword_1400A37F8);
          SelectObject(DC, ::wParam);
          if ( !GetTextMetricsA(DC, &tm) )
            return 0i64;
          *((_DWORD *)v4 + 4) = tm.tmHeight + 1;
          ReleaseDC(qword_1400A37F8, DC);
LABEL_79:
          lpString = (CHAR *)v4;
          wParam = v5;
          Msg = v6;
          goto LABEL_80;
        case 0x4Eu:
          if ( wParam != 1000 )
          {
            if ( *((_DWORD *)lpString + 4) != -520 )
              return 0i64;
            LoadStringA(hInstance, *((_DWORD *)lpString + 2), ::Buffer, 4128);
            result = 0i64;
            *((_QWORD *)v4 + 3) = ::Buffer;
            return result;
          }
          v24 = *((_DWORD *)lpString + 4);
          switch ( v24 )
          {
            case -307:
              goto LABEL_65;
            case -150:
              v31 = *((int *)lpString + 8);
              v32 = *((_QWORD *)lpString + 8);
              if ( (_DWORD)v31 == 1 )
              {
                if ( *(_WORD *)v32 )
                {
                  if ( byte_1400921CC )
                  {
                    GetTimeFormatA(0x400u, 0, (const SYSTEMTIME *)v32, 0i64, TimeStr, 64);
                    if ( byte_1400935A4 )
                    {
                      v33 = (unsigned int)strrchr(TimeStr, 58) - ((unsigned int)FilePart + 816);
                      v34 = &TimeStr[v33];
                      for ( j = *v34; j; ++v33 )
                      {
                        if ( j == 32 )
                          break;
                        j = *++v34;
                      }
                      v36 = v33;
                      v37 = &TimeStr[v33];
                      v38 = v37;
                      v39 = 1152 - (v33 + 816i64);
                      do
                      {
                        v40 = *v38;
                        v38[v39] = *v38;
                        ++v38;
                      }
                      while ( v40 );
                      if ( v36 >= 0x40 )
                        _report_rangecheckfailure(v38);
                      *v37 = 0;
                      sub_140002490(::TimeStr, "%s.%03d%s", TimeStr, *(unsigned __int16 *)(v32 + 14), v137);
                      result = 0i64;
                      *((_QWORD *)v4 + 6) = ::TimeStr;
                    }
                    else
                    {
                      v41 = 0i64;
                      do
                      {
                        v42 = TimeStr[v41];
                        ::TimeStr[v41++] = v42;
                      }
                      while ( v42 );
                      *((_QWORD *)v4 + 6) = ::TimeStr;
                      return 0i64;
                    }
                  }
                  else
                  {
                    sub_140002490(::TimeStr, "%10.8f", *(float *)(v32 + 16));
                    result = 0i64;
                    *((_QWORD *)v4 + 6) = ::TimeStr;
                  }
                }
                else
                {
                  strcpy(::TimeStr, *(const char **)(v32 + 32));
                  *((_QWORD *)lpString + 6) = ::TimeStr;
                  return 0i64;
                }
              }
              else
              {
                v43 = *(const LPARAM **)(v32 + 8 * v31 + 24);
                v44 = &WindowName;
                if ( v43 )
                  v44 = v43;
                *((_QWORD *)lpString + 6) = v44;
                return 0i64;
              }
              return result;
            case -105:
              return 1i64;
            case -103:
              v25 = *((_DWORD *)lpString + 6);
              v26 = *(HWND *)lpString;
              lParam[0] = 4;
              lParam[1] = v25;
              SendMessageA(v26, 0x1005u, 0i64, (LPARAM)lParam);
              v27 = (char *)Block;
              v28 = 24i64;
              v29 = 3i64;
              do
              {
                v30 = *(void **)&v27[v28];
                if ( v30 )
                {
                  j__free_base(v30);
                  v27 = (char *)Block;
                }
                v28 += 8i64;
                --v29;
              }
              while ( v29 );
              j__free_base(v27);
              return 0i64;
          }
          break;
        default:
          goto LABEL_301;
      }
      return 0i64;
    }
    v54 = wParam;
    if ( (unsigned __int16)wParam <= 0x9C47u )
    {
      switch ( (unsigned __int16)wParam )
      {
        case 0x9C47u:
          sub_140013B40(hWnd, &byte_1400A2650[384 * (unsigned int)ArgList], qword_1400A37F8, 0);
          return 0i64;
        case 0x68u:
          SendMessageA(hWnd, 0x10u, 0i64, 0i64);
          return 0i64;
        case 0x12Cu:
          DialogBoxParamA(hInstance, "AboutBox", hWnd, (DLGPROC)sub_140002CC0, 0i64);
          return 0i64;
      }
LABEL_242:
      if ( (unsigned __int16)(wParam + 15536) <= 9u )
      {
        v104 = (unsigned __int16)wParam - 50000;
        if ( v104 != (_DWORD)ArgList )
        {
          EnterCriticalSection(&CriticalSection);
          sub_14000A2C0(v7, v104);
LABEL_245:
          LeaveCriticalSection(&CriticalSection);
          return 0i64;
        }
        return 0i64;
      }
      Msg = 273;
      return DefWindowProcA(hWnd, Msg, wParam, (LPARAM)lpString);
    }
    switch ( (unsigned __int16)wParam )
    {
      case 0x9C4Cu:
        sub_140013B40(hWnd, &byte_1400A2650[384 * (unsigned int)ArgList], qword_1400A37F8, 1);
        return 0i64;
      case 0x9C51u:
        GetCurrentDirectoryA(0x104u, Buffer);
        v56 = lstrlenA(Buffer);
        sub_140002490(&Buffer[v56], "\\dbgview.hlp");
        FirstFileA = FindFirstFileA(Buffer, &FindFileData);
        if ( FirstFileA == (HANDLE)-1i64 )
        {
          if ( !SearchPathA(0i64, "dbgview.chm", 0i64, 0x104u, Buffer, FilePart) )
            sub_140002490(Buffer, "dbgview.chm");
        }
        else
        {
          FindClose(FirstFileA);
        }
        sub_1400012F0((__int64)v7, (__int64)Buffer, 0, 0i64);
        return 0i64;
      case 0x9C52u:
        v66 = ArgList;
        v67 = (HBITMAP)qword_1400A05C0;
        v68 = byte_1400921B2 == 0;
        v69 = (HBITMAP)qword_1400A05B8;
        byte_1400921B2 = v68;
        if ( v68 )
        {
          v67 = hBitmapChecked;
          v69 = hBitmapUnchecked;
        }
        byte_1400A2770[384 * (unsigned int)ArgList] = v68;
        SubMenu = GetSubMenu(hMenu, 4);
        SetMenuItemBitmaps(SubMenu, v66 + 50000, 0, v69, v67);
        v71 = 0i64;
        if ( !byte_1400921CA )
          goto LABEL_142;
        v72 = ArgList;
        if ( (_DWORD)ArgList )
        {
          sub_140014250(ArgList, 2 - (byte_1400921B2 != 0));
        }
        else
        {
          if ( hDevice == (HANDLE)-1i64 )
            goto LABEL_143;
          v73 = -2096824316;
          if ( byte_1400921B2 )
            v73 = -2096824320;
          if ( !DeviceIoControl(hDevice, v73, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
          {
            v74 = "Unable to hook kernel debug prints.";
            goto LABEL_139;
          }
        }
LABEL_142:
        v72 = ArgList;
LABEL_143:
        if ( byte_1400921C9 && v72 )
          sub_140014250(v72, 4 - (byte_1400921B2 != 0));
        CheckMenuItem(hMenu, 0x9C52u, byte_1400921B2 != 0 ? 8 : 0);
        LOBYTE(v71) = byte_1400921B2 != 0;
        SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C52ui64, v71 + 1);
        InvalidateRect(qword_1400A37E8, 0i64, 1);
        v75 = "APPICONDISABLED";
        if ( byte_1400921B2 )
          v75 = "APPICON";
        IconA = LoadIconA(hInstance, v75);
        sub_14000A540(v7, 1u, IconA);
        return 0i64;
      case 0x9C53u:
        v90 = 8 * (byte_1400921B3 == 0);
        byte_1400921B3 = byte_1400921B3 == 0;
        CheckMenuItem(hMenu, 0x9C53u, v90);
        SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C53ui64, (byte_1400921B3 != 0) + 3i64);
        InvalidateRect(qword_1400A37E8, 0i64, 1);
        return 0i64;
      case 0x9C54u:
        if ( qword_1400921D8 != (HANDLE)-1i64 )
          return 0i64;
        if ( (_DWORD)ArgList )
        {
          sub_140014250(ArgList, 5);
          goto LABEL_104;
        }
        if ( hDevice == (HANDLE)-1i64 || DeviceIoControl(hDevice, 0x83050008, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
        {
          QueryPerformanceCounter(&PerformanceCount);
LABEL_104:
          sub_14000A640(qword_1400A37F8, (unsigned __int64)&unk_1400A3880, 0, 1);
          v55 = 384i64 * (unsigned int)ArgList;
          *(_DWORD *)((char *)&unk_1400A2780 + v55) += *(_DWORD *)((char *)&unk_1400A2784 + v55);
          result = 0i64;
          *(_DWORD *)((char *)&unk_1400A2784 + v55) = 0;
          return result;
        }
        goto LABEL_186;
      case 0x9C56u:
        DialogBoxParamA(hInstance, "Filter", hWnd, (DLGPROC)sub_14000D5D0, 0i64);
        return 0i64;
      case 0x9C58u:
        v45 = qword_140093590;
        if ( qword_140093590 )
          goto LABEL_70;
        byte_14009F500 = 0;
        sub_140011780(v7);
        return 0i64;
      case 0x9C5Au:
        v86 = byte_1400921C8 == 0;
        byte_1400921C8 = byte_1400921C8 == 0;
        if ( (_DWORD)ArgList )
        {
          sub_140014250(ArgList, v86 + 6);
        }
        else if ( hDevice != (HANDLE)-1i64
               && !DeviceIoControl(hDevice, 4 * v86 - 2096824304, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
        {
LABEL_186:
          v74 = "Couldn't access device driver";
LABEL_139:
          sub_140002BF0(v7, v74);
          return 1i64;
        }
        CheckMenuItem(hMenu, 0x9C5Au, byte_1400921C8 != 0 ? 8 : 0);
        SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Aui64, 10i64 - (byte_1400921C8 != 0));
        InvalidateRect(qword_1400A37E8, 0i64, 1);
        return 0i64;
      case 0x9C5Bu:
        DialogBoxParamA(hInstance, "History", hWnd, (DLGPROC)sub_140010800, 0i64);
        return 0i64;
      case 0x9C5Cu:
        v84 = byte_1400921C9 == 0;
        byte_1400921C9 = byte_1400921C9 == 0;
        if ( (_DWORD)ArgList )
        {
          sub_140014250(ArgList, !v84 + 3);
        }
        else
        {
          byte_1400A2772 = v84;
          if ( v84 )
          {
            if ( !DGBView_StartListener_140005710(0) )
            {
              sub_1400053E0(v138);
              sub_140002490(Text, "Unable to monitor Win32 debug output: %s\n", v138);
              MessageBoxA(0i64, Text, "DebugView", 0x30u);
              byte_1400921C9 = 0;
            }
          }
          else
          {
            DBGView_CloseListener(0);
          }
        }
        CheckMenuItem(hMenu, 0x9C5Cu, byte_1400921C9 != 0 ? 8 : 0);
        v80 = 40028i64;
        v81 = 13i64 - (byte_1400921C9 != 0);
        goto LABEL_159;
      case 0x9C5Du:
        v87 = 8 * (byte_1400921CC == 0);
        byte_1400921CC = byte_1400921CC == 0;
        CheckMenuItem(hMenu, 0x9C5Du, v87);
        SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C5Dui64, 15i64 - (byte_1400921CC != 0));
        InvalidateRect(qword_1400A37E8, 0i64, 1);
        v88 = byte_1400921CC == 0;
        v89 = GetMenu(v7);
        EnableMenuItem(v89, 0x9C77u, v88);
LABEL_65:
        InvalidateRect(qword_1400A37F8, 0i64, 1);
        return 0i64;
      case 0x9C5Fu:
        v77 = byte_1400921CA == 0;
        byte_1400921CA = byte_1400921CA == 0;
        if ( !byte_1400921B2 )
          goto LABEL_158;
        if ( (_DWORD)ArgList )
        {
          sub_140014250(ArgList, !v77 + 1);
        }
        else
        {
          v78 = hDevice;
          if ( hDevice == (HANDLE)-1i64 )
          {
            sub_14000A080(v7);
            v78 = hDevice;
          }
          v79 = -2096824316;
          if ( byte_1400921CA )
            v79 = -2096824320;
          if ( !DeviceIoControl(v78, v79, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
            return 0i64;
        }
LABEL_158:
        CheckMenuItem(hMenu, 0x9C5Fu, byte_1400921CA != 0 ? 8 : 0);
        v80 = 40031i64;
        v81 = 18i64 - (byte_1400921CA != 0);
LABEL_159:
        SendMessageA(qword_1400A37E8, 0x42Bu, v80, v81);
        InvalidateRect(qword_1400A37E8, 0i64, 1);
        return 0i64;
      case 0x9C60u:
        v98 = GetDC(qword_1400A37F8);
        v131 = lf;
        v120.hDC = CreateCompatibleDC(v98);
        ReleaseDC(v7, v98);
        v120.hwndOwner = qword_1400A37F8;
        v120.lStructSize = 104;
        v120.lpLogFont = &v131;
        v120.hInstance = hInstance;
        v120.nFontType = 0x2000;
        *(_QWORD *)&v120.Flags = 8273i64;
        v120.lCustData = 0i64;
        v120.lpszStyle = 0i64;
        v120.nSizeMin = 0;
        v120.nSizeMax = 20;
        v120.lpfnHook = 0i64;
        v120.lpTemplateName = (LPCSTR)1543;
        if ( !ChooseFontA(&v120) )
          return 0i64;
        lf = v131;
        DeleteObject(::wParam);
        FontIndirectA = CreateFontIndirectA(&lf);
        ::wParam = FontIndirectA;
        v100 = &qword_1400A2648;
        v101 = 10i64;
        do
        {
          if ( *v100 )
          {
            SendMessageA(*v100, 0x30u, (WPARAM)FontIndirectA, 0i64);
            InvalidateRgn(*v100, 0i64, 1);
            FontIndirectA = (HFONT)::wParam;
          }
          v100 += 48;
          --v101;
        }
        while ( v101 );
        GetWindowRect(hWndParent, &Rect);
        SetWindowPos(hWndParent, 0i64, Rect.left, Rect.top, Rect.right - Rect.left - 1, Rect.bottom - Rect.top, 4u);
        SetWindowPos(hWndParent, 0i64, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 4u);
        return 0i64;
      case 0x9C61u:
        byte_1400935A5 = byte_1400935A5 == 0;
        v91 = -1i64;
        if ( !byte_1400935A5 )
          v91 = -2i64;
        SetWindowPos(hWnd, (HWND)v91, 0, 0, 0, 0, 3u);
        CheckMenuItem(hMenu, 0x9C61u, byte_1400935A5 != 0 ? 8 : 0);
        return 0i64;
      case 0x9C62u:
        if ( hThread != (HANDLE)-1i64 )
          goto LABEL_296;
        if ( !DialogBoxParamA(hInstance, "COMPUTER", hWnd, (DLGPROC)sub_140009C50, (LPARAM)qword_1400957C0) )
          return 0i64;
        hDlg = CreateDialogParamA(hInstance, "CONNECT", v7, (DLGPROC)sub_1400036E0, 0i64);
        sub_140002490(::TimeStr, "Looking up %s...", (const char *)qword_1400957C0);
        SetDlgItemTextA(hDlg, 1004, ::TimeStr);
        hThread = (HANDLE)beginthread((_beginthread_proc_type)sub_140004E00, 0, qword_1400957C0);
        return 0i64;
      case 0x9C63u:
        if ( qword_1400921D8 != (HANDLE)-1i64 )
          return 0i64;
        v45 = qword_1400958E0;
        if ( qword_1400958E0 )
        {
LABEL_70:
          SetFocus(v45);
          return 0i64;
        }
        else
        {
          v102 = ArgList;
          v103 = (unsigned int)ArgList;
          byte_1400A2641[384 * (unsigned int)ArgList] = 1;
          if ( v102 )
            beginthread((_beginthread_proc_type)sub_140005300, 0, (void *)v103);
          else
            sub_140004E50(v7);
          return 0i64;
        }
      case 0x9C65u:
        v94 = ArgList + 1;
        while ( 2 )
        {
          v95 = 0i64;
          if ( v94 != 10 )
            v95 = v94;
          if ( (_DWORD)v95 == (_DWORD)ArgList )
            return 0i64;
          if ( !*(&qword_1400A2648 + 48 * v95) || !(_DWORD)v95 && !byte_1400921B1 )
          {
            v94 = v95 + 1;
            continue;
          }
          break;
        }
        sub_14000A2C0(hWnd, v95);
        return 0i64;
      case 0x9C66u:
        goto LABEL_125;
      case 0x9C67u:
        sub_14000FB00(hWnd);
        return 0i64;
      case 0x9C69u:
        byte_1400921CD = byte_1400921CD == 0;
        ShowWindow(qword_1400A37E8, byte_1400921CD != 0 ? 5 : 0);
        v58 = (_DWORD *)qword_14009E1E8;
        for ( k = 0; *v58 != -1; v58 = (_DWORD *)(32i64 * k + qword_14009E1E8) )
        {
          SendMessageA(qword_1400A37E8, 0x404u, (int)v58[1], byte_1400921CD == 0);
          ++k;
        }
        GetClientRect(hWndParent, &Rect);
        v60 = &qword_1400A2648;
        v61 = 10i64;
        do
        {
          if ( *v60 )
            SetWindowPos(
              *v60,
              0i64,
              0,
              byte_1400921CD != 0 ? 0x1C : 0,
              Rect.right - Rect.left,
              Rect.bottom - (byte_1400921CD != 0 ? 0x1C : 0) - Rect.top,
              4u);
          v60 += 48;
          --v61;
        }
        while ( v61 );
        v62 = 8;
        v63 = 40041;
        if ( byte_1400921CD )
          v62 = 0;
        goto LABEL_118;
      case 0x9C6Au:
      case 0x9C6Bu:
        if ( byte_1400921B2 )
        {
          MessageBoxA(hWnd, "Capture must be disabled before printing is allowed.", "DebugView", 0x30u);
          return 0i64;
        }
        EnterCriticalSection(&CriticalSection);
        if ( qword_1400921D8 != (HANDLE)-1i64 )
          goto LABEL_245;
        LeaveCriticalSection(&CriticalSection);
        if ( v54 == -25493 )
        {
          if ( !DialogBoxParamA(hInstance, "PRINTRANGE", v7, (DLGPROC)sub_140013850, (unsigned int)ArgList) )
            return 0i64;
          v92 = (unsigned int)ArgList;
        }
        else
        {
          v128 = 4128;
          v126 = 0;
          v127 = ::Buffer;
          SendMessageA(qword_1400A37F8, 0x102Du, 0i64, (LPARAM)&v125);
          v93 = sub_14003FD10((__int64)::Buffer);
          v92 = (unsigned int)ArgList;
          dword_14009E3A8 = v93;
          dword_14009E3A4 = *((_DWORD *)&unk_1400A2784 + 96 * (unsigned int)ArgList);
          if ( dword_14009E3A4 == v93 )
          {
            MessageBoxA(v7, "Nothing to print.", "DebugView", 0x10u);
            return 0i64;
          }
        }
        qword_1400921D8 = (HANDLE)beginthread((_beginthread_proc_type)sub_140013B10, 0, (void *)v92);
        return 0i64;
      case 0x9C6Du:
        v96 = 8 * (byte_1400921CB == 0);
        byte_1400921CB = byte_1400921CB == 0;
        CheckMenuItem(hMenu, 0x9C6Du, v96);
        *((_BYTE *)&unk_1400A2777 + 384 * (unsigned int)ArgList) = byte_1400921CB;
        return 0i64;
      case 0x9C6Eu:
        v97 = byte_1400935AF;
        goto LABEL_222;
      case 0x9C70u:
        v97 = 0;
        byte_1400935AF = 0;
LABEL_222:
        if ( !Stream && !v97 && !DialogBoxParamA(hInstance, "LOGFILE", hWnd, (DLGPROC)sub_140012770, 0i64) )
          return 0i64;
        sub_140012BF0(v7, 0);
        return 0i64;
      case 0x9C71u:
        sub_1400037E0(hWnd);
        return 0i64;
      case 0x9C72u:
        sub_140002490(Buffer, "%sdbgview.exe", byte_1400A36E0);
        sub_140009460(v7, 1);
        sub_140016650((__int64)&pExecInfo, 0, 0x70ui64);
        pExecInfo.cbSize = 112;
        pExecInfo.lpVerb = "open";
        pExecInfo.fMask = 64;
        pExecInfo.lpFile = Buffer;
        pExecInfo.nShow = 1;
        ShellExecuteExA(&pExecInfo);
        return 0i64;
      case 0x9C73u:
        DialogBoxParamA(hInstance, "CRASHDUMP", hWnd, (DLGPROC)sub_140011900, 0i64);
        return 0i64;
      case 0x9C74u:
        v85 = byte_1400921B0 == 0;
        byte_1400921B0 = byte_1400921B0 == 0;
        if ( (_DWORD)ArgList )
        {
          sub_140014250(ArgList, !v85 + 8);
        }
        else if ( hDevice != (HANDLE)-1i64
               && !DeviceIoControl(hDevice, 4 * !v85 - 2096824268, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
        {
          goto LABEL_186;
        }
        v63 = 40052;
        v62 = byte_1400921B0 != 0 ? 8 : 0;
LABEL_118:
        CheckMenuItem(hMenu, v63, v62);
        return 0i64;
      case 0x9C75u:
        v65 = 8 * (byte_1400935A1 == 0);
        byte_1400935A1 = byte_1400935A1 == 0;
        CheckMenuItem(hMenu, 0x9C75u, v65);
        return 0i64;
      case 0x9C76u:
        byte_1400935A2 = byte_1400935A2 == 0;
        if ( !byte_1400935A2 )
        {
          DBGView_CloseListener(1u);
LABEL_162:
          v82 = byte_1400935A2;
          goto LABEL_163;
        }
        if ( DGBView_StartListener_140005710(1u) )
          goto LABEL_162;
        sub_1400053E0(v138);
        sub_140002490(Text, "Unable to monitor Win32 debug output: %s\n", v138);
        MessageBoxA(0i64, Text, "DebugView", 0x30u);
        v82 = 0;
        byte_1400935A2 = 0;
LABEL_163:
        byte_1400A2773 = v82;
        CheckMenuItem(hMenu, 0x9C76u, v82 != 0 ? 8 : 0);
        result = 0i64;
        break;
      case 0x9C77u:
        v63 = 40055;
        v62 = 8 * (byte_1400935A4 == 0);
        byte_1400935A4 = byte_1400935A4 == 0;
        goto LABEL_118;
      case 0x9C78u:
        sub_140002810(hWnd, byte_1400935A3);
        return 0i64;
      case 0x9C79u:
        sub_140012130(hWnd, ArgList, qword_1400A37F8, 0i64);
        return 0i64;
      case 0x9C7Au:
        if ( (stru_14009F520.Flags & 1) != 0 )
          v64 = stru_14009F520.Flags & 0xFFFFFFFE;
        else
          v64 = stru_14009F520.Flags | 1;
        stru_14009F520.Flags = v64;
LABEL_125:
        if ( !byte_14009F500 )
          return 0i64;
        SetCapture(qword_140093590);
        qword_1400A05A8 = SetCursor(qword_1400A05A0);
        if ( sub_140010340(v7, (__int64)&stru_14009F520) )
        {
          byte_1400921B3 = 0;
          CheckMenuItem(hMenu, 0x9C53u, 0);
          SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C53ui64, 3i64);
        }
LABEL_33:
        SetCursor(qword_1400A05A8);
        goto LABEL_34;
      case 0x9C7Bu:
        DialogBoxParamA(hInstance, "INSERTCOMMENT", hWnd, (DLGPROC)sub_140010940, 0i64);
        return 0i64;
      case 0x9C7Cu:
        v83 = byte_1400935A3 == 0;
        byte_1400935A3 = byte_1400935A3 == 0;
        if ( hDevice == (HANDLE)-1i64 )
          return 0i64;
        DeviceIoControl(hDevice, 4 * !v83 - 2096824260, 0i64, 0, 0i64, 0, &BytesReturned, 0i64);
        byte_1400A2776 = byte_1400935A3;
        CheckMenuItem(hMenu, 0x9C7Cu, byte_1400935A3 != 0 ? 8 : 0);
        return 0i64;
      default:
        goto LABEL_242;
    }
  }
  return result;
}
// 14001503C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 1400921B0: using guessed type char byte_1400921B0;
// 1400921B1: using guessed type char byte_1400921B1;
// 1400921B2: using guessed type char byte_1400921B2;
// 1400921B3: using guessed type char byte_1400921B3;
// 1400921C8: using guessed type char byte_1400921C8;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400921CB: using guessed type char byte_1400921CB;
// 1400921CC: using guessed type char byte_1400921CC;
// 1400921CD: using guessed type char byte_1400921CD;
// 1400921CE: using guessed type char byte_1400921CE;
// 1400921D0: using guessed type int dword_1400921D0;
// 1400935A1: using guessed type char byte_1400935A1;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935A3: using guessed type char byte_1400935A3;
// 1400935A4: using guessed type char byte_1400935A4;
// 1400935A5: using guessed type char byte_1400935A5;
// 1400935AF: using guessed type char byte_1400935AF;
// 1400935D1: using guessed type char byte_1400935D1;
// 1400957C0: using guessed type LPARAM qword_1400957C0[33];
// 14009E1E8: using guessed type __int64 qword_14009E1E8;
// 14009E1F8: using guessed type __int64 qword_14009E1F8;
// 14009E200: using guessed type int dword_14009E200;
// 14009E210: using guessed type __int64 qword_14009E210;
// 14009E3A4: using guessed type int dword_14009E3A4;
// 14009E3A8: using guessed type int dword_14009E3A8;
// 14009F500: using guessed type char byte_14009F500;
// 1400A05B8: using guessed type __int64 qword_1400A05B8;
// 1400A05C0: using guessed type __int64 qword_1400A05C0;
// 1400A2772: using guessed type char byte_1400A2772;
// 1400A2773: using guessed type char byte_1400A2773;
// 1400A2776: using guessed type char byte_1400A2776;
// 1400A277C: using guessed type char byte_1400A277C;
// 1400A3800: using guessed type int dword_1400A3800;
// 1400A80E1: using guessed type char byte_1400A80E1;
// 1400A81E1: using guessed type char byte_1400A81E1;
// 140005B80: using guessed type unsigned int var_7AC[3];
// 140005B80: using guessed type _DWORD lParam[10];
// 140005B80: using guessed type CHAR TimeStr[64];
// 140005B80: using guessed type char var_2B0[64];
// 140005B80: using guessed type CHAR Buffer[272];

//----- (0000000140007FC0) ----------------------------------------------------
BOOL __fastcall sub_140007FC0(HWND a1)
{
  const CHAR *v2; // rdx
  HICON IconA; // rbx
  CHAR szBuf[4128]; // [rsp+20h] [rbp-1038h] BYREF

  v2 = "APPICONDISABLED";
  if ( byte_1400921B2 )
    v2 = "APPICON";
  IconA = LoadIconA(hInstance, v2);
  GetWindowTextA(a1, szBuf, 4128);
  sub_14000A410(a1, 1u, IconA, szBuf);
  return ShowWindow(a1, 0);
}
// 1400921B2: using guessed type char byte_1400921B2;

//----- (0000000140008070) ----------------------------------------------------
char __fastcall sub_140008070(char *String1, _BYTE *a2)
{
  char v2; // si
  char v3; // r12
  char v4; // r15
  char v5; // al
  char v6; // r13
  char v7; // bp
  char *i; // rbx
  char *v10; // rdi
  char v11; // cl
  char v12; // si
  char v13; // al
  __int64 v14; // rdi
  char v15; // al
  int v16; // ecx
  char v17; // si
  char *v18; // rcx
  char v19; // al
  unsigned __int64 v20; // rdi
  CHAR v21; // al
  bool v22; // zf
  char k; // al
  char j; // al
  HWND WindowA; // rax
  char v27; // [rsp+20h] [rbp-168h]
  char v28; // [rsp+21h] [rbp-167h]
  CHAR Text[272]; // [rsp+30h] [rbp-158h] BYREF

  v2 = 0;
  v3 = 0;
  *a2 = 0;
  v4 = 0;
  v5 = *String1;
  v6 = 0;
  v7 = 0;
  v27 = 0;
  v28 = 0;
  for ( i = String1; *i; v5 = *i )
  {
    v10 = i;
    if ( isspace(v5) )
    {
      ++i;
    }
    else if ( !strnicmp(i, "-accepteula", 0xBui64) || !strnicmp(i, "/accepteula", 0xBui64) )
    {
      i += 11;
    }
    else
    {
      v11 = *i;
      if ( ((*i - 45) & 0xFD) != 0 )
      {
        if ( v7 )
        {
LABEL_97:
          sub_140002490(Text, "Invalid argument: %s\n\nSpecify /? for usage.", i);
          MessageBoxA(0i64, Text, "DebugView", 0x10u);
          return 0;
        }
        v12 = 0;
        v13 = *i;
        if ( v11 == 34 )
        {
          v13 = i[1];
          v12 = 1;
        }
        ++i;
        if ( v11 != 34 )
          i = v10;
        v14 = 0i64;
        if ( v13 )
        {
          do
          {
            if ( !v12 && isspace(*i) )
              break;
            v15 = *i++;
            if ( v15 == 34 )
              break;
            a2[v14++] = v15;
          }
          while ( *i );
        }
        v2 = v27;
        v7 = 1;
        a2[v14] = 0;
      }
      else
      {
        v16 = *++i;
        switch ( toupper(v16) )
        {
          case 'F':
            byte_1400935D1 = 1;
            ++i;
            continue;
          case 'G':
            if ( toupper(i[1]) == 78 )
            {
              byte_1400935A2 = 0;
              i += 2;
            }
            else
            {
              ++i;
              byte_1400935A2 = 1;
            }
            continue;
          case 'H':
            if ( v3 )
            {
              MessageBoxA(0i64, "Command-line options error (/? for usage):\n\n/h specified twice", "DebugView", 0x10u);
              return 0;
            }
            if ( !i[1] )
              return sub_14000A930();
            i += 2;
            dword_1400935B4 = sub_14003FD10((__int64)i);
            for ( j = *i; j; j = *++i )
            {
              if ( isspace(j) )
                break;
            }
            v3 = 1;
            break;
          case 'K':
            if ( toupper(i[1]) == 78 )
            {
              byte_1400921CA = 0;
              i += 2;
            }
            else
            {
              ++i;
              byte_1400921CA = 1;
            }
            continue;
          case 'L':
            if ( byte_1400935AF )
            {
              MessageBoxA(0i64, "Command-line options error (/? for usage):\n\n/l specified twice", "DebugView", 0x10u);
              return 0;
            }
            v17 = 0;
            v18 = i + 1;
            if ( !i[1] )
              return sub_14000A930();
            v19 = i[2];
            i += 2;
            if ( v19 == 34 )
            {
              v19 = v18[2];
              i = v18 + 2;
              v17 = 1;
            }
            v20 = 0i64;
            if ( v19 )
            {
              do
              {
                if ( !v17 && isspace(*i) )
                  break;
                v21 = *i++;
                if ( v21 == 34 )
                  break;
                String[v20++] = v21;
                byte_1400935AF = 1;
              }
              while ( *i );
              if ( v20 >= 0x104 )
                _report_rangecheckfailure(v18);
            }
            v22 = byte_1400935AF == 0;
            String[v20] = 0;
            if ( v22 )
              return sub_14000A930();
            v2 = v27;
            continue;
          case 'M':
            if ( v4 )
            {
              MessageBoxA(0i64, "Command-line options error (/? for usage):\n\n/m specified twice", "DebugView", 0x10u);
              return 0;
            }
            if ( !byte_1400935AF )
              return sub_14000A930();
            if ( v6 )
              return sub_14000A930();
            if ( !i[1] )
              return sub_14000A930();
            i += 2;
            dword_1400935C4 = sub_14003FD10((__int64)i);
            if ( !dword_1400935C4 )
              return sub_14000A930();
            for ( k = *i; k; k = *++i )
            {
              if ( isspace(k) )
                break;
            }
            v4 = 1;
            nIDButton = 1041;
            continue;
          case 'N':
            if ( v6 )
              goto LABEL_91;
            if ( !byte_1400935AF || v4 || v2 )
              return sub_14000A930();
            ++i;
            nIDButton = 1040;
            v6 = 1;
            continue;
          case 'O':
            if ( toupper(i[1]) == 78 )
            {
              byte_1400921CC = 0;
              i += 2;
            }
            else
            {
              byte_1400921CC = 1;
              if ( toupper(i[1]) == 77 )
              {
                byte_1400935A4 = 1;
                ++i;
              }
              ++i;
            }
            continue;
          case 'P':
            if ( !strnicmp(i, "accepteula", 0xAui64) )
            {
              i += 10;
            }
            else
            {
              if ( v28 )
              {
                MessageBoxA(
                  0i64,
                  "Command-line options error (/? for usage):\n\n/a specified twice",
                  "DebugView",
                  0x10u);
                return 0;
              }
              if ( !byte_1400935AF || v6 )
                return sub_14000A930();
              ++i;
              byte_1400935A6 = 1;
              v28 = 1;
            }
            continue;
          case 'Q':
            WindowA = FindWindowA("dbgviewClass", 0i64);
            if ( WindowA )
              PostMessageA(WindowA, 0x10u, 0i64, 0i64);
            else
              MessageBoxA(0i64, "No instnace of DebugView is running on this desktop.", "DebugView", 0x30u);
            return 0;
          case 'T':
            if ( byte_1400935A1 )
            {
              MessageBoxA(0i64, "Command-line options error (/? for usage):\n\n/t specified twice", "DebugView", 0x10u);
              return 0;
            }
            byte_1400935A1 = 1;
            ++i;
            continue;
          case 'V':
            if ( toupper(i[1]) == 78 )
            {
              byte_1400935A3 = 0;
              i += 2;
            }
            else
            {
              ++i;
              byte_1400935A3 = 1;
            }
            continue;
          case 'W':
            if ( v2 )
            {
LABEL_91:
              MessageBoxA(0i64, "Command-line options error (/? for usage):\n\n/w specified twice", "DebugView", 0x10u);
              return 0;
            }
            if ( !byte_1400935AF || !v4 || v6 )
              return sub_14000A930();
            v2 = 1;
            byte_1400935A7 = 1;
            v27 = 1;
            ++i;
            continue;
          case 'X':
            if ( nIDButton != 1040 )
              return sub_14000A930();
            ++i;
            byte_1400935D0 = 1;
            continue;
          default:
            goto LABEL_97;
        }
      }
    }
  }
  if ( !byte_1400935A6 || !v4 )
    return 1;
  MessageBoxA(0i64, "Append and max log file size are incompatible arguments.", "DebugView", 0x10u);
  return 0;
}
// 1400086DE: variable 'v18' is possibly undefined
// 14001503C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 1400921CA: using guessed type char byte_1400921CA;
// 1400921CC: using guessed type char byte_1400921CC;
// 1400935A1: using guessed type char byte_1400935A1;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935A3: using guessed type char byte_1400935A3;
// 1400935A4: using guessed type char byte_1400935A4;
// 1400935A6: using guessed type char byte_1400935A6;
// 1400935A7: using guessed type char byte_1400935A7;
// 1400935AF: using guessed type char byte_1400935AF;
// 1400935B4: using guessed type int dword_1400935B4;
// 1400935C4: using guessed type int dword_1400935C4;
// 1400935D0: using guessed type char byte_1400935D0;
// 1400935D1: using guessed type char byte_1400935D1;

//----- (0000000140008730) ----------------------------------------------------
int sub_140008730()
{
  HGDIOBJ StockObject; // rax
  __int64 v1; // rdi
  BYTE *v2; // rcx
  BYTE *v3; // rax
  __int64 v4; // rdx
  __int128 v5; // xmm0
  __int128 v6; // xmm1
  __int128 v7; // xmm0
  __int128 v8; // xmm1
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  __int128 v11; // xmm0
  __int128 v12; // xmm1
  __int128 v13; // xmm0
  __int128 v14; // xmm1
  int v15; // eax
  __int64 v16; // rcx
  CHAR v17; // al
  __int64 *v18; // rsi
  __int64 v19; // rbx
  __int64 v20; // r14
  COLORREF v21; // ecx
  HBRUSH *v22; // r14
  unsigned __int64 v23; // rbx
  HBRUSH *v24; // rsi
  COLORREF v25; // ecx
  __int64 v26; // rbx
  COLORREF v27; // ecx
  BYTE *v28; // rdx
  int i; // r9d
  BYTE *v30; // rcx
  __int64 v31; // r8
  char *v32; // r8
  char v33; // al
  __int64 v34; // rax
  char *v35; // r8
  int j; // r9d
  char *v37; // rcx
  __int64 v38; // rdx
  char *v39; // rdx
  char v40; // al
  __int64 v41; // rax
  BYTE *v42; // r8
  int k; // r9d
  BYTE *v44; // rcx
  __int64 v45; // rdx
  char *v46; // rdx
  char v47; // al
  __int64 v48; // rax
  BYTE *v49; // r8
  int m; // r9d
  BYTE *v51; // rcx
  __int64 v52; // rdx
  char *v53; // rdx
  char v54; // al
  __int64 v55; // rax
  __int64 v56; // rdx
  char v57; // al
  __int64 v58; // rdx
  char v59; // al
  BYTE *v60; // rbx
  __int64 v61; // rsi
  char *v62; // rax
  BYTE *v63; // rdx
  BYTE v64; // cl
  char v65; // dl
  __int64 v66; // rax
  int result; // eax
  DWORD v68; // [rsp+30h] [rbp-D0h] BYREF
  HKEY hKey; // [rsp+38h] [rbp-C8h] BYREF
  DWORD lpcbData; // [rsp+40h] [rbp-C0h] BYREF
  __int128 v71; // [rsp+48h] [rbp-B8h] BYREF
  __m256i v72; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v73; // [rsp+78h] [rbp-88h]
  int v74; // [rsp+80h] [rbp-80h]
  BYTE Data[4]; // [rsp+90h] [rbp-70h] BYREF
  char v76[1296]; // [rsp+2C0h] [rbp+1C0h] BYREF
  BYTE v77[1296]; // [rsp+7D0h] [rbp+6D0h] BYREF
  BYTE v78[1296]; // [rsp+CE0h] [rbp+BE0h] BYREF
  BYTE v79[1296]; // [rsp+11F0h] [rbp+10F0h] BYREF
  BYTE v80[5152]; // [rsp+1700h] [rbp+1600h] BYREF

  sub_140016650((__int64)&dword_1400A8300, 0, 0x224ui64);
  StockObject = GetStockObject(13);
  GetObjectA(StockObject, 60, &v71);
  v1 = 0i64;
  strcpy(&v72.m256i_i8[12], "Courier New");
  *(_QWORD *)&v71 = 4294967283i64;
  v72.m256i_i32[0] = 400;
  *(_DWORD *)&byte_1400A832C[56] = v74;
  *(_OWORD *)byte_1400A832C = v71;
  Y = 100;
  X = 100;
  *(__m256i *)&byte_1400A832C[16] = v72;
  nWidth = 500;
  nHeight = 300;
  *(_QWORD *)&byte_1400A832C[48] = v73;
  word_1400A8324 = 1;
  word_1400A839C = 256;
  byte_1400A8326 = 1;
  byte_1400A8329 = 0;
  byte_1400A8394 = 1;
  dword_1400A8368 = 16843008;
  byte_1400A84CC = 1;
  dword_1400A8398 = 0;
  byte_1400A84A2 = 0;
  byte_1400A839E = 0;
  dword_1400A836C = 0xFFFFFF;
  dword_1400A8380 = 255;
  dword_1400A8370 = 0xFFFFFF;
  dword_1400A8384 = 16711808;
  dword_1400A8374 = 0xFFFFFF;
  dword_1400A8388 = 4227327;
  dword_1400A8378 = 0xFFFFFF;
  dword_1400A838C = 8421440;
  dword_1400A837C = 0xFFFFFF;
  dword_1400A8390 = 16744448;
  qword_1400A84A4 = 0i64;
  dword_1400A84B8 = 16744576;
  dword_1400A84BC = 8454016;
  qword_1400A84AC = 0i64;
  dword_1400A84C0 = 16777088;
  dword_1400A84C4 = 8454016;
  dword_1400A84B4 = 0;
  dword_1400A84C8 = 8454143;
  dword_1400A84D0 = 0xFFFFFF;
  dword_1400A84F8 = 255;
  dword_1400A84D4 = 0xFFFFFF;
  dword_1400A84FC = 16711808;
  dword_1400A84D8 = 0xFFFFFF;
  dword_1400A8500 = 4227327;
  dword_1400A84DC = 0xFFFFFF;
  dword_1400A8504 = 8421440;
  qword_1400A84E0 = 0xFFFFFFi64;
  dword_1400A8508 = 16744448;
  dword_1400A850C = 16744576;
  qword_1400A84E8 = 0i64;
  dword_1400A8510 = 8454016;
  dword_1400A8514 = 16777088;
  qword_1400A84F0 = 0i64;
  dword_1400A8518 = 8454016;
  dword_1400A851C = 8454143;
  dword_1400A8314 = 35;
  dword_1400A8318 = 100;
  qword_1400A831C = 300i64;
  sub_140016650((__int64)byte_14009DCC0, 0, 0x505ui64);
  strcpy(v76, "*");
  v76[2] = 0;
  v78[0] = 0;
  v79[0] = 0;
  sub_140016650((__int64)v80, 0, 0x1415ui64);
  sub_140016650((__int64)qword_1400A6180, 0, 0x500ui64);
  sub_140016650((__int64)qword_1400A6680, 0, 0x500ui64);
  sub_140016650((__int64)String1, 0, 0x500ui64);
  sub_140016650((__int64)&byte_1400A4880, 0, 0x1400ui64);
  RegDeleteKeyA(HKEY_CURRENT_USER, "Software\\Systems Internals\\DbgView");
  RegCreateKeyA(HKEY_CURRENT_USER, "Software\\Sysinternals\\DbgView", &hKey);
  v77[0] = 0;
  byte_14009DCC0[0] = 0;
  byte_14009DDC1 = 0;
  byte_14009DEC2 = 0;
  byte_14009DFC3 = 0;
  byte_14009E0C4 = 0;
  lpcbData = 548;
  *(_DWORD *)Data = 0;
  RegQueryValueExA(hKey, "Settings", 0i64, 0i64, Data, &lpcbData);
  v68 = 1286;
  RegQueryValueExA(hKey, "Recent", 0i64, 0i64, v77, &v68);
  v68 = 1286;
  RegQueryValueExA(hKey, "InFilters", 0i64, 0i64, (LPBYTE)v76, &v68);
  v68 = 1286;
  RegQueryValueExA(hKey, "ExFilters", 0i64, 0i64, v78, &v68);
  v68 = 1286;
  RegQueryValueExA(hKey, "HiFilters", 0i64, 0i64, v79, &v68);
  v68 = 5141;
  RegQueryValueExA(hKey, "HiCurFilters", 0i64, 0i64, v80, &v68);
  CloseHandle(hKey);
  if ( *(_DWORD *)Data == 400 )
  {
    v2 = &dword_1400A8300;
    v3 = Data;
    v4 = 4i64;
    do
    {
      v2 += 128;
      v5 = *(_OWORD *)v3;
      v6 = *((_OWORD *)v3 + 1);
      v3 += 128;
      *((_OWORD *)v2 - 8) = v5;
      v7 = *((_OWORD *)v3 - 6);
      *((_OWORD *)v2 - 7) = v6;
      v8 = *((_OWORD *)v3 - 5);
      *((_OWORD *)v2 - 6) = v7;
      v9 = *((_OWORD *)v3 - 4);
      *((_OWORD *)v2 - 5) = v8;
      v10 = *((_OWORD *)v3 - 3);
      *((_OWORD *)v2 - 4) = v9;
      v11 = *((_OWORD *)v3 - 2);
      *((_OWORD *)v2 - 3) = v10;
      v12 = *((_OWORD *)v3 - 1);
      *((_OWORD *)v2 - 2) = v11;
      *((_OWORD *)v2 - 1) = v12;
      --v4;
    }
    while ( v4 );
    v13 = *(_OWORD *)v3;
    v14 = *((_OWORD *)v3 + 1);
    v15 = *((_DWORD *)v3 + 8);
    *(_OWORD *)v2 = v13;
    *((_OWORD *)v2 + 1) = v14;
    *((_DWORD *)v2 + 8) = v15;
  }
  dword_1400935B4 = HIDWORD(qword_1400A831C);
  v16 = 0i64;
  byte_1400921C8 = word_1400A8324;
  byte_1400921B0 = HIBYTE(word_1400A839C);
  byte_1400921C9 = byte_1400A8326;
  byte_1400921CC = byte_1400A8327;
  byte_1400935A4 = byte_1400A8328;
  byte_1400921CA = byte_1400A8329;
  byte_1400921B3 = byte_1400A84CC;
  byte_1400921CD = BYTE1(dword_1400A8368);
  byte_1400935A5 = dword_1400A8368;
  byte_1400921CB = byte_1400A8394;
  byte_1400935A6 = word_1400A839C;
  byte_1400935A7 = byte_1400A84CD;
  dword_1400935C4 = dword_1400A8398;
  byte_1400935A2 = byte_1400A84A2;
  byte_1400935A3 = byte_1400A8520;
  do
  {
    v17 = *(&dword_1400A8300 + v16 + 158);
    String[v16++] = v17;
  }
  while ( v17 );
  lf = *(LOGFONTA *)byte_1400A832C;
  wParam = CreateFontIndirectA(&lf);
  v18 = qword_1400A7F80;
  v19 = 0i64;
  byte_14009E4C5 = BYTE2(dword_1400A8368);
  v20 = 5i64;
  byte_14009E4C4 = HIBYTE(dword_1400A8368);
  do
  {
    v21 = *(_DWORD *)(&dword_1400A8300 + v19 * 4 + 128);
    dword_1400A8080[v19] = *(_DWORD *)(&dword_1400A8300 + v19 * 4 + 108);
    dword_1400A8020[v19] = v21;
    *v18++ = (__int64)CreateSolidBrush(v21);
    ++v19;
    --v20;
  }
  while ( v20 );
  v22 = (HBRUSH *)&unk_1400A7FA8;
  v23 = 0i64;
  v24 = (HBRUSH *)&unk_1400A7FD0;
  do
  {
    v25 = *(_DWORD *)(&dword_1400A8300 + v23 + 440);
    *(_DWORD *)((char *)&qword_1400A8094 + v23) = *(_DWORD *)(&dword_1400A8300 + v23 + 420);
    dword_1400A8034[v23 / 4] = v25;
    *v22 = CreateSolidBrush(v25);
    v23 += 4i64;
    ++v22;
  }
  while ( (__int64)v22 < (__int64)&unk_1400A7FD0 );
  v26 = 0i64;
  do
  {
    v27 = *(_DWORD *)(&dword_1400A8300 + v26 * 4 + 504);
    dword_1400A80A8[v26] = *(_DWORD *)(&dword_1400A8300 + v26 * 4 + 464);
    dword_1400A8048[v26] = v27;
    *v24 = CreateSolidBrush(v27);
    ++v26;
    ++v24;
  }
  while ( (__int64)v24 < (__int64)dword_1400A8020 );
  v28 = v77;
  for ( i = 0; *v28; v28 += v34 + 1 )
  {
    v30 = v28;
    v31 = 257i64 * i++;
    v32 = (char *)(&byte_14009DCC0[v31] - v28);
    do
    {
      v33 = *v30;
      v32[(_QWORD)v30] = *v30;
      ++v30;
    }
    while ( v33 );
    v34 = -1i64;
    do
      ++v34;
    while ( v28[v34] );
  }
  v35 = v76;
  for ( j = 0; *v35; v35 += v41 + 1 )
  {
    v37 = v35;
    v38 = (__int64)j++ << 8;
    v39 = (char *)(&qword_1400A6680[v38] - v35);
    do
    {
      v40 = *v37;
      v39[(_QWORD)v37] = *v37;
      ++v37;
    }
    while ( v40 );
    v41 = -1i64;
    do
      ++v41;
    while ( v35[v41] );
  }
  v42 = v78;
  for ( k = 0; *v42; v42 += v48 + 1 )
  {
    v44 = v42;
    v45 = (__int64)k++ << 8;
    v46 = (char *)(&qword_1400A6180[v45] - (char *)v42);
    do
    {
      v47 = *v44;
      v46[(_QWORD)v44] = *v44;
      ++v44;
    }
    while ( v47 );
    v48 = -1i64;
    do
      ++v48;
    while ( v42[v48] );
  }
  v49 = v79;
  for ( m = 0; *v49; v49 += v55 + 1 )
  {
    v51 = v49;
    v52 = (__int64)m++ << 8;
    v53 = (char *)((char *)String1 + v52 - (char *)v49);
    do
    {
      v54 = *v51;
      v53[(_QWORD)v51] = *v51;
      ++v51;
    }
    while ( v54 );
    v55 = -1i64;
    do
      ++v55;
    while ( v49[v55] );
  }
  v56 = 0i64;
  do
  {
    v57 = qword_1400A6680[v56];
    *(&byte_1400A81E0 + v56++) = v57;
  }
  while ( v57 );
  strupr(&byte_1400A81E0);
  v58 = 0i64;
  do
  {
    v59 = qword_1400A6180[v58];
    *(&Source + v58++) = v59;
  }
  while ( v59 );
  strupr(&Source);
  v60 = v80;
  v61 = 20i64;
  do
  {
    v62 = (char *)&byte_1400A4880 + v1;
    v63 = v60;
    do
    {
      v64 = *v63;
      v63[(char *)&byte_1400A4880 + v1 - (char *)v60] = *v63;
      ++v63;
    }
    while ( v64 );
    do
    {
      v65 = *v62;
      v62[&unk_1400A6B80 - (_UNKNOWN *)&byte_1400A4880] = *v62;
      ++v62;
    }
    while ( v65 );
    strupr((char *)&unk_1400A6B80 + v1);
    v66 = -1i64;
    do
      ++v66;
    while ( v60[v66] );
    v1 += 256i64;
    v60 += v66 + 1;
    --v61;
  }
  while ( v61 );
  if ( X > GetSystemMetrics(78) )
    X = GetSystemMetrics(78) - 200;
  result = GetSystemMetrics(79);
  if ( Y > result )
  {
    result = GetSystemMetrics(79) - 200;
    Y = result;
  }
  return result;
}
// 1400921B0: using guessed type char byte_1400921B0;
// 1400921B3: using guessed type char byte_1400921B3;
// 1400921C8: using guessed type char byte_1400921C8;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400921CB: using guessed type char byte_1400921CB;
// 1400921CC: using guessed type char byte_1400921CC;
// 1400921CD: using guessed type char byte_1400921CD;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935A3: using guessed type char byte_1400935A3;
// 1400935A4: using guessed type char byte_1400935A4;
// 1400935A5: using guessed type char byte_1400935A5;
// 1400935A6: using guessed type char byte_1400935A6;
// 1400935A7: using guessed type char byte_1400935A7;
// 1400935B4: using guessed type int dword_1400935B4;
// 1400935C4: using guessed type int dword_1400935C4;
// 14009DCC0: using guessed type _BYTE byte_14009DCC0[257];
// 14009DDC1: using guessed type char byte_14009DDC1;
// 14009DEC2: using guessed type char byte_14009DEC2;
// 14009DFC3: using guessed type char byte_14009DFC3;
// 14009E0C4: using guessed type char byte_14009E0C4;
// 14009E4C4: using guessed type char byte_14009E4C4;
// 14009E4C5: using guessed type char byte_14009E4C5;
// 1400A5C80: using guessed type LPARAM String1[160];
// 1400A7F80: using guessed type __int64 qword_1400A7F80[5];
// 1400A8020: using guessed type int dword_1400A8020[];
// 1400A8034: using guessed type int dword_1400A8034[];
// 1400A8048: using guessed type int dword_1400A8048[];
// 1400A8080: using guessed type int dword_1400A8080[];
// 1400A8094: using guessed type __int64 qword_1400A8094;
// 1400A80A8: using guessed type int dword_1400A80A8[];
// 1400A8314: using guessed type int dword_1400A8314;
// 1400A8318: using guessed type int dword_1400A8318;
// 1400A831C: using guessed type __int64 qword_1400A831C;
// 1400A8324: using guessed type __int16 word_1400A8324;
// 1400A8326: using guessed type char byte_1400A8326;
// 1400A8327: using guessed type char byte_1400A8327;
// 1400A8328: using guessed type char byte_1400A8328;
// 1400A8329: using guessed type char byte_1400A8329;
// 1400A8368: using guessed type int dword_1400A8368;
// 1400A836C: using guessed type int dword_1400A836C;
// 1400A8370: using guessed type int dword_1400A8370;
// 1400A8374: using guessed type int dword_1400A8374;
// 1400A8378: using guessed type int dword_1400A8378;
// 1400A837C: using guessed type int dword_1400A837C;
// 1400A8380: using guessed type int dword_1400A8380;
// 1400A8384: using guessed type int dword_1400A8384;
// 1400A8388: using guessed type int dword_1400A8388;
// 1400A838C: using guessed type int dword_1400A838C;
// 1400A8390: using guessed type int dword_1400A8390;
// 1400A8394: using guessed type char byte_1400A8394;
// 1400A8398: using guessed type int dword_1400A8398;
// 1400A839C: using guessed type __int16 word_1400A839C;
// 1400A839E: using guessed type char byte_1400A839E;
// 1400A84A2: using guessed type char byte_1400A84A2;
// 1400A84A4: using guessed type __int64 qword_1400A84A4;
// 1400A84AC: using guessed type __int64 qword_1400A84AC;
// 1400A84B4: using guessed type int dword_1400A84B4;
// 1400A84B8: using guessed type int dword_1400A84B8;
// 1400A84BC: using guessed type int dword_1400A84BC;
// 1400A84C0: using guessed type int dword_1400A84C0;
// 1400A84C4: using guessed type int dword_1400A84C4;
// 1400A84C8: using guessed type int dword_1400A84C8;
// 1400A84CC: using guessed type char byte_1400A84CC;
// 1400A84CD: using guessed type char byte_1400A84CD;
// 1400A84D0: using guessed type int dword_1400A84D0;
// 1400A84D4: using guessed type int dword_1400A84D4;
// 1400A84D8: using guessed type int dword_1400A84D8;
// 1400A84DC: using guessed type int dword_1400A84DC;
// 1400A84E0: using guessed type __int64 qword_1400A84E0;
// 1400A84E8: using guessed type __int64 qword_1400A84E8;
// 1400A84F0: using guessed type __int64 qword_1400A84F0;
// 1400A84F8: using guessed type int dword_1400A84F8;
// 1400A84FC: using guessed type int dword_1400A84FC;
// 1400A8500: using guessed type int dword_1400A8500;
// 1400A8504: using guessed type int dword_1400A8504;
// 1400A8508: using guessed type int dword_1400A8508;
// 1400A850C: using guessed type int dword_1400A850C;
// 1400A8510: using guessed type int dword_1400A8510;
// 1400A8514: using guessed type int dword_1400A8514;
// 1400A8518: using guessed type int dword_1400A8518;
// 1400A851C: using guessed type int dword_1400A851C;
// 1400A8520: using guessed type char byte_1400A8520;

//----- (00000001400091E0) ----------------------------------------------------
INT_PTR __fastcall sub_1400091E0(HWND a1, int a2, __int16 a3, const char *a4)
{
  const char *v4; // rbx
  int v6; // edx
  int v7; // edx
  HCURSOR v9; // rdi
  DWORD v10; // ebx
  signed __int64 v11; // rcx
  char v12; // al
  struct _NETRESOURCEA NetResource; // [rsp+20h] [rbp-2B8h] BYREF
  CHAR String[32]; // [rsp+50h] [rbp-288h] BYREF
  CHAR Password[32]; // [rsp+70h] [rbp-268h] BYREF
  char Buffer[272]; // [rsp+90h] [rbp-248h] BYREF
  CHAR v17[272]; // [rsp+1A0h] [rbp-138h] BYREF

  v4 = a4;
  v6 = a2 - 16;
  if ( v6 )
  {
    v7 = v6 - 256;
    if ( v7 )
    {
      if ( v7 != 1 )
        return 0i64;
      if ( a3 != 1 && a3 != 1005 )
      {
        if ( a3 == 2 )
          EndDialog(a1, 0i64);
        return 0i64;
      }
      GetDlgItemTextA(a1, 1006, String, 32);
      GetDlgItemTextA(a1, 1007, Password, 32);
      SetCapture(a1);
      v9 = SetCursor(qword_1400A05A0);
      sub_140002490(Buffer, "\\\\%s\\ADMIN$", byte_140094680);
      NetResource.lpRemoteName = Buffer;
      NetResource.dwType = 0;
      NetResource.lpLocalName = 0i64;
      NetResource.lpProvider = 0i64;
      v10 = WNetAddConnection2A(&NetResource, Password, String, 0);
      SetCursor(v9);
      ReleaseCapture();
      EndDialog(a1, v10 == 0);
    }
    else
    {
      sub_140002490(v17, "DebugView Login to %s", a4);
      SetWindowTextA(a1, v17);
      v11 = byte_140094680 - v4;
      do
      {
        v12 = *v4;
        v4[v11] = *v4;
        ++v4;
      }
      while ( v12 );
    }
  }
  else
  {
    EndDialog(a1, 0i64);
  }
  return 1i64;
}

//----- (0000000140009390) ----------------------------------------------------
int __fastcall sub_140009390(unsigned int a1)
{
  __int64 v1; // rcx
  void *v2; // rax
  CHAR Name[272]; // [rsp+20h] [rbp-128h] BYREF

  v1 = 384i64 * a1;
  v2 = &unk_1400A2640;
  if ( *((_BYTE *)&unk_1400A2640 + v1 + 288) )
  {
    sub_140002490(Name, "\\\\%s\\ADMIN$", (const char *)&unk_1400A2640 + v1 + 16);
    LODWORD(v2) = WNetCancelConnection2A(Name, 0, 1);
  }
  return (int)v2;
}

//----- (0000000140009410) ----------------------------------------------------
__int64 sub_140009410()
{
  HMODULE ModuleHandleA; // rax
  FARPROC ProcAddress; // rbx
  HANDLE CurrentProcess; // rax
  unsigned int v4; // [rsp+30h] [rbp+8h] BYREF

  v4 = 0;
  ModuleHandleA = GetModuleHandleA("kernel32.dll");
  ProcAddress = GetProcAddress(ModuleHandleA, "IsWow64Process");
  if ( ProcAddress )
  {
    CurrentProcess = GetCurrentProcess();
    ((void (__fastcall *)(HANDLE, unsigned int *))ProcAddress)(CurrentProcess, &v4);
  }
  return v4;
}

//----- (0000000140009460) ----------------------------------------------------
int __fastcall sub_140009460(HWND a1, char a2)
{
  int *v4; // rdi
  int v5; // r12d
  WPARAM v6; // rbx
  __int64 v7; // rsi
  int v8; // eax
  __int64 v9; // rcx
  BYTE v10; // al
  LPARAM *v11; // r9
  BYTE *v12; // r15
  int i; // r8d
  char *v14; // rax
  __int64 v15; // rdx
  char v16; // cl
  __int64 v17; // rax
  LPARAM *v18; // r9
  BYTE *v19; // r14
  int j; // r8d
  LPARAM *v21; // rcx
  signed __int64 v22; // rdx
  char v23; // al
  __int64 v24; // rax
  LPARAM *v25; // r9
  BYTE *v26; // rsi
  int k; // r8d
  LPARAM *v28; // rcx
  signed __int64 v29; // rdx
  char v30; // al
  __int64 v31; // rax
  LPARAM *v32; // r8
  BYTE *v33; // rdi
  LPARAM *v34; // rcx
  signed __int64 v35; // rdx
  char v36; // al
  __int64 v37; // rax
  BYTE *v38; // rbx
  LPARAM *v39; // r8
  __int64 v40; // r9
  LPARAM *v41; // rcx
  char v42; // al
  __int64 v43; // rax
  int v44; // esp
  HKEY hKey; // [rsp+30h] [rbp-D0h] BYREF
  struct tagRECT v47; // [rsp+38h] [rbp-C8h] BYREF
  BYTE v48[176]; // [rsp+50h] [rbp-B0h] BYREF
  _BYTE v49[1120]; // [rsp+100h] [rbp+0h] BYREF
  BYTE v50[1296]; // [rsp+560h] [rbp+460h] BYREF
  BYTE v51[1296]; // [rsp+A70h] [rbp+970h] BYREF
  BYTE v52[1296]; // [rsp+F80h] [rbp+E80h] BYREF
  BYTE v53[1296]; // [rsp+1490h] [rbp+1390h] BYREF

  *(_DWORD *)&dword_1400A8300 = 400;
  GetWindowRect(a1, &v47);
  if ( !IsIconic(a1) && !IsZoomed(a1) )
  {
    X = v47.left;
    nWidth = v47.right - v47.left;
    Y = v47.top;
    nHeight = v47.bottom - v47.top;
  }
  v4 = &dword_1400A8314;
  HIBYTE(word_1400A8324) = IsZoomed(a1);
  LOBYTE(dword_1400A8368) = byte_1400935A5;
  v5 = 0;
  BYTE1(dword_1400A8368) = byte_1400921CD;
  v6 = 0i64;
  v7 = 3i64;
  do
  {
    v8 = SendMessageA(qword_1400A37F8, 0x101Du, v6++, 0i64);
    *v4++ = v8;
    --v7;
  }
  while ( v7 );
  HIDWORD(qword_1400A831C) = dword_1400935B4;
  byte_1400A84A2 = byte_1400935A2;
  byte_1400A8520 = byte_1400935A3;
  byte_1400A8327 = byte_1400921CC;
  byte_1400A8328 = byte_1400935A4;
  LOBYTE(word_1400A8324) = byte_1400921C8;
  HIBYTE(word_1400A839C) = byte_1400921B0;
  byte_1400A84CC = byte_1400921B3;
  byte_1400A8326 = byte_1400921C9;
  byte_1400A8329 = byte_1400921CA;
  byte_1400A8394 = byte_1400921CB;
  *(LOGFONTA *)byte_1400A832C = lf;
  BYTE2(dword_1400A8368) = byte_14009E4C5;
  HIBYTE(dword_1400A8368) = byte_14009E4C4;
  dword_1400A836C = dword_1400A8080;
  dword_1400A8380 = dword_1400A8020;
  dword_1400A8370 = dword_1400A8084;
  dword_1400A8384 = dword_1400A8024;
  dword_1400A8374 = dword_1400A8088;
  dword_1400A8388 = dword_1400A8028;
  dword_1400A8378 = dword_1400A808C;
  dword_1400A838C = dword_1400A802C;
  dword_1400A837C = dword_1400A8090;
  dword_1400A8390 = dword_1400A8030;
  qword_1400A84A4 = qword_1400A8094;
  dword_1400A84B8 = dword_1400A8034;
  dword_1400A84BC = dword_1400A8038;
  qword_1400A84AC = qword_1400A809C;
  dword_1400A84C0 = dword_1400A803C;
  dword_1400A84C4 = dword_1400A8040;
  dword_1400A84B4 = dword_1400A80A4;
  dword_1400A84C8 = dword_1400A8044;
  dword_1400A84D0 = dword_1400A80A8;
  dword_1400A84F8 = dword_1400A8048;
  dword_1400A84D4 = dword_1400A80AC;
  dword_1400A84FC = dword_1400A804C;
  v9 = 0i64;
  dword_1400A84D8 = dword_1400A80B0;
  dword_1400A8500 = dword_1400A8050;
  dword_1400A84DC = dword_1400A80B4;
  dword_1400A8504 = dword_1400A8054;
  qword_1400A84E0 = qword_1400A80B8;
  dword_1400A8508 = dword_1400A8058;
  dword_1400A850C = dword_1400A805C;
  qword_1400A84E8 = qword_1400A80C0;
  dword_1400A8510 = dword_1400A8060;
  dword_1400A8514 = dword_1400A8064;
  qword_1400A84F0 = qword_1400A80C8;
  dword_1400A8518 = dword_1400A8068;
  dword_1400A851C = dword_1400A806C;
  LOBYTE(word_1400A839C) = byte_1400935A6;
  byte_1400A84CD = byte_1400935A7;
  dword_1400A8398 = dword_1400935C4;
  do
  {
    v10 = String[v9];
    *(&dword_1400A8300 + v9 + 158) = v10;
    ++v9;
  }
  while ( v10 );
  v48[0] = 0;
  v11 = &byte_14009DCC0;
  v12 = v48;
  for ( i = 0; i < 5; ++i )
  {
    if ( !*(_BYTE *)v11 )
      break;
    v14 = (char *)&byte_14009DCC0 + 257 * i;
    v15 = v12 - (BYTE *)v14;
    do
    {
      v16 = *v14;
      v14[v15] = *v14;
      ++v14;
    }
    while ( v16 );
    v17 = -1i64;
    do
      ++v17;
    while ( v12[v17] );
    v12 += v17 + 1;
    v11 = (LPARAM *)((char *)v11 + 257);
  }
  *v12 = 0;
  v18 = qword_1400A6680;
  v50[0] = 0;
  v19 = v50;
  for ( j = 0; j < 5; ++j )
  {
    if ( !*(_BYTE *)v18 )
      break;
    v21 = &qword_1400A6680[32 * (__int64)j];
    v22 = v19 - (BYTE *)v21;
    do
    {
      v23 = *(_BYTE *)v21;
      *((_BYTE *)v21 + v22) = *(_BYTE *)v21;
      v21 = (LPARAM *)((char *)v21 + 1);
    }
    while ( v23 );
    v24 = -1i64;
    do
      ++v24;
    while ( v19[v24] );
    v19 += v24 + 1;
    v18 += 32;
  }
  *v19 = 0;
  v25 = qword_1400A6180;
  v51[0] = 0;
  v26 = v51;
  for ( k = 0; k < 5; ++k )
  {
    if ( !*(_BYTE *)v25 )
      break;
    v28 = &qword_1400A6180[32 * (__int64)k];
    v29 = v26 - (BYTE *)v28;
    do
    {
      v30 = *(_BYTE *)v28;
      *((_BYTE *)v28 + v29) = *(_BYTE *)v28;
      v28 = (LPARAM *)((char *)v28 + 1);
    }
    while ( v30 );
    v31 = -1i64;
    do
      ++v31;
    while ( v26[v31] );
    v26 += v31 + 1;
    v25 += 32;
  }
  *v26 = 0;
  v32 = String1;
  v52[0] = 0;
  v33 = v52;
  do
  {
    if ( !*(_BYTE *)v32 )
      break;
    v34 = &String1[32 * (__int64)v5];
    v35 = v33 - (BYTE *)v34;
    do
    {
      v36 = *(_BYTE *)v34;
      *((_BYTE *)v34 + v35) = *(_BYTE *)v34;
      v34 = (LPARAM *)((char *)v34 + 1);
    }
    while ( v36 );
    v37 = -1i64;
    do
      ++v37;
    while ( v33[v37] );
    ++v5;
    v33 += v37 + 1;
    v32 += 32;
  }
  while ( v5 < 5 );
  *v33 = 0;
  v38 = v53;
  v53[0] = 0;
  v39 = &byte_1400A4880;
  v40 = 20i64;
  do
  {
    v41 = v39;
    do
    {
      v42 = *(_BYTE *)v41;
      *((_BYTE *)v41 + v38 - (BYTE *)v39) = *(_BYTE *)v41;
      v41 = (LPARAM *)((char *)v41 + 1);
    }
    while ( v42 );
    v43 = -1i64;
    do
      ++v43;
    while ( v38[v43] );
    v39 += 32;
    v38 += v43 + 1;
    --v40;
  }
  while ( v40 );
  *v38 = 0;
  if ( a2 )
  {
    RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Sysinternals\\DbgView", &hKey);
    RegSetValueExA(hKey, "Settings", 0, 3u, &dword_1400A8300, 0x224u);
    RegSetValueExA(hKey, "Recent", 0, 3u, v48, (_DWORD)v12 - (v44 + 80) + 1);
    RegSetValueExA(hKey, "InFilters", 0, 3u, v50, (_DWORD)v19 - ((unsigned int)v49 + 1120) + 1);
    RegSetValueExA(hKey, "ExFilters", 0, 3u, v51, (_DWORD)v26 - ((unsigned int)v49 + 2416) + 1);
    RegSetValueExA(hKey, "HiFilters", 0, 3u, v52, (_DWORD)v33 - ((unsigned int)v49 + 3712) + 1);
    RegSetValueExA(hKey, "HiCurFilters", 0, 3u, v53, (_DWORD)v38 - ((unsigned int)v49 + 5008) + 1);
    LODWORD(v43) = CloseHandle(hKey);
  }
  return v43;
}
// 140009B0A: variable 'v44' is possibly undefined
// 1400921B0: using guessed type char byte_1400921B0;
// 1400921B3: using guessed type char byte_1400921B3;
// 1400921C8: using guessed type char byte_1400921C8;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400921CB: using guessed type char byte_1400921CB;
// 1400921CC: using guessed type char byte_1400921CC;
// 1400921CD: using guessed type char byte_1400921CD;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935A3: using guessed type char byte_1400935A3;
// 1400935A4: using guessed type char byte_1400935A4;
// 1400935A5: using guessed type char byte_1400935A5;
// 1400935A6: using guessed type char byte_1400935A6;
// 1400935A7: using guessed type char byte_1400935A7;
// 1400935B4: using guessed type int dword_1400935B4;
// 1400935C4: using guessed type int dword_1400935C4;
// 14009E4C4: using guessed type char byte_14009E4C4;
// 14009E4C5: using guessed type char byte_14009E4C5;
// 1400A5C80: using guessed type LPARAM String1[160];
// 1400A6180: using guessed type LPARAM qword_1400A6180[160];
// 1400A6680: using guessed type LPARAM qword_1400A6680[160];
// 1400A8020: using guessed type int dword_1400A8020;
// 1400A8024: using guessed type int dword_1400A8024;
// 1400A8028: using guessed type int dword_1400A8028;
// 1400A802C: using guessed type int dword_1400A802C;
// 1400A8030: using guessed type int dword_1400A8030;
// 1400A8034: using guessed type int dword_1400A8034;
// 1400A8038: using guessed type int dword_1400A8038;
// 1400A803C: using guessed type int dword_1400A803C;
// 1400A8040: using guessed type int dword_1400A8040;
// 1400A8044: using guessed type int dword_1400A8044;
// 1400A8048: using guessed type int dword_1400A8048;
// 1400A804C: using guessed type int dword_1400A804C;
// 1400A8050: using guessed type int dword_1400A8050;
// 1400A8054: using guessed type int dword_1400A8054;
// 1400A8058: using guessed type int dword_1400A8058;
// 1400A805C: using guessed type int dword_1400A805C;
// 1400A8060: using guessed type int dword_1400A8060;
// 1400A8064: using guessed type int dword_1400A8064;
// 1400A8068: using guessed type int dword_1400A8068;
// 1400A806C: using guessed type int dword_1400A806C;
// 1400A8080: using guessed type int dword_1400A8080;
// 1400A8084: using guessed type int dword_1400A8084;
// 1400A8088: using guessed type int dword_1400A8088;
// 1400A808C: using guessed type int dword_1400A808C;
// 1400A8090: using guessed type int dword_1400A8090;
// 1400A8094: using guessed type __int64 qword_1400A8094;
// 1400A809C: using guessed type __int64 qword_1400A809C;
// 1400A80A4: using guessed type int dword_1400A80A4;
// 1400A80A8: using guessed type int dword_1400A80A8;
// 1400A80AC: using guessed type int dword_1400A80AC;
// 1400A80B0: using guessed type int dword_1400A80B0;
// 1400A80B4: using guessed type int dword_1400A80B4;
// 1400A80B8: using guessed type __int64 qword_1400A80B8;
// 1400A80C0: using guessed type __int64 qword_1400A80C0;
// 1400A80C8: using guessed type __int64 qword_1400A80C8;
// 1400A8314: using guessed type int dword_1400A8314;
// 1400A831C: using guessed type __int64 qword_1400A831C;
// 1400A8324: using guessed type __int16 word_1400A8324;
// 1400A8326: using guessed type char byte_1400A8326;
// 1400A8327: using guessed type char byte_1400A8327;
// 1400A8328: using guessed type char byte_1400A8328;
// 1400A8329: using guessed type char byte_1400A8329;
// 1400A8368: using guessed type int dword_1400A8368;
// 1400A836C: using guessed type int dword_1400A836C;
// 1400A8370: using guessed type int dword_1400A8370;
// 1400A8374: using guessed type int dword_1400A8374;
// 1400A8378: using guessed type int dword_1400A8378;
// 1400A837C: using guessed type int dword_1400A837C;
// 1400A8380: using guessed type int dword_1400A8380;
// 1400A8384: using guessed type int dword_1400A8384;
// 1400A8388: using guessed type int dword_1400A8388;
// 1400A838C: using guessed type int dword_1400A838C;
// 1400A8390: using guessed type int dword_1400A8390;
// 1400A8394: using guessed type char byte_1400A8394;
// 1400A8398: using guessed type int dword_1400A8398;
// 1400A839C: using guessed type __int16 word_1400A839C;
// 1400A84A2: using guessed type char byte_1400A84A2;
// 1400A84A4: using guessed type __int64 qword_1400A84A4;
// 1400A84AC: using guessed type __int64 qword_1400A84AC;
// 1400A84B4: using guessed type int dword_1400A84B4;
// 1400A84B8: using guessed type int dword_1400A84B8;
// 1400A84BC: using guessed type int dword_1400A84BC;
// 1400A84C0: using guessed type int dword_1400A84C0;
// 1400A84C4: using guessed type int dword_1400A84C4;
// 1400A84C8: using guessed type int dword_1400A84C8;
// 1400A84CC: using guessed type char byte_1400A84CC;
// 1400A84CD: using guessed type char byte_1400A84CD;
// 1400A84D0: using guessed type int dword_1400A84D0;
// 1400A84D4: using guessed type int dword_1400A84D4;
// 1400A84D8: using guessed type int dword_1400A84D8;
// 1400A84DC: using guessed type int dword_1400A84DC;
// 1400A84E0: using guessed type __int64 qword_1400A84E0;
// 1400A84E8: using guessed type __int64 qword_1400A84E8;
// 1400A84F0: using guessed type __int64 qword_1400A84F0;
// 1400A84F8: using guessed type int dword_1400A84F8;
// 1400A84FC: using guessed type int dword_1400A84FC;
// 1400A8500: using guessed type int dword_1400A8500;
// 1400A8504: using guessed type int dword_1400A8504;
// 1400A8508: using guessed type int dword_1400A8508;
// 1400A850C: using guessed type int dword_1400A850C;
// 1400A8510: using guessed type int dword_1400A8510;
// 1400A8514: using guessed type int dword_1400A8514;
// 1400A8518: using guessed type int dword_1400A8518;
// 1400A851C: using guessed type int dword_1400A851C;
// 1400A8520: using guessed type char byte_1400A8520;

//----- (0000000140009C50) ----------------------------------------------------
INT_PTR __fastcall sub_140009C50(HWND a1, int a2, __int16 a3, const CHAR *a4)
{
  HWND v5; // rbx
  int v6; // edx
  int v7; // edx
  HWND v8; // rax
  __int64 v9; // rax
  INT_PTR v10; // rdx
  HWND DlgItem; // rax
  LPARAM *v13; // rbx
  __int64 v14; // rsi
  LPARAM *v15; // rdi

  v5 = a1;
  v6 = a2 - 16;
  if ( !v6 )
  {
LABEL_20:
    v10 = 0i64;
    goto LABEL_21;
  }
  v7 = v6 - 256;
  if ( !v7 )
  {
    DlgItem = GetDlgItem(a1, 1008);
    lpString = a4;
    qword_140094790 = DlgItem;
    SendMessageA(DlgItem, 0x14Bu, 0i64, 0i64);
    v13 = &byte_14009DCC0;
    v14 = 5i64;
    v15 = &byte_14009DCC0;
    do
    {
      if ( *(_BYTE *)v13 )
        SendMessageA(qword_140094790, 0x143u, 0i64, (LPARAM)v15);
      v15 = (LPARAM *)((char *)v15 + 257);
      v13 = (LPARAM *)((char *)v13 + 257);
      --v14;
    }
    while ( v14 );
    SendMessageA(qword_140094790, 0x14Eu, 0i64, 0i64);
    SetFocus(qword_140094790);
    return 1i64;
  }
  if ( v7 != 1 )
    return 0i64;
  if ( a3 != 1 )
  {
    if ( a3 != 2 )
    {
      if ( a3 == 1009 )
      {
        if ( sub_140003540(a1, (char *)lpString) )
          SetDlgItemTextA(v5, 1008, lpString);
        SendDlgItemMessageA(v5, 1009, 0xF4u, 0i64, 1i64);
        SendMessageA(v5, 0x401u, 1ui64, 0i64);
        SendDlgItemMessageA(v5, 1, 0xF4u, 1ui64, 1i64);
        v8 = GetDlgItem(v5, 1);
        SetFocus(v8);
        return 1i64;
      }
      return 0i64;
    }
    goto LABEL_20;
  }
  GetDlgItemTextA(a1, 1008, (LPSTR)lpString, 256);
  v9 = -1i64;
  do
    ++v9;
  while ( lpString[v9] );
  if ( !v9 )
    return 1i64;
  v10 = 1i64;
  a1 = v5;
LABEL_21:
  EndDialog(a1, v10);
  return 1i64;
}

//----- (0000000140009E50) ----------------------------------------------------
BOOL __fastcall sub_140009E50(HWND hWnd, unsigned int a2)
{
  const char *v3; // r8
  const char *v4; // rax
  __int64 v5; // rbx
  char *v6; // rax
  __int64 v9; // [rsp+0h] [rbp-158h] BYREF
  const char *v10; // [rsp+20h] [rbp-138h]
  CHAR String[272]; // [rsp+30h] [rbp-128h] BYREF

  if ( a2 || byte_1400921B1 )
  {
    v3 = "Low Memory Disable - ";
    v4 = (const char *)&WindowName;
    v5 = 384i64 * a2;
    if ( !a2 )
      v4 = " (local)";
    v10 = v4;
    if ( byte_1400921CE )
      v3 = (const char *)&WindowName;
    sub_140002490(String, "%sDebugView on \\\\%s%s", v3, (char *)&unk_1400A2640 + v5 + 16, v10);
    if ( *((_BYTE *)&unk_1400A2640 + v5 + 1) )
    {
      v6 = (char *)&v9 + 47;
      while ( *++v6 != 0 )
        ;
      strcpy(v6, " - Not Connected");
    }
  }
  else
  {
    sub_140002490(String, "DebugView - Not Connected");
  }
  return SetWindowTextA(hWnd, String);
}
// 1400921B1: using guessed type char byte_1400921B1;
// 1400921CE: using guessed type char byte_1400921CE;

//----- (0000000140009F60) ----------------------------------------------------
HBITMAP __fastcall sub_140009F60(HWND a1, void *a2)
{
  HDC DC; // r13
  HDC CompatibleDC; // r12
  HDC hdcSrc; // r15
  LONG v6; // eax
  int v7; // ebp
  int hDest; // esi
  HBITMAP CompatibleBitmap; // r14
  HGDIOBJ v10; // rdi
  HGDIOBJ v11; // rbx

  DC = GetDC(a1);
  CompatibleDC = CreateCompatibleDC(DC);
  hdcSrc = CreateCompatibleDC(DC);
  v6 = GetMenuCheckMarkDimensions();
  v7 = (unsigned __int16)v6;
  hDest = HIWORD(v6);
  CompatibleBitmap = CreateCompatibleBitmap(DC, (unsigned __int16)v6, HIWORD(v6));
  v10 = SelectObject(CompatibleDC, CompatibleBitmap);
  v11 = SelectObject(hdcSrc, a2);
  StretchBlt(CompatibleDC, 0, 0, v7, hDest, hdcSrc, 0, 0, 13, 13, 0xCC0020u);
  SelectObject(CompatibleDC, v10);
  SelectObject(hdcSrc, v11);
  DeleteDC(CompatibleDC);
  DeleteDC(hdcSrc);
  ReleaseDC(a1, DC);
  return CompatibleBitmap;
}

//----- (000000014000A080) ----------------------------------------------------
int __fastcall sub_14000A080(HWND hWnd)
{
  int result; // eax
  const CHAR *v3; // rcx
  char *v4; // rax
  char *v5; // rax
  CHAR FileName[272]; // [rsp+20h] [rbp-348h] BYREF
  char Format[272]; // [rsp+130h] [rbp-238h] BYREF
  CHAR Buffer[272]; // [rsp+240h] [rbp-128h] BYREF

  result = sub_14000D0D0("DBGV", (char **)&hDevice);
  if ( !result )
  {
    GetCurrentDirectoryA(0x104u, Buffer);
    sub_140002490(FileName, "%s\\%s", Buffer, "Dbgv.sys");
    if ( sub_14000CD70("DBGV", FileName, (char **)&hDevice) )
      return DeleteFileA(FileName);
    GetSystemDirectoryA(Buffer, 0x104u);
    sub_140002490(FileName, "%s\\Drivers\\%s", Buffer, "Dbgv.sys");
    if ( qword_1400935B8 )
      qword_1400935B8(0i64);
    v3 = "RCDBGSYS";
    if ( dword_1400A3868 )
      v3 = "RCDBGSYS64";
    if ( sub_14000CCC0(v3, FileName) )
    {
      if ( sub_14000CD70("DBGV", FileName, (char **)&hDevice) )
        goto LABEL_22;
      if ( GetLastError() == 1168 )
      {
        sub_140002490(Format, "File Not Found");
      }
      else if ( GetLastError() == 5 || GetLastError() == 3 )
      {
        sub_140002490(
          Format,
          "Cannot connect to local system because it is already\nconnected to another instance of DebugView.");
      }
      else if ( GetLastError() == 1392 )
      {
        sub_140002490(
          Format,
          "This version of DebugView will not capture kernel debug output for this version of Windows.\n"
          "Check the Sysinternals site for updates.");
      }
      else
      {
        v5 = sub_1400053E0(TimeStr);
        sub_140002490(
          Format,
          "Error loading DebugView driver%s\n"
          "Make sure that you have the Load Drivers and Debug privileges in order to \n"
          "monitor kernel-mode debug prints.",
          v5);
      }
      sub_140002490(TimeStr, Format);
    }
    else
    {
      if ( qword_1400935B8 )
        qword_1400935B8(1i64);
      v4 = sub_1400053E0(Format);
      sub_140002490(
        TimeStr,
        "Could not extract DebugView driver to %s%s\nKernel debug output capture will be unavailable.",
        FileName,
        v4);
    }
    MessageBoxA(hWnd, TimeStr, "DebugView", 0x10u);
LABEL_22:
    if ( qword_1400935B8 )
      qword_1400935B8(1i64);
    return DeleteFileA(FileName);
  }
  return result;
}
// 1400935B8: using guessed type __int64 (__fastcall *qword_1400935B8)(_QWORD);
// 1400A3868: using guessed type int dword_1400A3868;

//----- (000000014000A2C0) ----------------------------------------------------
HWND __fastcall sub_14000A2C0(HWND hWnd, unsigned int a2)
{
  int v2; // ebx
  __int64 v4; // rdi
  HMENU SubMenu; // rax
  HMENU v6; // rax
  HWND *v7; // rbx
  HWND v8; // rax
  UINT v9; // ebx
  HMENU Menu; // rax
  UINT v11; // r8d

  v2 = ArgList;
  v4 = a2;
  SubMenu = GetSubMenu(hMenu, 4);
  CheckMenuItem(SubMenu, v2 + 50000, 0);
  v6 = GetSubMenu(hMenu, 4);
  CheckMenuItem(v6, v4 + 50000, 8u);
  ShowWindow(*((HWND *)&unk_1400A2640 + 48 * (unsigned int)ArgList + 1), 0);
  v7 = (HWND *)((char *)&unk_1400A2640 + 384 * v4);
  ShowWindow(v7[1], 5);
  sub_140002F30(hWnd, ArgList, v4);
  sub_140009E50(hWnd, v4);
  v8 = v7[1];
  v9 = 1;
  qword_1400A37F8 = v8;
  LODWORD(ArgList) = v4;
  if ( (_DWORD)v4 || byte_1400921B1 )
  {
    Menu = GetMenu(hWnd);
    v11 = 0;
  }
  else
  {
    Menu = GetMenu(hWnd);
    v11 = 1;
  }
  EnableMenuItem(Menu, 0x9C63u, v11);
  if ( !(_DWORD)ArgList && byte_1400921B1 )
    v9 = 0;
  EnableMenuItem(hMenu, 0x9C78u, v9);
  return SetFocus(qword_1400A37F8);
}
// 1400921B1: using guessed type char byte_1400921B1;

//----- (000000014000A410) ----------------------------------------------------
BOOL __fastcall sub_14000A410(HWND a1, UINT a2, HICON a3, const CHAR *a4)
{
  struct _NOTIFYICONDATAA Data; // [rsp+20h] [rbp-248h] BYREF

  sub_140016650((__int64)&Data, 0, 0x208ui64);
  Data.cbSize = 520;
  Data.hWnd = a1;
  Data.uID = a2;
  Data.uFlags = 7;
  Data.uCallbackMessage = 1037;
  Data.hIcon = a3;
  if ( a4 )
    lstrcpynA(Data.szTip, a4, 128);
  else
    Data.szTip[0] = 0;
  return Shell_NotifyIconA(0, &Data);
}

//----- (000000014000A4C0) ----------------------------------------------------
BOOL __fastcall sub_14000A4C0(HWND a1, UINT a2)
{
  struct _NOTIFYICONDATAA Data; // [rsp+20h] [rbp-228h] BYREF

  sub_140016650((__int64)&Data, 0, 0x208ui64);
  Data.cbSize = 520;
  Data.hWnd = a1;
  Data.uID = a2;
  return Shell_NotifyIconA(2u, &Data);
}

//----- (000000014000A540) ----------------------------------------------------
BOOL __fastcall sub_14000A540(HWND a1, UINT a2, HICON a3)
{
  struct _NOTIFYICONDATAA Data; // [rsp+20h] [rbp-238h] BYREF

  sub_140016650((__int64)&Data, 0, 0x208ui64);
  Data.cbSize = 520;
  Data.hWnd = a1;
  Data.uID = a2;
  Data.uFlags = 2;
  Data.hIcon = a3;
  return Shell_NotifyIconA(1u, &Data);
}

//----- (000000014000A5C0) ----------------------------------------------------
BOOL __fastcall DBGView_CloseListener(unsigned __int8 a1)
{
  unsigned __int64 v1; // rbx
  BOOL result; // eax

  v1 = 8i64 * a1;
  UnmapViewOfFile((LPCVOID)qword_1400A3660[v1 / 8]);
  CloseHandle(*(HANDLE *)((char *)&qword_1400A3680 + v1));
  CloseHandle(*(HANDLE *)((char *)&qword_1400A3690 + v1));
  CloseHandle(*(HANDLE *)((char *)&unk_1400A36A0 + v1));
  result = CloseHandle(*(HANDLE *)&algn_1400A3668[v1 + 8]);
  *(HANDLE *)((char *)&qword_1400A3680 + v1) = (HANDLE)-1i64;
  return result;
}
// 1400A3660: using guessed type __int64 qword_1400A3660[];

//----- (000000014000A640) ----------------------------------------------------
void __fastcall sub_14000A640(HWND hWnd, unsigned __int64 a2, unsigned int a3, int a4)
{
  int v4; // r14d
  int v5; // ebx
  HWND *v8; // rax
  __int64 v9; // rsi
  unsigned __int64 v10; // rbp
  __int64 v11; // r12
  __int64 v12; // r13
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rbx
  unsigned int v17; // ebx
  _QWORD *v18; // rbx
  int v19; // eax
  void *v20; // rcx
  int v21; // eax

  v4 = 0;
  v5 = a4;
  if ( a4 || a3 >= 6 || byte_1400935AC )
  {
    v8 = &qword_1400A2648;
    v9 = 0i64;
    do
    {
      if ( *v8 == hWnd )
        break;
      v9 = (unsigned int)(v9 + 1);
      v8 += 48;
    }
    while ( (unsigned int)v9 < 0xA );
    if ( a2 )
    {
      v10 = a2;
      v11 = 384 * v9;
      v12 = a3;
      v13 = a2 + a3;
      qword_1400A36B8 = *((_QWORD *)&unk_1400A2640 + 48 * v9 + 37);
      v14 = a2 + 4080;
      while ( 1 )
      {
        v15 = 4080i64;
        if ( v13 < v14 )
          v15 = v12;
        if ( v10 >= a2 + v15 )
          break;
        v16 = -1i64;
        do
          ++v16;
        while ( *(_BYTE *)(v10 + 20 + v16) );
        v17 = (v16 + 4) & 0xFFFFFFFC;
        if ( v17 > 0x101F )
        {
          *(_BYTE *)(v10 + 4147) = 0;
          v17 = 4127;
        }
        v4 |= sub_140010B40(
                hWnd,
                v9,
                *(_DWORD *)v10 + *(_DWORD *)((char *)&unk_1400A2640 + v11 + 312),
                *(FILETIME *)(v10 + 4),
                *(_QWORD *)(v10 + 12),
                (char *)(v10 + 20));
        v13 = a2 + v12;
        v14 = a2 + 4080;
        v10 += v17 + 20i64;
      }
      if ( qword_1400A2648 == hWnd )
      {
        v18 = Block;
        if ( Block )
        {
          do
          {
            v19 = sub_140010B40(
                    hWnd,
                    v9,
                    *(_DWORD *)((char *)&unk_1400A2640 + v11 + 312) + *((_DWORD *)v18 + 2),
                    (FILETIME)v18[2],
                    v18[3],
                    (char *)v18 + 32);
            v20 = v18;
            Block = v18;
            v18 = (_QWORD *)*v18;
            v4 |= v19;
            j__free_base(v20);
          }
          while ( v18 );
        }
        Block = 0i64;
        qword_1400A3648 = 0i64;
        byte_1400935AC = 0;
      }
      if ( dword_1400935B4 && v4 )
      {
        SendMessageA(hWnd, 0xBu, 0i64, 0i64);
        for ( ; dword_1400935C0 >= (unsigned int)dword_1400935B4; --dword_1400935C0 )
          SendMessageA(hWnd, 0x1008u, 0i64, 0i64);
        SendMessageA(hWnd, 0xBu, 1ui64, 0i64);
      }
      if ( byte_1400921B3 )
      {
        if ( v4 )
        {
          if ( *((HWND *)&unk_1400A2640 + 48 * (unsigned int)ArgList + 1) == hWnd && qword_1400935C8 )
            ShowWindow(qword_1400935C8, 0);
          v21 = SendMessageA(hWnd, 0x1004u, 0i64, 0i64);
          SendMessageA(hWnd, 0x1013u, v21 - 1, 0i64);
        }
        v5 = a4;
      }
      else
      {
        v5 = a4;
      }
    }
    if ( v5 )
    {
      SendMessageA(hWnd, 0x1009u, 0i64, 0i64);
      dword_1400935C0 = 0;
      *((_BYTE *)&unk_1400A2640 + 384 * v9 + 316) = 1;
    }
  }
}
// 1400921B3: using guessed type char byte_1400921B3;
// 1400935AC: using guessed type char byte_1400935AC;
// 1400935B4: using guessed type int dword_1400935B4;
// 1400935C0: using guessed type int dword_1400935C0;
// 1400A3648: using guessed type __int64 qword_1400A3648;
// 1400A36B8: using guessed type __int64 qword_1400A36B8;

//----- (000000014000A930) ----------------------------------------------------
char sub_14000A930()
{
  MessageBoxA(
    0i64,
    "You can direct DebugView to run as an agent that sends output to a\n"
    "viewer running on another computer with the following command-line syntax:\n"
    "\n"
    "Agent usage: dbgview [/a [/t] [/s] [/g] [/e] [/k] [/v]]\n"
    "\n"
    "   /a\tStart in agent mode\n"
    "   /t\tStart minimized in the tray\n"
    "   /g\tCapture global Win32 output\n"
    "   /s\tAgent silent mode - no window is displayed\n"
    "   /e\tAgent notifies you when connection to server is broken\n"
    "   /k\tCapture kernel output\n"
    "   /v\tEnable verbose kernel output\n"
    "\n"
    "The following command-line syntax starts DebugView in viewer mode:\n"
    "\n"
    "Viewer usage: dbgview [/t] [/f] [/k[n]] [/o[m|n]] [/v[n]] [/l Logfile [/a] [[/m nnn [/w]] ] | [/n [/x]]] [/h nnn] [/"
    "q] [LogFile]\n"
    "\n"
    "   /t\tStart minimized in the tray\n"
    "   /f\tNo filter prompt\n"
    "   /o\tUse clock time (/o), clock time with ms (/om), or elapsed time (/on)\n"
    "   /l\tLog output to the specified file\n"
    "   /g\tEnable global Win32 capture (/g) or disable global Win32 capture (/gn)\n"
    "   /k\tEnable kernel capture (/k) or disable kernel capture (/kn)\n"
    "   /m\tLimit log file to size (in MB)\n"
    "   /p\tAppend output to log file if it exists\n"
    "   /w\tWrap to the start when the log file reaches max\n"
    "   /n\tCreate a new log file every day\n"
    "   /x\tClear display on new log file\n"
    "   /h\tSet history depth to specified size\n"
    "   /q\tTerminate running instance of Dbgview on the same desktop\n"
    "   /v\tEnable verbose kernel capture with /v and disable with /vn (XP and higher)\n"
    "   Specify a log file to load it.\n",
    "DebugView",
    0x40u);
  return 0;
}

//----- (000000014000A960) ----------------------------------------------------
int __fastcall sub_14000A960(unsigned __int8 a1)
{
  int result; // eax
  __int64 v2; // rbx
  void **v3; // rbp
  void *v4; // rcx
  unsigned int **v5; // r15
  __int64 v6; // rdi
  __int64 v7; // rbx
  char *v8; // rax
  char *v9; // r14
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx
  char *v14; // rcx
  char v15; // al
  char *v16; // rcx
  bool v17; // zf
  __int64 v18; // rdx
  char v19; // al
  unsigned __int64 v20; // rcx
  char v21; // al
  char *v22; // rsi
  __int64 v23; // rcx
  char v24; // al
  struct _FILETIME FileTime; // [rsp+20h] [rbp-10C8h] BYREF
  struct _FILETIME v26; // [rsp+28h] [rbp-10C0h]
  LARGE_INTEGER PerformanceCount; // [rsp+30h] [rbp-10B8h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+38h] [rbp-10B0h] BYREF
  char Buffer[4127]; // [rsp+50h] [rbp-1098h] BYREF
  char v30; // [rsp+106Fh] [rbp-79h]

  result = a1;
  v2 = a1;
  v3 = (HANDLE *)((char *)&qword_1400A3690 + v2 * 8);
  v4 = *(HANDLE *)((char *)&qword_1400A3690 + v2 * 8);
  if ( v4 != (void *)-1i64 )
  {
    if ( byte_1400A2770 )
    {
      GetSystemTime(&SystemTime);
      SystemTimeToFileTime(&SystemTime, &FileTime);
      v26 = FileTime;
      QueryPerformanceCounter(&PerformanceCount);
      v5 = (unsigned int **)&qword_1400A3660[v2];
      v6 = qword_1400A3660[v2] + 4;
      if ( qword_1400A3660[v2] != -4 )
      {
        v7 = (__int64)v26;
        while ( *(_BYTE *)v6 )
        {
          v8 = strstr((const char *)v6, "\n");
          v9 = v8;
          if ( v8 )
          {
            *v8 = 0;
          }
          else if ( !byte_1400921B0 )
          {
            v10 = -1i64;
            do
              ++v10;
            while ( *(_BYTE *)(v6 + v10) );
            if ( (unsigned int)v10 > 0x1020 )
            {
              LODWORD(v10) = 4128;
              *(_BYTE *)(v6 + 4128) = 0;
            }
            v11 = -1i64;
            do
              ++v11;
            while ( byte_140093620[v11] );
            if ( (unsigned int)(v11 + v10 + 1) <= 0x1020 )
            {
              v22 = &byte_140093620[-1];
              do
                v17 = *++v22 == 0;
              while ( !v17 );
              v23 = 0i64;
              do
              {
                v24 = *(_BYTE *)(v6 + v23);
                v22[v23++] = v24;
              }
              while ( v24 );
              break;
            }
            v9 = (char *)(v6 + (unsigned int)(4127 - v11));
            *v9 = 0;
          }
          v12 = -1i64;
          do
            ++v12;
          while ( *(_BYTE *)(v6 + v12) );
          v13 = -1i64;
          do
            ++v13;
          while ( byte_140093620[v13] );
          if ( (unsigned int)(v13 + v12 + 1) <= 0x1020 )
          {
            v16 = &byte_140093620[-1];
            do
              v17 = *++v16 == 0;
            while ( !v17 );
            v18 = 0i64;
            do
            {
              v19 = *(_BYTE *)(v6 + v18);
              v16[v18++] = v19;
            }
            while ( v19 );
          }
          else
          {
            sub_140002490(Buffer, (char *)&byte_14007B310, **v5, byte_140093620);
            sub_14000AC40(Buffer, v7, PerformanceCount.QuadPart);
            v14 = &byte_140093620[-v6];
            do
            {
              v15 = *(_BYTE *)v6;
              v14[v6] = *(_BYTE *)v6;
              ++v6;
            }
            while ( v15 );
          }
          sub_140002490(Buffer, (char *)&byte_14007B310, **v5, byte_140093620);
          byte_140093620[0] = 0;
          v20 = -1i64;
          do
            ++v20;
          while ( Buffer[v20] );
          v21 = v30;
          if ( v20 > 0x101F )
            v21 = 0;
          v30 = v21;
          sub_14000AC40(Buffer, v7, PerformanceCount.QuadPart);
          v6 = (__int64)(v9 + 1);
          if ( !v9 )
            v6 = 0i64;
          if ( !v6 )
            break;
        }
      }
      v4 = *v3;
      byte_1400935AC = 1;
    }
    return SetEvent(v4);
  }
  return result;
}
// 1400921B0: using guessed type char byte_1400921B0;
// 1400935AC: using guessed type char byte_1400935AC;
// 1400A2770: using guessed type char byte_1400A2770;
// 1400A3660: using guessed type __int64 qword_1400A3660[];
// 14000A960: using guessed type char Buffer[4127];

//----- (000000014000AC40) ----------------------------------------------------
__int64 __fastcall sub_14000AC40(char *a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rcx
  _QWORD *v7; // r8
  signed __int32 v8; // edx
  __int64 v9; // rcx
  char v10; // al
  __int64 result; // rax

  v5 = -1i64;
  do
    ++v5;
  while ( a1[v5] );
  v7 = j__malloc_base(v5 + 33);
  v8 = _InterlockedIncrement((volatile signed __int32 *)qword_1400A36C0);
  v7[2] = a2;
  *((_DWORD *)v7 + 2) = v8;
  v9 = (char *)v7 - a1;
  v7[3] = a3;
  *v7 = 0i64;
  do
  {
    v10 = *a1;
    a1[v9 + 32] = *a1;
    ++a1;
  }
  while ( v10 );
  result = qword_1400A3648;
  if ( qword_1400A3648 )
    *(_QWORD *)qword_1400A3648 = v7;
  else
    Block = v7;
  qword_1400A3648 = (__int64)v7;
  return result;
}
// 1400A3648: using guessed type __int64 qword_1400A3648;
// 1400A36C0: using guessed type __int64 qword_1400A36C0;

//----- (000000014000ACE0) ----------------------------------------------------
int __stdcall DBGVIEW_WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  char v7; // si
  unsigned __int8 Version; // cl
  char v10; // al
  int v11; // eax
  char v12; // cl
  __int64 v13; // rdi
  __int64 v14; // rcx
  LPSTR CommandLineA; // rbx
  CHAR v16; // al
  HMODULE ModuleHandleA; // rax
  char *v18; // rax
  HMODULE v19; // rax
  FARPROC ProcAddress; // rbx
  DWORD CurrentProcessId; // eax
  char v22; // al
  HWND v23; // rax
  HWND v24; // rdi
  HACCEL AcceleratorsA; // rsi
  DWORD nHandles; // ebx
  __int64 v27; // rcx
  DWORD v28; // eax
  DWORD nSize; // [rsp+30h] [rbp-D0h] BYREF
  int v30; // [rsp+34h] [rbp-CCh] BYREF
  HANDLE pHandles[2]; // [rsp+38h] [rbp-C8h] BYREF
  LPSTR FilePart; // [rsp+48h] [rbp-B8h] BYREF
  struct tagMSG Msg; // [rsp+50h] [rbp-B0h] BYREF
  CHAR Filename[272]; // [rsp+80h] [rbp-80h] BYREF
  char v35[272]; // [rsp+190h] [rbp+90h] BYREF

  v7 = 0;
  Version = GetVersion();
  if ( Version < 5u )
  {
    MessageBoxA(0i64, "DebugView requires Windows XP or higher", "DebugView", 0x10u);
    return 0;
  }
  v10 = byte_14009E1E0;
  if ( Version >= 6u )
    v10 = 1;
  byte_14009E1E1 = 1;
  byte_14009E1E0 = v10;
  v11 = sub_14000CBE0("SeDebugPrivilege");
  v12 = byte_1400921CA;
  v13 = 0i64;
  if ( !v11 )
    v12 = 0;
  byte_1400921CA = v12;
  if ( strstr(lpCmdLine, "/?") )
  {
    sub_14000A930();
    return 0;
  }
  CommandLineA = GetCommandLineA();
  v16 = *CommandLineA;
  if ( *CommandLineA == 34 )
  {
    v16 = *++CommandLineA;
    v7 = 1;
  }
  if ( v16 )
  {
    do
    {
      if ( !v7 && isspace(*CommandLineA) )
        break;
      v14 = (unsigned __int8)*CommandLineA;
      if ( (_BYTE)v14 == 34 )
        break;
      Filename[v13] = v14;
      ++CommandLineA;
      v13 = (unsigned int)(v13 + 1);
    }
    while ( *CommandLineA );
  }
  if ( (unsigned int)v13 >= 0x104 )
    _report_rangecheckfailure(v14);
  Filename[v13] = 0;
  if ( !strchr(Filename, 92) )
    GetModuleFileNameA(0i64, Filename, 0x104u);
  GetFullPathNameA(Filename, 0x104u, byte_1400A36E0, &FilePart);
  if ( FilePart )
    *FilePart = 0;
  dword_1400A3868 = sub_140009410();
  if ( dword_1400A3868 )
  {
    ModuleHandleA = GetModuleHandleA("kernel32.dll");
    qword_1400935B8 = (__int64 (__fastcall *)(_QWORD))GetProcAddress(ModuleHandleA, "Wow64EnableWow64FsRedirection");
  }
  v18 = strstr(lpCmdLine, "/A");
  if ( v18 || (v18 = strstr(lpCmdLine, "/a")) != 0i64 )
  {
    if ( strnicmp(v18 + 1, "accepteula", 0xAui64) )
    {
      sub_14000B4E0(hInstance, lpCmdLine, 5);
      return 0;
    }
  }
  sub_140008730();
  if ( !sub_140008070(lpCmdLine, v35) || !(unsigned int)DBGView_RegisterWndClass(hInstance) )
    return 0;
  if ( FindWindowA("dbgviewClass", 0i64) )
  {
    byte_1400921B1 = 0;
    if ( nWidth )
    {
      Y += 20;
      X += 20;
    }
  }
  nSize = 257;
  GetComputerNameA(&byte_1400A3540, &nSize);
  sub_140016650((__int64)&unk_1400A2640, 0, 0xF00ui64);
  qword_1400A2620 = (__int64)CreateEventA(0i64, 1, 0, 0i64);
  hEvent = CreateEventA(0i64, 0, 0, 0i64);
  v19 = GetModuleHandleA("Kernel32.DLL");
  ProcAddress = GetProcAddress(v19, "ProcessIdToSessionId");
  if ( ProcAddress )
  {
    CurrentProcessId = GetCurrentProcessId();
    if ( ((unsigned int (__fastcall *)(_QWORD, int *))ProcAddress)(CurrentProcessId, &v30) )
    {
      v22 = byte_1400935A0;
      if ( v30 )
        v22 = 1;
      byte_1400935A0 = v22;
    }
  }
  InitCommonControls();
  v23 = DBGView_CreateWnd(hInstance, nShowCmd);
  v24 = v23;
  if ( !v23 )
    return 0;
  if ( v35[0] )
    sub_140012130(v23, 0, qword_1400A2648, v35);
  AcceleratorsA = LoadAcceleratorsA(hInstance, "ACCELERATORS");
  dword_1400A3800 = RegisterWindowMessageA("commdlg_FindReplace");
  while ( 1 )
  {
    while ( !PeekMessageA(&Msg, 0i64, 0, 0, 1u) )
    {
      if ( byte_1400921B1 && (byte_1400A2772 || byte_1400A2773) )
      {
        nHandles = 0;
        if ( byte_1400A2772 )
        {
          nHandles = 1;
          pHandles[0] = qword_1400A3680;
        }
        if ( byte_1400A2773 )
        {
          v27 = nHandles++;
          pHandles[v27] = qword_1400A3688;
        }
        v28 = MsgWaitForMultipleObjects(nHandles, pHandles, 0, 0xFFFFFFFF, 0x4FFu);
        if ( v28 )
        {
          if ( nHandles == 2 && v28 == 1 )
            sub_14000A960(1u);
        }
        else
        {
          sub_14000A960(pHandles[0] != qword_1400A3680);
        }
      }
      else
      {
        MsgWaitForMultipleObjects(0, pHandles, 0, 0xFFFFFFFF, 0x5FFu);
      }
    }
    if ( Msg.message == 18 )
      break;
    if ( !TranslateAcceleratorA(v24, AcceleratorsA, &Msg)
      && (!IsWindow(qword_140093590) || !IsDialogMessageA(qword_140093590, &Msg))
      && (!IsWindow(qword_140093598) || !IsDialogMessageA(qword_140093598, &Msg)) )
    {
      TranslateMessage(&Msg);
      DispatchMessageA(&Msg);
    }
  }
  return 1;
}
// 14000B217: variable 'v14' is possibly undefined
// 14001503C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 1400921B1: using guessed type char byte_1400921B1;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400935A0: using guessed type char byte_1400935A0;
// 1400935B8: using guessed type __int64 (__fastcall *qword_1400935B8)(_QWORD);
// 14009E1E0: using guessed type char byte_14009E1E0;
// 14009E1E1: using guessed type char byte_14009E1E1;
// 1400A2620: using guessed type __int64 qword_1400A2620;
// 1400A2772: using guessed type char byte_1400A2772;
// 1400A2773: using guessed type char byte_1400A2773;
// 1400A3800: using guessed type int dword_1400A3800;
// 1400A3868: using guessed type int dword_1400A3868;
// 14000ACE0: using guessed type CHAR Filename[272];
// 14000ACE0: using guessed type HANDLE pHandles[2];

//----- (000000014000B220) ----------------------------------------------------
BOOL sub_14000B220()
{
  __int64 v0; // rdi
  struct _FILETIME v1; // rbx
  __int64 v2; // rbp
  char *v3; // rax
  char *v4; // r14
  char *v5; // rax
  bool v6; // zf
  unsigned __int64 v7; // rcx
  char v8; // al
  __int64 v9; // rdi
  __int64 v10; // rdx
  unsigned int v11; // edi
  __int64 v12; // rdx
  signed __int32 v13; // ecx
  __int64 v14; // rax
  char *v15; // rsi
  __int64 v16; // rcx
  char v17; // al
  struct _FILETIME FileTime; // [rsp+20h] [rbp-10B8h] BYREF
  struct _FILETIME v20; // [rsp+28h] [rbp-10B0h]
  LARGE_INTEGER PerformanceCount; // [rsp+30h] [rbp-10A8h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+38h] [rbp-10A0h] BYREF
  __m128i Buffer; // [rsp+50h] [rbp-1088h] BYREF
  char v24; // [rsp+106Fh] [rbp-69h]

  GetSystemTime(&SystemTime);
  SystemTimeToFileTime(&SystemTime, &FileTime);
  v20 = FileTime;
  QueryPerformanceCounter(&PerformanceCount);
  v0 = qword_1400A3660[0] + 4;
  if ( qword_1400A3660[0] != -4 )
  {
    v1 = v20;
    v2 = -1i64;
    while ( *(_BYTE *)v0 )
    {
      v3 = strstr((const char *)v0, "\n");
      v4 = v3;
      if ( v3 )
      {
        *v3 = 0;
      }
      else if ( !byte_1400921B0 )
      {
        v14 = -1i64;
        do
          ++v14;
        while ( *(_BYTE *)(v0 + v14) );
        if ( (unsigned int)v14 > 0x1020 )
          *(_BYTE *)(v0 + 4128) = 0;
        do
          ++v2;
        while ( byte_140096940[v2] );
        if ( (unsigned __int64)(unsigned int)v14 + v2 + 1 > 0x1020 )
          *(_BYTE *)(v0 - v2 + 4127) = 0;
        v15 = &byte_140096940[-1];
        do
          v6 = *++v15 == 0;
        while ( !v6 );
        v16 = 0i64;
        do
        {
          v17 = *(_BYTE *)(v0 + v16);
          v15[v16++] = v17;
        }
        while ( v17 );
        break;
      }
      v5 = &byte_140096940[-1];
      do
        v6 = *++v5 == 0;
      while ( !v6 );
      strcpy(v5, (const char *)v0);
      sub_140002490(Buffer.m128i_i8, (char *)&byte_14007B310, *(unsigned int *)qword_1400A3660[0], byte_140096940);
      byte_140096940[0] = 0;
      v7 = -1i64;
      do
        ++v7;
      while ( Buffer.m128i_i8[v7] );
      v8 = v24;
      v9 = -1i64;
      if ( v7 > 0x101F )
        v8 = 0;
      v24 = v8;
      do
        ++v9;
      while ( Buffer.m128i_i8[v9] );
      v10 = qword_140095900;
      v11 = (v9 + 4) & 0xFFFFFFFC;
      if ( (unsigned __int64)(v11 + *(_DWORD *)(qword_140095900 + 16)) + 21 >= 0xFEC )
      {
        sub_14000C190();
        v10 = qword_140095900;
      }
      v12 = *(unsigned int *)(v10 + 16) + v10;
      v13 = _InterlockedIncrement((volatile signed __int32 *)qword_1400A36C0);
      *(struct _FILETIME *)(v12 + 24) = v1;
      *(_DWORD *)(v12 + 20) = v13;
      *(LARGE_INTEGER *)(v12 + 32) = PerformanceCount;
      sub_1400161F0((__m128i *)(v12 + 40), &Buffer, v11);
      *(_DWORD *)(qword_140095900 + 16) += v11 + 20;
      if ( v4 )
      {
        v0 = (__int64)(v4 + 1);
        if ( v4 != (char *)-1i64 )
          continue;
      }
      break;
    }
  }
  byte_1400935AC = 1;
  return SetEvent(qword_1400A3690);
}
// 1400921B0: using guessed type char byte_1400921B0;
// 1400935AC: using guessed type char byte_1400935AC;
// 140095900: using guessed type __int64 qword_140095900;
// 1400A3660: using guessed type __int64 qword_1400A3660[];
// 1400A36C0: using guessed type __int64 qword_1400A36C0;
// 14000B220: using guessed type __m128i Buffer;

//----- (000000014000B4E0) ----------------------------------------------------
__int64 __fastcall sub_14000B4E0(HINSTANCE hInstance, char *Str, int a3)
{
  HCURSOR CursorA; // rax
  HWND DialogParamA; // rax
  struct tagMSG Msg; // [rsp+30h] [rbp-88h] BYREF
  WNDCLASSEXA v10; // [rsp+60h] [rbp-58h] BYREF

  ::hInstance = hInstance;
  if ( strstr(Str, "/s") || strstr(Str, "/S") )
  {
    byte_1400958F0 = 1;
  }
  else if ( strstr(Str, "/e") || strstr(Str, "/E") )
  {
    byte_1400958F1 = 1;
  }
  if ( strstr(Str, "/g") || strstr(Str, "/G") )
    byte_1400935A2 = 1;
  if ( strstr(Str, "/t") || strstr(Str, "/T") )
    byte_1400935A1 = 1;
  if ( strstr(Str, "/k") || strstr(Str, "/K") )
  {
    byte_1400921CA = 1;
    if ( strstr(Str, "/v") || strstr(Str, "/V") )
      byte_1400935A3 = 1;
  }
  else
  {
    byte_1400921CA = 0;
  }
  v10.cbSize = 80;
  v10.lpfnWndProc = (WNDPROC)sub_14000B7B0;
  v10.cbClsExtra = 0;
  v10.style = 3;
  v10.cbWndExtra = 30;
  v10.hInstance = hInstance;
  v10.hIcon = LoadIconA(hInstance, "APPICON");
  v10.hIconSm = LoadIconA(hInstance, "APPICON");
  CursorA = LoadCursorA(0i64, (LPCSTR)0x7F00);
  //*(__m128i *)&v10.hbrBackground = _mm_load_si128((const __m128i *)&xmmword_14007CBE0);
  v10.hbrBackground = (HBRUSH)16;
  v10.hCursor = CursorA;
  v10.lpszClassName = aDbgvclnt;
  RegisterClassExA(&v10);
  DialogParamA = CreateDialogParamA(hInstance, aDbgvclnt, 0i64, (DLGPROC)sub_14000B7B0, 0i64);
  qword_14009DCA8 = DialogParamA;
  if ( byte_1400958F4 )
    return 0xFFFFFFFFi64;
  if ( byte_1400935A1 )
    a3 = 0;
  if ( !byte_1400958F0 )
    ShowWindow(DialogParamA, a3);
  while ( GetMessageA(&Msg, 0i64, 0, 0) )
  {
    if ( !IsDialogMessageA(qword_14009DCA8, &Msg) )
    {
      TranslateMessage(&Msg);
      DispatchMessageA(&Msg);
    }
  }
  return LODWORD(Msg.wParam);
}
// 14007CBE0: using guessed type __int128 xmmword_14007CBE0;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400935A1: using guessed type char byte_1400935A1;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935A3: using guessed type char byte_1400935A3;
// 1400958F0: using guessed type char byte_1400958F0;
// 1400958F1: using guessed type char byte_1400958F1;
// 1400958F4: using guessed type char byte_1400958F4;

//----- (000000014000B7B0) ----------------------------------------------------
INT_PTR __fastcall sub_14000B7B0(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
  HICON IconA; // rbx
  INT_PTR result; // rax
  const CHAR *v10; // rcx
  char *v11; // rax
  const CHAR *v12; // rdx
  DWORD LastError; // eax
  HANDLE v14; // rcx
  u_short v15; // bx
  const CHAR *v16; // rdx
  HICON v17; // rbx
  DWORD BytesReturned; // [rsp+40h] [rbp-C0h] BYREF
  int OutBuffer; // [rsp+44h] [rbp-BCh] BYREF
  DWORD nSize; // [rsp+48h] [rbp-B8h] BYREF
  int namelen; // [rsp+4Ch] [rbp-B4h] BYREF
  struct sockaddr v22; // [rsp+50h] [rbp-B0h] BYREF
  struct WSAData WSAData; // [rsp+60h] [rbp-A0h] BYREF
  char Format[32]; // [rsp+200h] [rbp+100h] BYREF
  CHAR name[16]; // [rsp+220h] [rbp+120h] BYREF
  CHAR FileName[272]; // [rsp+230h] [rbp+130h] BYREF
  CHAR String[272]; // [rsp+340h] [rbp+240h] BYREF
  CHAR Buffer[272]; // [rsp+450h] [rbp+350h] BYREF

  if ( a2 > 0x112 )
  {
    if ( a2 == 275 )
    {
      if ( byte_1400958F3 )
        SetEvent(qword_14009DC98);
    }
    else if ( a2 == 1037 && a4 == 515 )
    {
      ShowWindow(a1, 1);
      SetForegroundWindow(a1);
      sub_14000A4C0(a1, 1u);
    }
    return DefWindowProcA(a1, a2, a3, a4);
  }
  if ( a2 != 274 )
  {
    if ( a2 == 16 )
    {
      if ( !byte_1400958F2
        || MessageBoxA(
             a1,
             "The DebugView agent is currently connected. Are you sure you want to exit?",
             "DebugView",
             0x34u) == 6 )
      {
        TerminateThread(qword_140096938, 0);
        closesocket(s);
        EndDialog(a1, 0i64);
        PostQuitMessage(0);
      }
      return DefWindowProcA(a1, a2, a3, a4);
    }
    if ( a2 != 272 )
    {
      if ( a2 == 273
        && (_WORD)a3 == 1001
        && (!byte_1400958F2
         || MessageBoxA(
              a1,
              "The DebugView agent is currently connected. Are you sure you want to exit?",
              "DebugView",
              0x34u) == 6) )
      {
        TerminateThread(qword_140096938, 0);
        sub_14000A4C0(a1, 1u);
        EndDialog(a1, 0i64);
        PostQuitMessage(0);
      }
      return DefWindowProcA(a1, a2, a3, a4);
    }
    if ( byte_1400935A1 )
    {
      IconA = LoadIconA(hInstance, "APPICONDISABLED");
      GetWindowTextA(a1, String, 4128);
      sub_14000A410(a1, 1u, IconA, String);
    }
    qword_140095900 = (__int64)j__malloc_base(0x1004ui64);
    *(_DWORD *)(qword_140095900 + 16) = 0;
    *(_QWORD *)(qword_140095900 + 8) = 0i64;
    dword_140095908 = 1;
    byte_1400921C9 = 0;
    SetDlgItemTextA(qword_14009DCA8, 1004, "Waiting for connection...");
    if ( byte_1400921CA )
    {
      if ( !GetEnvironmentVariableA("SYSTEMROOT", Buffer, 0x104u) )
      {
        strcpy(xmmword_140095910, "Could not resolve SYSTEMROOT environment variable");
        MessageBoxA(a1, xmmword_140095910, "DebugView", 0x10u);
        return 0i64;
      }
      sub_140002490(FileName, "%s\\System32\\Drivers\\%s", Buffer, "Dbgv.sys");
      if ( qword_1400935B8 )
        qword_1400935B8(0i64);
      v10 = "RCDBGSYS";
      if ( dword_1400A3868 )
        v10 = "RCDBGSYS64";
      if ( !sub_14000CCC0(v10, FileName) )
      {
        if ( qword_1400935B8 )
          qword_1400935B8(1i64);
        v11 = sub_1400053E0(Format);
        sub_140002490(xmmword_140095910, "Could not extract DebugView driver to %s%s", FileName, v11);
        goto LABEL_23;
      }
      if ( qword_1400935B8 )
        qword_1400935B8(1i64);
      if ( !sub_14000CD70("DBGV", FileName, (char **)&hDevice) )
      {
        if ( GetLastError() == 1168 )
        {
          sub_140002490(Format, "File Not Found");
        }
        else if ( GetLastError() == 5 || GetLastError() == 3 )
        {
          sub_140002490(
            Format,
            "Cannot connect to local system because it is already\nconnected to another instance of DebugView.");
        }
        else if ( GetLastError() == 1392 )
        {
          sub_140002490(
            Format,
            "This version of DebugView will not capture kernel debug output for this version of Windows.\n"
            "Check the Sysinternals site for updates.");
        }
        else
        {
          LastError = GetLastError();
          sub_140002490(
            Format,
            "Error %d loading DebugView. Make sure that you have the Load Drivers and Debug privileges and\n"
            "are running DebugView off of a local drive.",
            LastError);
        }
        DeleteFileA(FileName);
        sub_140002490(xmmword_140095910, Format);
LABEL_23:
        v12 = xmmword_140095910;
LABEL_24:
        MessageBoxA(a1, v12, "DebugView", 0x10u);
        result = 0i64;
        byte_1400958F4 = 1;
        return result;
      }
      DeleteFileA(FileName);
      if ( hDevice == (HANDLE)-1i64 )
      {
LABEL_51:
        qword_140095900 = (__int64)j__malloc_base(0x1004ui64);
        *(_DWORD *)(qword_140095900 + 16) = 0;
        *(_QWORD *)(qword_140095900 + 8) = 0i64;
        dword_140095908 = 1;
        if ( WSAStartup(0x202u, &WSAData) == -1 )
        {
          sub_140002BF0(qword_14009DCA8, "Unable to initialize Winsock");
          return 0i64;
        }
        s = socket(2, 1, 0);
        if ( s == -1i64 )
        {
          sub_140002BF0(qword_14009DCA8, "Unable to create socket");
          result = 0i64;
          byte_1400958F4 = 1;
          return result;
        }
        nSize = 16;
        GetComputerNameA(name, &nSize);
        v22.sa_family = gethostbyname(name)->h_addrtype;
        v15 = 2020;
        *(_DWORD *)&v22.sa_data[2] = htonl(0);
        while ( 1 )
        {
          *(_WORD *)v22.sa_data = htons(v15);
          if ( !bind(s, &v22, 16) )
            break;
          if ( (__int16)++v15 >= 2030 )
          {
            sub_140002BF0(qword_14009DCA8, "Unable to bind socket");
            result = 0i64;
            byte_1400958F4 = 1;
            return result;
          }
        }
        namelen = 16;
        if ( getsockname(s, &v22, &namelen) )
        {
          sub_140002BF0(qword_14009DCA8, "Unable to query the port1");
          result = 0i64;
          byte_1400958F4 = 1;
          return result;
        }
        if ( listen(s, 0) == -1 )
        {
          sub_140002BF0(qword_14009DCA8, "Socket listen failure");
          result = 0i64;
          byte_1400958F4 = 1;
          return result;
        }
        qword_14009DC98 = CreateEventA(0i64, 0, 0, 0i64);
        SetTimer(a1, 0i64, 0x1F4u, 0i64);
        qword_140096938 = (HANDLE)beginthread((_beginthread_proc_type)sub_14000C210, 0, a1);
        return DefWindowProcA(a1, a2, a3, a4);
      }
      if ( !DeviceIoControl(hDevice, 0x83050024, 0i64, 0, &OutBuffer, 4u, &BytesReturned, 0i64) || OutBuffer != 800 )
      {
        v12 = "DebugView has found a previously loaded DebugView driver with a version incompatable with the\n"
              "user interface. Please reboot the system and restart DebugView to synchronize the GUI and driver.";
        goto LABEL_24;
      }
    }
    else
    {
      qword_1400A36C0 = (__int64)&unk_1400935A8;
    }
    if ( hDevice != (HANDLE)-1i64 )
    {
      if ( !DeviceIoControl(hDevice, 0x83050008, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
      {
        sub_140002BF0(a1, "Couldn't access device driver");
        result = 0i64;
        byte_1400958F4 = 1;
        return result;
      }
      v14 = hDevice;
      if ( hDevice != (HANDLE)-1i64 )
      {
        if ( byte_1400935A3 )
        {
          DeviceIoControl(hDevice, 0x8305003C, 0i64, 0, 0i64, 0, &BytesReturned, 0i64);
          v14 = hDevice;
        }
        if ( v14 != (HANDLE)-1i64
          && !DeviceIoControl(v14, 0x83050020, 0i64, 0, &qword_1400A36C0, 8u, &BytesReturned, 0i64) )
        {
          sub_140002BF0(a1, "Couldn't access device driver");
          return 0i64;
        }
      }
    }
    goto LABEL_51;
  }
  if ( a3 != 61472 || !byte_1400935A1 )
  {
    ShowWindow(a1, 5);
    return DefWindowProcA(a1, a2, a3, a4);
  }
  v16 = "APPICONDISABLED";
  if ( byte_1400958F2 )
    v16 = "APPICON";
  v17 = LoadIconA(hInstance, v16);
  GetWindowTextA(a1, String, 4128);
  sub_14000A410(a1, 1u, v17, String);
  ShowWindow(a1, 0);
  return 0i64;
}
// 1400921C9: using guessed type char byte_1400921C9;
// 1400921CA: using guessed type char byte_1400921CA;
// 1400935A1: using guessed type char byte_1400935A1;
// 1400935A3: using guessed type char byte_1400935A3;
// 1400935B8: using guessed type __int64 (__fastcall *qword_1400935B8)(_QWORD);
// 1400958F2: using guessed type char byte_1400958F2;
// 1400958F3: using guessed type char byte_1400958F3;
// 1400958F4: using guessed type char byte_1400958F4;
// 140095900: using guessed type __int64 qword_140095900;
// 140095908: using guessed type int dword_140095908;
// 1400A36C0: using guessed type __int64 qword_1400A36C0;
// 1400A3868: using guessed type int dword_1400A3868;

//----- (000000014000BFF0) ----------------------------------------------------
__int64 sub_14000BFF0()
{
  __int64 v0; // r8
  __int64 result; // rax
  __int64 v2; // rcx
  __int64 v3; // rdx
  int v4; // edx
  char v5; // cl

  v0 = qword_140095900;
  result = qword_140095900;
  v2 = *(_QWORD *)(qword_140095900 + 8);
  if ( v2 )
  {
    do
    {
      v3 = result;
      result = v2;
      v2 = *(_QWORD *)(v2 + 8);
    }
    while ( v2 );
    *(_QWORD *)(v3 + 8) = 0i64;
    v0 = qword_140095900;
    v4 = --dword_140095908;
  }
  else
  {
    v4 = dword_140095908;
  }
  if ( !*(_DWORD *)(v0 + 16) )
  {
    v5 = byte_1400935AC;
    if ( v4 == 1 )
      v5 = 0;
    byte_1400935AC = v5;
  }
  return result;
}
// 1400935AC: using guessed type char byte_1400935AC;
// 140095900: using guessed type __int64 qword_140095900;
// 140095908: using guessed type int dword_140095908;

//----- (000000014000C060) ----------------------------------------------------
__int64 __fastcall sub_14000C060(HWND hDlg, int a2, __int16 a3, __int64 a4)
{
  HWND v5; // rbx
  int v6; // edx
  int v7; // edx
  LRESULT v8; // rdx
  HWND DlgItem; // rax
  const __m128i **v11; // rcx
  const __m128i *v12; // rdx
  __int64 v13; // rbx
  char *v14; // rax
  __m128i in; // [rsp+24h] [rbp-24h] BYREF

  v5 = hDlg;
  v6 = a2 - 16;
  if ( !v6 )
    goto LABEL_14;
  v7 = v6 - 256;
  if ( !v7 )
  {
    DlgItem = GetDlgItem(hDlg, 1001);
    v11 = *(const __m128i ***)(a4 + 24);
    qword_140096930 = DlgItem;
    v12 = *v11;
    if ( *v11 )
    {
      v13 = 0i64;
      do
      {
        sub_1400161F0(&in, v12, *(__int16 *)(a4 + 18));
        v14 = inet_ntoa(*(struct in_addr *)in.m128i_i8);
        SendMessageA(qword_140096930, 0x143u, 0i64, (LPARAM)v14);
        ++v13;
        v12 = *(const __m128i **)(*(_QWORD *)(a4 + 24) + 8 * v13);
      }
      while ( v12 );
      DlgItem = qword_140096930;
    }
    SendMessageA(DlgItem, 0x14Eu, 0i64, 0i64);
    return 1i64;
  }
  if ( v7 != 1 )
    return 0i64;
  if ( a3 != 1 )
  {
    if ( a3 != 2 )
    {
      if ( a3 == 1005 )
        goto LABEL_7;
      return 0i64;
    }
LABEL_14:
    v8 = -1i64;
    goto LABEL_15;
  }
LABEL_7:
  v8 = SendMessageA(qword_140096930, 0x147u, 0i64, 0i64);
  hDlg = v5;
LABEL_15:
  EndDialog(hDlg, v8);
  return 1i64;
}

//----- (000000014000C190) ----------------------------------------------------
__int64 sub_14000C190()
{
  __int64 result; // rax
  __int64 v1; // rbx
  _DWORD *v2; // rax

  result = (unsigned int)dword_140095908;
  v1 = qword_140095900;
  if ( dword_140092840 == dword_140095908 )
  {
    *(_DWORD *)(qword_140095900 + 16) = 0;
  }
  else if ( *(_DWORD *)(qword_140095900 + 16) )
  {
    v2 = j__malloc_base(0x1004ui64);
    if ( v2 )
    {
      qword_140095900 = (__int64)v2;
      v2[4] = 0;
      result = qword_140095900;
      *(_QWORD *)(qword_140095900 + 8) = v1;
      ++dword_140095908;
    }
    else
    {
      result = qword_140095900;
      *(_DWORD *)(qword_140095900 + 16) = 0;
    }
  }
  return result;
}
// 140092840: using guessed type int dword_140092840;
// 140095900: using guessed type __int64 qword_140095900;
// 140095908: using guessed type int dword_140095908;

//----- (000000014000C210) ----------------------------------------------------
void __fastcall sub_14000C210(HWND a1)
{
  HWND v1; // rbx
  unsigned int v2; // r12d
  char v3; // r13
  void *v4; // rsi
  HANDLE v5; // rax
  void *v6; // r15
  HICON IconA; // rax
  unsigned int v8; // r14d
  DWORD v9; // edi
  DWORD v10; // eax
  DWORD v11; // ebx
  char v12; // al
  _DWORD *v13; // rdi
  int v14; // esi
  _DWORD *v15; // rdi
  int v16; // esi
  bool v17; // zf
  HICON v18; // rax
  DWORD BytesReturned; // [rsp+48h] [rbp-79h] BYREF
  int OutBuffer; // [rsp+4Ch] [rbp-75h] BYREF
  DWORD Buffer; // [rsp+50h] [rbp-71h] BYREF
  int addrlen; // [rsp+54h] [rbp-6Dh] BYREF
  DWORD NumberOfBytesWritten; // [rsp+58h] [rbp-69h] BYREF
  DWORD NumberOfBytesRead; // [rsp+5Ch] [rbp-65h] BYREF
  HANDLE EventA; // [rsp+60h] [rbp-61h]
  struct _OVERLAPPED Overlapped; // [rsp+68h] [rbp-59h] BYREF
  LARGE_INTEGER Frequency; // [rsp+88h] [rbp-39h] BYREF
  HWND v28; // [rsp+90h] [rbp-31h]
  struct _OVERLAPPED v29; // [rsp+98h] [rbp-29h] BYREF
  struct sockaddr addr; // [rsp+B8h] [rbp-9h] BYREF
  HANDLE hEvent[2]; // [rsp+C8h] [rbp+7h] BYREF
  __int128 v32; // [rsp+D8h] [rbp+17h]
  HANDLE v33; // [rsp+E8h] [rbp+27h]

  v1 = a1;
  v28 = a1;
  v2 = 0;
  v33 = 0i64;
  *(_OWORD *)hEvent = 0i64;
  v3 = 0;
  v32 = 0i64;
  hObject = CreateEventA(0i64, 1, 0, 0i64);
  if ( !hObject )
    goto LABEL_84;
  EventA = CreateEventA(0i64, 1, 0, 0i64);
  v4 = EventA;
  if ( EventA )
  {
    hEvent[0] = hObject;
    v5 = CreateEventA(0i64, 1, 0, 0i64);
    hEvent[1] = v5;
    if ( v5 )
    {
      *(_QWORD *)&v32 = qword_14009DC98;
      while ( 1 )
      {
        while ( 1 )
        {
          SetDlgItemTextA(qword_14009DCA8, 1004, "Waiting for connection...");
          addrlen = 16;
          v6 = (void *)accept(s, &addr, &addrlen);
          if ( v6 != (void *)-1i64 )
            break;
          WSAGetLastError();
          sub_140002BF0(qword_14009DCA8, "No connection");
        }
        SetDlgItemTextA(qword_14009DCA8, 1004, "Connected.");
        byte_1400958F2 = 1;
        IconA = LoadIconA(hInstance, "APPICON");
        sub_14000A540(v1, 1u, IconA);
        Overlapped.hEvent = hEvent[1];
        memset(&Overlapped, 0, 24);
        ResetEvent(hEvent[1]);
        ReadFile(v6, &Buffer, 4u, &NumberOfBytesRead, &Overlapped);
        while ( 1 )
        {
          v8 = v2;
          if ( byte_1400921C9 )
          {
            v9 = 4;
            *((_QWORD *)&v32 + 1) = qword_1400A3680;
            if ( byte_1400935A2 )
            {
              v9 = 5;
              v33 = qword_1400A3688;
            }
          }
          else
          {
            v9 = 3;
          }
          while ( 1 )
          {
            while ( 1 )
            {
              v10 = WaitForMultipleObjects(v9, hEvent, 0, 0xFFFFFFFF);
              if ( v10 != 1 )
                break;
              v11 = Buffer;
              if ( Buffer )
                goto LABEL_21;
            }
            if ( v10 == 2 )
              goto LABEL_20;
            if ( v10 <= 2 )
              goto LABEL_71;
            if ( v10 > 4 )
              break;
            sub_14000B220();
          }
          if ( v10 != 258 )
            break;
LABEL_20:
          v11 = -2096824305;
LABEL_21:
          switch ( v11 )
          {
            case 0x83050000:
            case 0x83050004:
            case 0x83050010:
            case 0x83050014:
              goto LABEL_23;
            case 0x83050008:
              if ( hDevice != (HANDLE)-1i64 && !DeviceIoControl(hDevice, v11, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
                sub_140002BF0(qword_14009DCA8, "Driver error");
              sub_14000CAB0();
              QueryPerformanceCounter(&PerformanceCount);
              goto LABEL_68;
            case 0x8305000F:
              v12 = byte_1400935AC;
              ++v2;
              memset(&v29, 0, 24);
              v29.hEvent = v4;
              if ( !v3 && byte_1400935AC )
              {
                sub_14000C190();
                v13 = (_DWORD *)sub_14000BFF0();
                v14 = (unsigned __int8)sub_14000CB20(v6, (__int64)(v13 + 4), v13[4] + 4, &v29);
                if ( v13 != (_DWORD *)qword_140095900 )
                  j__free_base(v13);
                v3 = 1;
                if ( !v14 )
                  goto LABEL_71;
                v2 = v8;
                goto LABEL_64;
              }
              if ( hDevice == (HANDLE)-1i64 )
                goto LABEL_55;
              if ( DeviceIoControl(hDevice, 0x8305000F, 0i64, 0, &unk_14009CCA4, 0xFF0u, &::NumberOfBytesRead, 0i64) )
              {
                v12 = byte_1400935AC;
LABEL_55:
                if ( ::NumberOfBytesRead )
                {
                  dword_14009CCA0 = ::NumberOfBytesRead;
                  v17 = sub_14000CB20(v6, (__int64)&dword_14009CCA0, ::NumberOfBytesRead + 4, &v29) == 0;
LABEL_61:
                  if ( v17 )
                    goto LABEL_71;
                  v2 = v8;
                  goto LABEL_63;
                }
                if ( v12 )
                {
                  sub_14000C190();
                  v15 = (_DWORD *)sub_14000BFF0();
                  v16 = (unsigned __int8)sub_14000CB20(v6, (__int64)(v15 + 4), v15[4] + 4, &v29);
                  if ( v15 != (_DWORD *)qword_140095900 )
                    j__free_base(v15);
                  v17 = v16 == 0;
                  goto LABEL_61;
                }
LABEL_63:
                v3 = 0;
LABEL_64:
                if ( v2 > 0xA )
                {
                  dword_14009CCA0 = 0;
                  if ( !sub_14000CB20(v6, (__int64)&dword_14009CCA0, 4u, &v29) )
                    goto LABEL_71;
                  v2 = 0;
                }
                v4 = EventA;
LABEL_68:
                if ( v11 != -2096824305 )
                {
                  Overlapped.hEvent = hEvent[1];
                  memset(&Overlapped, 0, 24);
                  ResetEvent(hEvent[1]);
                  if ( !ReadFile(v6, &Buffer, 4u, &NumberOfBytesRead, &Overlapped) && GetLastError() != 997 )
                    goto LABEL_71;
                }
              }
              else
              {
                sub_140002BF0(qword_14009DCA8, "Unable to access driver");
              }
              break;
            case 0x83050018:
              byte_1400921C9 = 1;
              DGBView_StartListener_140005710(0);
              if ( byte_1400935A2 )
                DGBView_StartListener_140005710(byte_1400935A2);
              goto LABEL_68;
            case 0x8305001C:
              byte_1400921C9 = 0;
              DBGView_CloseListener(0);
              if ( byte_1400935A2 )
                DBGView_CloseListener(1u);
              sub_14000CAB0();
              goto LABEL_68;
            case 0x83050024:
              OutBuffer = 0x7FFFFFFF;
              if ( hDevice != (HANDLE)-1i64
                && !DeviceIoControl(hDevice, v11, 0i64, 0, &OutBuffer, 4u, &BytesReturned, 0i64) )
              {
                sub_140002BF0(qword_14009DCA8, "Unable to communicate with driver");
              }
              Overlapped.hEvent = hEvent[1];
              memset(&Overlapped, 0, 24);
              ResetEvent(hEvent[1]);
              if ( !WriteFile(v6, &OutBuffer, 4u, &NumberOfBytesWritten, &Overlapped) && GetLastError() == 997 )
                WaitForMultipleObjects(2u, hEvent, 0, 0xFFFFFFFF);
              goto LABEL_68;
            case 0x83050028:
              QueryPerformanceFrequency(&Frequency);
              Overlapped.hEvent = hEvent[1];
              memset(&Overlapped, 0, 24);
              ResetEvent(hEvent[1]);
              if ( WriteFile(v6, &Frequency, 8u, &NumberOfBytesWritten, &Overlapped)
                || GetLastError() != 997
                || WaitForMultipleObjects(2u, hEvent, 0, 0xFFFFFFFF) == 1 )
              {
                byte_1400958F3 = 1;
              }
              goto LABEL_68;
            case 0x8305002C:
              goto LABEL_71;
            case 0x83050034:
            case 0x83050038:
              byte_1400921B0 = v11 == -2096824268;
LABEL_23:
              if ( hDevice != (HANDLE)-1i64 && !DeviceIoControl(hDevice, v11, 0i64, 0, 0i64, 0, &BytesReturned, 0i64) )
                sub_140002BF0(qword_14009DCA8, "Error communicating with driver");
              goto LABEL_68;
            default:
              goto LABEL_68;
          }
        }
LABEL_71:
        closesocket((SOCKET)v6);
        if ( hDevice != (HANDLE)-1i64 )
          DeviceIoControl(hDevice, 0x83050004, 0i64, 0, 0i64, 0, &BytesReturned, 0i64);
        byte_1400958F2 = 0;
        byte_1400958F3 = 0;
        ResetEvent(qword_14009DC98);
        if ( !byte_1400958F0 && byte_1400958F1 )
          MessageBoxA(qword_14009DCA8, "The connection was terminated by the remote side.", "DebugView", 0x10u);
        if ( byte_1400921C9 )
        {
          DBGView_CloseListener(0);
          if ( byte_1400935A2 )
            DBGView_CloseListener(1u);
          sub_14000CAB0();
          byte_1400921C9 = 0;
        }
        v18 = LoadIconA(hInstance, "APPICONDISABLED");
        v1 = v28;
        sub_14000A540(v28, 1u, v18);
        v4 = EventA;
      }
    }
  }
  else
  {
    v5 = hEvent[1];
  }
  if ( hObject )
  {
    CloseHandle(hObject);
LABEL_84:
    v5 = hEvent[1];
  }
  if ( v5 )
    CloseHandle(v5);
}
// 1400921B0: using guessed type char byte_1400921B0;
// 1400921C9: using guessed type char byte_1400921C9;
// 1400935A2: using guessed type char byte_1400935A2;
// 1400935AC: using guessed type char byte_1400935AC;
// 1400958F0: using guessed type char byte_1400958F0;
// 1400958F1: using guessed type char byte_1400958F1;
// 1400958F2: using guessed type char byte_1400958F2;
// 1400958F3: using guessed type char byte_1400958F3;
// 140095900: using guessed type __int64 qword_140095900;
// 14009CCA0: using guessed type int dword_14009CCA0;

//----- (000000014000CAB0) ----------------------------------------------------
__int64 sub_14000CAB0()
{
  __int64 v0; // rax
  _QWORD *v1; // rcx
  _QWORD *v2; // rbx
  __int64 result; // rax

  v0 = qword_140095900;
  v1 = *(_QWORD **)(qword_140095900 + 8);
  if ( v1 )
  {
    do
    {
      v2 = (_QWORD *)v1[1];
      j__free_base(v1);
      v1 = v2;
    }
    while ( v2 );
    v0 = qword_140095900;
  }
  *(_DWORD *)(v0 + 16) = 0;
  result = qword_140095900;
  *(_QWORD *)(qword_140095900 + 8) = 0i64;
  byte_1400935AC = 0;
  dword_140095908 = 1;
  return result;
}
// 1400935AC: using guessed type char byte_1400935AC;
// 140095900: using guessed type __int64 qword_140095900;
// 140095908: using guessed type int dword_140095908;

//----- (000000014000CB20) ----------------------------------------------------
char __fastcall sub_14000CB20(HANDLE hFile, __int64 a2, unsigned int a3, struct _OVERLAPPED *a4)
{
  unsigned int v4; // ebx
  DWORD v9; // r8d
  DWORD NumberOfBytesWritten; // [rsp+60h] [rbp+18h] BYREF

  v4 = 0;
  if ( !a3 )
    return 1;
  while ( 1 )
  {
    ResetEvent(a4->hEvent);
    v9 = 500;
    if ( a3 - v4 < 0x1F4 )
      v9 = a3 - v4;
    if ( !WriteFile(hFile, (LPCVOID)(a2 + v4), v9, &NumberOfBytesWritten, a4)
      && (GetLastError() != 997
       || WaitForSingleObject(a4->hEvent, 0xBB8u) == 258
       || !GetOverlappedResult(hFile, a4, &NumberOfBytesWritten, 1)) )
    {
      break;
    }
    v4 += NumberOfBytesWritten;
    if ( v4 >= a3 )
      return 1;
  }
  return 0;
}

//----- (000000014000CBE0) ----------------------------------------------------
__int64 __fastcall sub_14000CBE0(LPCSTR lpName)
{
  HANDLE CurrentProcess; // rax
  unsigned int v3; // ebx
  HANDLE TokenHandle; // [rsp+30h] [rbp-38h] BYREF
  struct _LUID Luid; // [rsp+38h] [rbp-30h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [rsp+40h] [rbp-28h] BYREF

  CurrentProcess = GetCurrentProcess();
  if ( !OpenProcessToken(CurrentProcess, 0x28u, &TokenHandle) || !LookupPrivilegeValueA(0i64, lpName, &Luid) )
    return 0i64;
  NewState.PrivilegeCount = 1;
  NewState.Privileges[0].Luid = Luid;
  NewState.Privileges[0].Attributes = 2;
  v3 = AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0x10u, 0i64, 0i64);
  if ( v3 )
  {
    if ( GetLastError() )
      v3 = 0;
  }
  CloseHandle(TokenHandle);
  return v3;
}

//----- (000000014000CCC0) ----------------------------------------------------
char __fastcall sub_14000CCC0(LPCSTR lpName, char *FileName)
{
  HRSRC ResourceA; // rax
  HRSRC v4; // rdi
  HGLOBAL Resource; // rbx
  DWORD v6; // edi
  const void *v7; // rsi
  FILE *v8; // rax
  FILE *v9; // rbx

  ResourceA = FindResourceA(0i64, lpName, "BINRES");
  v4 = ResourceA;
  if ( !ResourceA )
    return 0;
  Resource = LoadResource(0i64, ResourceA);
  v6 = SizeofResource(0i64, v4);
  v7 = LockResource(Resource);
  v8 = fopen(FileName, "wb");
  v9 = v8;
  if ( !v8 )
    return 0;
  fwrite(v7, 1ui64, v6, v8);
  fclose(v9);
  return 1;
}

//----- (000000014000CD70) ----------------------------------------------------
_BOOL8 __fastcall sub_14000CD70(const char *a1, const char *a2, char **a3)
{
  __int64 v7; // rbx
  __int64 cbData; // rax
  HMODULE ModuleHandleA; // rax
  FARPROC ProcAddress; // r14
  HMODULE v11; // rax
  FARPROC v12; // r15
  HMODULE v13; // rax
  FARPROC v14; // r12
  HMODULE v15; // rax
  FARPROC v16; // r13
  __int64 v17; // r8
  unsigned int v18; // ebx
  DWORD v19; // eax
  BYTE Data[4]; // [rsp+30h] [rbp-D0h] BYREF
  HKEY phkResult; // [rsp+38h] [rbp-C8h] BYREF
  __int16 v22; // [rsp+40h] [rbp-C0h] BYREF
  char *v23; // [rsp+48h] [rbp-B8h]
  char v24[16]; // [rsp+50h] [rbp-B0h] BYREF
  CHAR SubKey[272]; // [rsp+60h] [rbp-A0h] BYREF
  CHAR v26[272]; // [rsp+170h] [rbp+70h] BYREF
  BYTE lpData[272]; // [rsp+280h] [rbp+180h] BYREF
  char Buffer[272]; // [rsp+390h] [rbp+290h] BYREF

  sub_14000CBE0("SeLoadDriverPrivilege");
  sub_140002490(SubKey, "System\\CurrentControlSet\\Services\\%s", a1);
  if ( RegCreateKeyA(HKEY_LOCAL_MACHINE, SubKey, &phkResult) )
  {
    SetLastError(5u);
    return 0i64;
  }
  else
  {
    *(_DWORD *)Data = 1;
    RegSetValueExA(phkResult, "Type", 0, 4u, Data, 4u);
    *(_DWORD *)Data = 1;
    RegSetValueExA(phkResult, "ErrorControl", 0, 4u, Data, 4u);
    *(_DWORD *)Data = 3;
    RegSetValueExA(phkResult, "Start", 0, 4u, Data, 4u);
    sub_140002490((char *)lpData, "\\??\\%s", a2);
    v7 = -1i64;
    cbData = -1i64;
    do
      ++cbData;
    while ( lpData[cbData] );
    RegSetValueExA(phkResult, "ImagePath", 0, 1u, lpData, cbData);
    RegCloseKey(phkResult);
    ModuleHandleA = GetModuleHandleA("ntdll.dll");
    ProcAddress = GetProcAddress(ModuleHandleA, "RtlNtStatusToDosError");
    v11 = GetModuleHandleA("ntdll.dll");
    v12 = GetProcAddress(v11, "RtlAnsiStringToUnicodeString");
    v13 = GetModuleHandleA("ntdll.dll");
    v14 = GetProcAddress(v13, "NtLoadDriver");
    v15 = GetModuleHandleA("ntdll.dll");
    v16 = GetProcAddress(v15, "RtlFreeUnicodeString");
    sub_140002490(Buffer, "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s", a1);
    v23 = Buffer;
    do
      ++v7;
    while ( Buffer[v7] );
    LOBYTE(v17) = 1;
    v22 = v7;
    ((void (__fastcall *)(char *, __int16 *, __int64))v12)(v24, &v22, v17);
    v18 = ((__int64 (__fastcall *)(char *))v14)(v24);
    ((void (__fastcall *)(char *))v16)(v24);
    sub_140002490(v26, "%s\\Enum", SubKey);
    RegDeleteKeyA(HKEY_LOCAL_MACHINE, v26);
    sub_140002490(v26, "%s\\Security", SubKey);
    RegDeleteKeyA(HKEY_LOCAL_MACHINE, v26);
    RegDeleteKeyA(HKEY_LOCAL_MACHINE, SubKey);
    if ( !v18 || v18 == -1073741554 || v18 == -1073741771 )
    {
      sub_14000D0D0(a1, a3);
      return *a3 + 1 != 0i64;
    }
    else
    {
      v19 = ((__int64 (__fastcall *)(_QWORD))ProcAddress)(v18);
      SetLastError(v19);
      return 0i64;
    }
  }
}
// 14000CFDB: variable 'v17' is possibly undefined
// 14000CD70: using guessed type BYTE var_260[272];
// 14000CD70: using guessed type char Buffer[272];

//----- (000000014000D0D0) ----------------------------------------------------
__int64 __fastcall sub_14000D0D0(const char *a1, char **a2)
{
  unsigned int v4; // ebx
  char *FileA; // rax
  bool v6; // zf
  char *v7; // rax
  CHAR FileName[272]; // [rsp+40h] [rbp-128h] BYREF

  sub_140002490(FileName, "\\\\.\\%s", a1);
  v4 = 0;
  FileA = (char *)CreateFileA(FileName, 0xC0000000, 0, 0i64, 3u, 0x80u, 0i64);
  *a2 = FileA;
  v6 = FileA + 1 == 0i64;
  if ( FileA == (char *)-1i64 )
  {
    sub_140002490(FileName, "\\\\.\\Global\\%s", a1);
    v7 = (char *)CreateFileA(FileName, 0xC0000000, 0, 0i64, 3u, 0x80u, 0i64);
    *a2 = v7;
    v6 = v7 + 1 == 0i64;
  }
  LOBYTE(v4) = !v6;
  return v4;
}

//----- (000000014000D1C0) ----------------------------------------------------
_BOOL8 __fastcall sub_14000D1C0(const char *a1)
{
  HMODULE ModuleHandleA; // rax
  FARPROC ProcAddress; // rdi
  HMODULE v5; // rax
  FARPROC v6; // rsi
  HMODULE v7; // rax
  FARPROC v8; // rbp
  HMODULE v9; // rax
  __int64 v10; // r8
  __int64 v11; // rdx
  unsigned int v12; // ebx
  DWORD v13; // eax
  HKEY phkResult; // [rsp+20h] [rbp-268h] BYREF
  __int16 v15; // [rsp+28h] [rbp-260h] BYREF
  char *v16; // [rsp+30h] [rbp-258h]
  char v17[24]; // [rsp+38h] [rbp-250h] BYREF
  char Buffer[272]; // [rsp+50h] [rbp-238h] BYREF
  CHAR SubKey[272]; // [rsp+160h] [rbp-128h] BYREF

  sub_14000CBE0("SeLoadDriverPrivilege");
  sub_140002490(SubKey, "System\\CurrentControlSet\\Services\\%s", a1);
  if ( RegCreateKeyA(HKEY_LOCAL_MACHINE, SubKey, &phkResult) )
    return 0i64;
  RegCloseKey(phkResult);
  ModuleHandleA = GetModuleHandleA("ntdll.dll");
  ProcAddress = GetProcAddress(ModuleHandleA, "RtlNtStatusToDosError");
  v5 = GetModuleHandleA("ntdll.dll");
  v6 = GetProcAddress(v5, "RtlAnsiStringToUnicodeString");
  v7 = GetModuleHandleA("ntdll.dll");
  v8 = GetProcAddress(v7, "NtUnloadDriver");
  v9 = GetModuleHandleA("ntdll.dll");
  GetProcAddress(v9, "RtlFreeUnicodeString");
  sub_140002490(Buffer, "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s", a1);
  v11 = -1i64;
  v16 = Buffer;
  do
    ++v11;
  while ( Buffer[v11] );
  v15 = v11;
  LOBYTE(v10) = 1;
  ((void (__fastcall *)(char *, __int16 *, __int64))v6)(v17, &v15, v10);
  v12 = ((__int64 (__fastcall *)(char *))v8)(v17);
  RegDeleteKeyA(HKEY_LOCAL_MACHINE, SubKey);
  v13 = ((__int64 (__fastcall *)(_QWORD))ProcAddress)(v12);
  SetLastError(v13);
  return v12 == 0;
}
// 14000D30B: variable 'v10' is possibly undefined
// 14000D1C0: using guessed type char Buffer[272];

//----- (000000014000D370) ----------------------------------------------------
_BOOL8 __fastcall sub_14000D370(HWND hDlg, int a2, HDC a3, HWND a4)
{
  LPARAM v7; // r9
  COLORREF v9; // ecx
  __int64 v10; // rdx
  __int64 v11; // rcx
  HWND DlgItem; // rax

  switch ( a2 )
  {
    case 272:
      dword_1400979B8 = *((_DWORD *)a4 + 12);
      qword_1400979A0 = GetDlgItem(hDlg, 1023);
      v11 = (unsigned int)dword_1400979B8;
      dword_1400979A8 = dword_1400A8080[v11];
      LODWORD(color) = dword_1400A8020[v11];
      dword_1400979B0 = RegisterWindowMessageA("commdlg_ColorOK");
      Msg = RegisterWindowMessageA("commdlg_SetRGBColor");
      CheckRadioButton(hDlg, 1028, 1029, 1028);
      SendMessageA(hDlg, Msg, 0i64, dword_1400979A8);
      DlgItem = GetDlgItem(hDlg, 3);
      SetFocus(DlgItem);
      return 0i64;
    case 273:
      if ( a3 == (HDC)3 )
      {
        DeleteObject((HGDIOBJ)qword_1400A7F80[dword_1400979B8]);
        v9 = color;
        v10 = (unsigned int)dword_1400979B8;
        dword_1400A8080[v10] = dword_1400979A8;
        dword_1400A8020[v10] = v9;
        qword_1400A7F80[dword_1400979B8] = (__int64)CreateSolidBrush(v9);
        PostMessageA(hDlg, 0x111u, 3ui64, 0i64);
        return 0i64;
      }
      return 0i64;
    case 312:
      if ( a4 == qword_1400979A0 )
      {
        SetBkColor(a3, color);
        SetTextColor(a3, dword_1400979A8);
        return GetStockObject(0) != 0i64;
      }
      return 0i64;
  }
  if ( a2 != dword_1400979B0 )
    return 0i64;
  if ( IsDlgButtonChecked(hDlg, 1029) )
  {
    LODWORD(color) = a4[6];
    InvalidateRect(qword_1400979A0, 0i64, 1);
    v7 = dword_1400979A8;
  }
  else
  {
    dword_1400979A8 = *((_DWORD *)a4 + 6);
    InvalidateRect(qword_1400979A0, 0i64, 1);
    v7 = (unsigned int)color;
  }
  SendMessageA(hDlg, Msg, 0i64, v7);
  return 1i64;
}
// 1400979B0: using guessed type int dword_1400979B0;
// 1400979B8: using guessed type int dword_1400979B8;
// 1400A7F80: using guessed type __int64 qword_1400A7F80[5];
// 1400A8020: using guessed type int dword_1400A8020[];
// 1400A8080: using guessed type int dword_1400A8080[];

//----- (000000014000D5D0) ----------------------------------------------------
INT_PTR __fastcall sub_14000D5D0(HWND a1, unsigned int a2, HDC a3, HWND a4)
{
  HWND v6; // rdi
  HWND DlgItem; // rax
  int k; // r9d
  int v9; // r9d
  __int64 v10; // r10
  char *v11; // rcx
  char *v12; // rdx
  char v13; // al
  char *v14; // r8
  char v15; // al
  LPARAM *v16; // rbx
  __int64 v17; // rbp
  HWND v18; // r10
  LPARAM *v19; // rdi
  __int64 v20; // rsi
  int v21; // ecx
  const LPARAM *v22; // r9
  LPARAM *v23; // rbx
  HWND v24; // r10
  __int64 v25; // rsi
  LPARAM *v26; // rdi
  int v27; // ecx
  const LPARAM *v28; // r9
  HWND v29; // rcx
  bool v30; // cf
  int v31; // eax
  LPARAM *v32; // r9
  LPARAM *v33; // rbx
  LPARAM *v34; // rdi
  int v35; // ecx
  const LPARAM *v36; // r9
  int v37; // eax
  int v39; // r15d
  int v40; // r14d
  COLORREF v41; // eax
  COLORREF v42; // ebx
  COLORREF v43; // eax
  COLORREF v44; // edi
  int c; // eax
  int v46; // ecx
  DWORD SysColor; // eax
  int v48; // ecx
  DWORD v49; // eax
  int v50; // eax
  __int64 v51; // rax
  __int64 v52; // rdx
  char v53; // al
  int v54; // eax
  int v55; // edi
  int v56; // r8d
  int v57; // r9d
  LPARAM *v58; // rcx
  char v59; // al
  __int64 v60; // rcx
  CHAR v61; // al
  __int64 v62; // rdx
  char v63; // al
  int v64; // eax
  int v65; // edi
  int v66; // r8d
  int v67; // r9d
  LPARAM *v68; // rcx
  char v69; // al
  __int64 v70; // rcx
  CHAR v71; // al
  char v72; // si
  int i; // eax
  __int64 v74; // r9
  char *v75; // rdx
  char *v76; // rcx
  char v77; // al
  char v78; // al
  int v79; // edx
  char *v80; // rcx
  int v81; // eax
  int v82; // edi
  bool v83; // zf
  int j; // edx
  LPARAM *v85; // rax
  char v86; // cl
  char *v87; // rcx
  signed __int64 v88; // r8
  char v89; // al
  char *v90; // rdx
  int v91; // ecx
  char *v92; // r9
  LPARAM *v93; // rbx
  __int64 v94; // rbp
  LPARAM *v95; // rdi
  int v96; // ecx
  const LPARAM *v97; // r9
  int v98; // eax
  struct tagTEXTMETRICA tm; // [rsp+48h] [rbp-290h] BYREF
  CHAR lParam[16]; // [rsp+80h] [rbp-258h] BYREF
  CHAR String[2]; // [rsp+90h] [rbp-248h] BYREF
  CHAR String2[2]; // [rsp+190h] [rbp-148h] BYREF

  v6 = a1;
  if ( a2 > 0x111 )
  {
    if ( a2 == 307 )
    {
      if ( a4 == qword_14009A1D0 || GetParent(a4) == qword_14009A1D0 )
      {
        SetTextColor(a3, dword_1400A8080[dword_1400979BC]);
        SetBkColor(a3, dword_1400A8020[dword_1400979BC]);
        return qword_1400A7F80[dword_1400979BC];
      }
    }
    else if ( a2 == 1024 )
    {
      GetDlgItemTextA(a1, 1005, &byte_1400979C0[256 * (__int64)dword_1400979BC], 256);
      dword_1400979BC = SendMessageA(qword_14009A1D8, 0x147u, 0i64, 0i64);
      SendMessageA(qword_14009A1D0, 0x14Bu, 0i64, 0i64);
      v90 = &byte_1400979C0[256 * (__int64)dword_1400979BC];
      v91 = (unsigned __int8)*v90 - 32;
      if ( *v90 == 32 )
        v91 = (unsigned __int8)v90[1];
      v92 = (char *)&WindowName;
      if ( v91 )
        v92 = &byte_1400979C0[256 * (__int64)dword_1400979BC];
      SendMessageA(qword_14009A1D0, 0x143u, 0i64, (LPARAM)v92);
      SendMessageA(qword_14009A1D0, 0x151u, 0i64, (LPARAM)&byte_1400979C0[256 * (__int64)dword_1400979BC]);
      v93 = String1;
      v94 = 5i64;
      v95 = String1;
      do
      {
        if ( *(_BYTE *)v93 && stricmp((const char *)v95, &byte_1400979C0[256 * (__int64)dword_1400979BC]) )
        {
          v96 = *(unsigned __int8 *)v95 - 32;
          if ( *(_BYTE *)v95 == 32 )
            v96 = *((unsigned __int8 *)v95 + 1);
          v97 = &WindowName;
          if ( v96 )
            v97 = v95;
          v98 = SendMessageA(qword_14009A1D0, 0x143u, 0i64, (LPARAM)v97);
          SendMessageA(qword_14009A1D0, 0x151u, v98, (LPARAM)v95);
        }
        v95 += 32;
        v93 += 32;
        --v94;
      }
      while ( v94 );
      SendMessageA(qword_14009A1D0, 0x14Eu, 0i64, 0i64);
      InvalidateRect(qword_14009A1D0, 0i64, 1);
      if ( a4 != (HWND)1 )
      {
        SetFocus(qword_14009A1D0);
        return 0i64;
      }
    }
    return 0i64;
  }
  switch ( a2 )
  {
    case 0x111u:
      if ( (_DWORD)a3 == 66568 )
        SendMessageA(a1, 0x400u, 0i64, 0i64);
      if ( (unsigned __int16)a3 > 0x407u )
      {
        if ( (unsigned __int16)a3 == 1035 )
        {
          sub_14000EC00(v6, byte_1400979C0);
          return 1i64;
        }
        if ( (unsigned __int16)a3 == 1036 )
        {
          sub_14000E3A0(v6, (__int64)byte_1400979C0);
          return 1i64;
        }
        return 0i64;
      }
      switch ( (unsigned __int16)a3 )
      {
        case 0x407u:
          sub_14000EE30(v6, dword_1400979BC);
          return 1i64;
        case 1u:
          GetDlgItemTextA(v6, 1005, &byte_1400979C0[256 * (__int64)dword_1400979BC], 256);
          GetDlgItemTextA(v6, 1003, String, 256);
          GetDlgItemTextA(v6, 1004, String2, 256);
          if ( !String[0] )
            strcpy(String, " ");
          if ( !String2[0] )
            strcpy(String2, " ");
          v51 = (__int64)dword_1400979BC << 8;
          if ( !byte_1400979C0[v51] )
            *(_WORD *)&byte_1400979C0[v51] = 32;
          v52 = 0i64;
          do
          {
            v53 = String[v52];
            *(&byte_1400A81E0 + v52++) = v53;
          }
          while ( v53 );
          strupr(&byte_1400A81E0);
          v54 = 0;
          do
          {
            v55 = v54 + 1;
            if ( !stricmp(&qword_1400A6680[256 * (__int64)v54], String) )
              break;
            v54 = v55;
          }
          while ( v55 < 5 );
          v56 = v55 - 2;
          if ( v55 != 1 )
          {
            v57 = v56 + 1;
            do
            {
              v58 = (LPARAM *)&qword_1400A6680[256 * (__int64)v56];
              do
              {
                v59 = *(_BYTE *)v58;
                *((_BYTE *)v58 + ((__int64)v57 << 8) - ((__int64)v56 << 8)) = *(_BYTE *)v58;
                v58 = (LPARAM *)((char *)v58 + 1);
              }
              while ( v59 );
              --v56;
              --v57;
            }
            while ( v56 != -1 );
          }
          v60 = 0i64;
          do
          {
            v61 = String[v60];
            qword_1400A6680[v60++] = v61;
          }
          while ( v61 );
          v62 = 0i64;
          do
          {
            v63 = String2[v62];
            *(&Source + v62++) = v63;
          }
          while ( v63 );
          strupr(&Source);
          v64 = 0;
          do
          {
            v65 = v64 + 1;
            if ( !stricmp(&qword_1400A6180[256 * (__int64)v64], String2) )
              break;
            v64 = v65;
          }
          while ( v65 < 5 );
          v66 = v65 - 2;
          if ( v65 != 1 )
          {
            v67 = v66 + 1;
            do
            {
              v68 = (LPARAM *)&qword_1400A6180[256 * (__int64)v66];
              do
              {
                v69 = *(_BYTE *)v68;
                *((_BYTE *)v68 + ((__int64)v67 << 8) - ((__int64)v66 << 8)) = *(_BYTE *)v68;
                v68 = (LPARAM *)((char *)v68 + 1);
              }
              while ( v69 );
              --v66;
              --v67;
            }
            while ( v66 != -1 );
          }
          v70 = 0i64;
          do
          {
            v71 = String2[v70];
            qword_1400A6180[v70++] = v71;
          }
          while ( v71 );
          v72 = 0;
          dword_1400979BC = 0;
          for ( i = 0; i < 20; dword_1400979BC = i )
          {
            v74 = (__int64)i << 8;
            v75 = &byte_1400979C0[v74];
            v76 = &byte_1400979C0[v74];
            do
            {
              v77 = *v76;
              v76[(char *)&byte_1400A4880 - byte_1400979C0] = *v76;
              ++v76;
            }
            while ( v77 );
            do
            {
              v78 = *v75;
              v75[&unk_1400A6B80 - (_UNKNOWN *)byte_1400979C0] = *v75;
              ++v75;
            }
            while ( v78 );
            strupr((char *)&unk_1400A6B80 + v74);
            v79 = dword_1400979BC;
            v80 = (char *)&unk_1400A6B80 + 256 * (__int64)dword_1400979BC;
            if ( *v80 && (*v80 != 32 || v80[1]) )
            {
              v81 = 0;
              while ( 1 )
              {
                v82 = v81 + 1;
                if ( !stricmp((const char *)&String1[32 * (__int64)v81], &byte_1400979C0[256 * (__int64)v79]) )
                  break;
                v81 = v82;
                v83 = v82 == 5;
                if ( v82 >= 5 )
                  goto LABEL_116;
                v79 = dword_1400979BC;
              }
              v83 = v82 == 5;
LABEL_116:
              if ( v83 )
              {
                for ( j = 3; j != -1; --j )
                {
                  v85 = &String1[32 * (__int64)j];
                  do
                  {
                    v86 = *(_BYTE *)v85;
                    *((_BYTE *)v85 + 256) = *(_BYTE *)v85;
                    v85 = (LPARAM *)((char *)v85 + 1);
                  }
                  while ( v86 );
                }
                v79 = dword_1400979BC;
                v87 = &byte_1400979C0[256 * (__int64)dword_1400979BC];
                v88 = (char *)String1 - v87;
                do
                {
                  v89 = *v87;
                  v87[v88] = *v87;
                  ++v87;
                }
                while ( v89 );
              }
              else
              {
                v79 = dword_1400979BC;
              }
            }
            if ( stricmp(&byte_140098DC0[256 * (__int64)v79], (const char *)&unk_1400A6B80 + 256 * (__int64)v79) )
              v72 = 1;
            i = dword_1400979BC + 1;
          }
          if ( v72 )
            InvalidateRgn(*(&qword_1400A2648 + 48 * (unsigned int)ArgList), 0i64, 1);
          v6 = a1;
          break;
        case 2u:
          break;
        case 3u:
          SetDlgItemTextA(v6, 1003, asc_14007BD58);
          SetDlgItemTextA(v6, 1004, (LPCSTR)&WindowName);
          SetDlgItemTextA(v6, 1005, (LPCSTR)&WindowName);
          byte_1400979C0[0] = 0;
          byte_140097AC0 = 0;
          byte_140097BC0 = 0;
          byte_140097CC0 = 0;
          byte_140097DC0 = 0;
          byte_140097EC0 = 0;
          byte_140097FC0 = 0;
          byte_1400980C0 = 0;
          byte_1400981C0 = 0;
          byte_1400982C0 = 0;
          byte_1400983C0 = 0;
          byte_1400984C0 = 0;
          byte_1400985C0 = 0;
          byte_1400986C0 = 0;
          byte_1400987C0 = 0;
          byte_1400988C0 = 0;
          byte_1400989C0 = 0;
          byte_140098AC0 = 0;
          byte_140098BC0 = 0;
          byte_140098CC0 = 0;
          InvalidateRect(v6, 0i64, 1);
          return 1i64;
        default:
          return 0i64;
      }
LABEL_131:
      EndDialog(v6, 1i64);
      return 1i64;
    case 0x10u:
      goto LABEL_131;
    case 0x2Bu:
      if ( *((_DWORD *)a4 + 2) != -1 )
      {
        GetTextMetricsA(*((HDC *)a4 + 4), &tm);
        v39 = (*((_DWORD *)a4 + 11) + *((_DWORD *)a4 + 13) - tm.tmHeight) / 2;
        v40 = (unsigned __int16)GetDialogBaseUnits() >> 2;
        if ( a3 == (HDC)1005 )
        {
          v41 = ((_BYTE)a4[4] & 1) != 0 ? GetSysColor(14) : dword_1400A8080[dword_1400979BC];
          v42 = SetTextColor(*((HDC *)a4 + 4), v41);
          v43 = ((_BYTE)a4[4] & 1) != 0 ? GetSysColor(13) : dword_1400A8020[dword_1400979BC];
          v44 = SetBkColor(*((HDC *)a4 + 4), v43);
          c = lstrlenA(*((LPCSTR *)a4 + 7));
          ExtTextOutA(*((HDC *)a4 + 4), v40, v39, 6u, (const RECT *)(a4 + 10), *((LPCSTR *)a4 + 7), c, 0i64);
        }
        else if ( a3 == (HDC)1032 )
        {
          v46 = 14;
          if ( ((_BYTE)a4[4] & 1) == 0 )
            v46 = 8;
          SysColor = GetSysColor(v46);
          v42 = SetTextColor(*((HDC *)a4 + 4), SysColor);
          if ( ((_BYTE)a4[4] & 1) != 0 )
            v48 = 13;
          else
            v48 = 5;
          v49 = GetSysColor(v48);
          v44 = SetBkColor(*((HDC *)a4 + 4), v49);
          sub_140002490(lParam, "Filter %d", (unsigned int)(*((_DWORD *)a4 + 14) + 1));
          v50 = lstrlenA(lParam);
          ExtTextOutA(*((HDC *)a4 + 4), v40, v39, 6u, (const RECT *)(a4 + 10), lParam, v50, 0i64);
          if ( ((_BYTE)a4[4] & 1) != 0 )
            SendMessageA(a1, 0x400u, 0i64, 1i64);
        }
        else
        {
          v42 = (unsigned int)a1;
          v44 = (unsigned int)a1;
        }
        SetTextColor(*((HDC *)a4 + 4), v42);
        SetBkColor(*((HDC *)a4 + 4), v44);
        if ( ((_BYTE)a4[4] & 0x10) != 0 )
        {
          DrawFocusRect(*((HDC *)a4 + 4), (const RECT *)(a4 + 10));
          return 0i64;
        }
      }
      return 0i64;
  }
  if ( a2 != 272 )
    return 0i64;
  DlgItem = GetDlgItem(a1, 1032);
  dword_1400979BC = 0;
  qword_14009A1D8 = DlgItem;
  for ( k = 0; k < 20; dword_1400979BC = k )
  {
    sub_140002490(lParam, "Filter %d", (unsigned int)(k + 1));
    SendMessageA(qword_14009A1D8, 0x14Au, dword_1400979BC, (LPARAM)lParam);
    SendMessageA(qword_14009A1D8, 0x151u, dword_1400979BC, dword_1400979BC);
    v9 = dword_1400979BC;
    v10 = (__int64)dword_1400979BC << 8;
    v11 = &byte_140098DC0[v10];
    v12 = (char *)&byte_1400A4880 + v10;
    do
    {
      v13 = *v12;
      v12[byte_140098DC0 - (char *)&byte_1400A4880] = *v12;
      ++v12;
    }
    while ( v13 );
    v14 = &byte_1400979C0[v10];
    do
    {
      v15 = *v11;
      v11[byte_1400979C0 - byte_140098DC0] = *v11;
      ++v11;
    }
    while ( v15 );
    if ( !*v14 )
      *(_WORD *)v14 = 32;
    k = v9 + 1;
  }
  SendMessageA(qword_14009A1D8, 0x14Eu, 0i64, 0i64);
  v16 = (LPARAM *)qword_1400A6680;
  v17 = 5i64;
  qword_14009A1C0 = GetDlgItem(v6, 1003);
  v18 = qword_14009A1C0;
  v19 = (LPARAM *)qword_1400A6680;
  v20 = 5i64;
  do
  {
    if ( *(_BYTE *)v16 )
    {
      v21 = *(unsigned __int8 *)v19 - 32;
      if ( *(_BYTE *)v19 == 32 )
        v21 = *((unsigned __int8 *)v19 + 1);
      v22 = &WindowName;
      if ( v21 )
        v22 = v19;
      SendMessageA(v18, 0x143u, 0i64, (LPARAM)v22);
      v18 = qword_14009A1C0;
    }
    v19 += 32;
    v16 += 32;
    --v20;
  }
  while ( v20 );
  v23 = (LPARAM *)qword_1400A6180;
  qword_14009A1C8 = GetDlgItem(a1, 1004);
  v24 = qword_14009A1C8;
  v25 = 5i64;
  v26 = (LPARAM *)qword_1400A6180;
  do
  {
    if ( *(_BYTE *)v23 )
    {
      v27 = *(unsigned __int8 *)v26 - 32;
      if ( *(_BYTE *)v26 == 32 )
        v27 = *((unsigned __int8 *)v26 + 1);
      v28 = &WindowName;
      if ( v27 )
        v28 = v26;
      SendMessageA(v24, 0x143u, 0i64, (LPARAM)v28);
      v24 = qword_14009A1C8;
    }
    v26 += 32;
    v23 += 32;
    --v25;
  }
  while ( v25 );
  v29 = GetDlgItem(a1, 1005);
  qword_14009A1D0 = v29;
  v30 = (unsigned __int8)byte_1400A4880 < 0x20u;
  if ( (_BYTE)byte_1400A4880 != 32 || (v30 = 0, byte_1400A4881) )
    v31 = v30 ? -1 : 1;
  else
    v31 = 0;
  v32 = &byte_1400A4880;
  if ( !v31 )
    v32 = (LPARAM *)&WindowName;
  SendMessageA(v29, 0x143u, 0i64, (LPARAM)v32);
  SendMessageA(qword_14009A1D0, 0x151u, 0i64, (LPARAM)&byte_1400A4880);
  v33 = String1;
  v34 = String1;
  do
  {
    if ( *(_BYTE *)v33 && stricmp((const char *)v34, (const char *)&byte_1400A4880) )
    {
      v35 = *(unsigned __int8 *)v34 - 32;
      if ( *(_BYTE *)v34 == 32 )
        v35 = *((unsigned __int8 *)v34 + 1);
      v36 = &WindowName;
      if ( v35 )
        v36 = v34;
      v37 = SendMessageA(qword_14009A1D0, 0x143u, 0i64, (LPARAM)v36);
      SendMessageA(qword_14009A1D0, 0x151u, v37, (LPARAM)v34);
    }
    v34 += 32;
    v33 += 32;
    --v17;
  }
  while ( v17 );
  dword_1400979BC = 0;
  SendMessageA(qword_14009A1C0, 0x14Eu, 0i64, 0i64);
  SendMessageA(qword_14009A1C8, 0x14Eu, 0i64, 0i64);
  SendMessageA(qword_14009A1D0, 0x14Eu, 0i64, 0i64);
  SetFocus(qword_14009A1C0);
  return 1i64;
}
// 1400979BC: using guessed type int dword_1400979BC;
// 140097AC0: using guessed type char byte_140097AC0;
// 140097BC0: using guessed type char byte_140097BC0;
// 140097CC0: using guessed type char byte_140097CC0;
// 140097DC0: using guessed type char byte_140097DC0;
// 140097EC0: using guessed type char byte_140097EC0;
// 140097FC0: using guessed type char byte_140097FC0;
// 1400980C0: using guessed type char byte_1400980C0;
// 1400981C0: using guessed type char byte_1400981C0;
// 1400982C0: using guessed type char byte_1400982C0;
// 1400983C0: using guessed type char byte_1400983C0;
// 1400984C0: using guessed type char byte_1400984C0;
// 1400985C0: using guessed type char byte_1400985C0;
// 1400986C0: using guessed type char byte_1400986C0;
// 1400987C0: using guessed type char byte_1400987C0;
// 1400988C0: using guessed type char byte_1400988C0;
// 1400989C0: using guessed type char byte_1400989C0;
// 140098AC0: using guessed type char byte_140098AC0;
// 140098BC0: using guessed type char byte_140098BC0;
// 140098CC0: using guessed type char byte_140098CC0;
// 1400A4881: using guessed type char byte_1400A4881;
// 1400A5C80: using guessed type LPARAM String1[160];
// 1400A7F80: using guessed type __int64 qword_1400A7F80[5];
// 1400A8020: using guessed type int dword_1400A8020[];
// 1400A8080: using guessed type int dword_1400A8080[];
// 14000D5D0: using guessed type CHAR lParam[16];

//----- (000000014000E3A0) ----------------------------------------------------
int __fastcall sub_14000E3A0(HWND hWnd, __int64 a2)
{
  int v4; // ebx
  int result; // eax
  FILE *v6; // rax
  FILE *v7; // r14
  int i; // edi
  struct tagOFNA v9; // [rsp+40h] [rbp-2E8h] BYREF
  CHAR String[528]; // [rsp+E0h] [rbp-248h] BYREF

  v9.lStructSize = 152;
  v9.hwndOwner = hWnd;
  v9.hInstance = hInstance;
  v9.lpstrFilter = "DebugView Filters (*.INI)";
  v4 = 0;
  v9.lpstrCustomFilter = 0i64;
  v9.nMaxCustFilter = 0;
  v9.nFilterIndex = 1;
  v9.lpstrFile = aFiltersIni;
  v9.nMaxFile = 256;
  v9.lpstrFileTitle = 0i64;
  v9.nMaxFileTitle = 0;
  v9.lpstrInitialDir = 0i64;
  v9.lpstrTitle = "Open DebugView Filters File...";
  *(_QWORD *)&v9.Flags = 0x200000i64;
  v9.lpstrDefExt = "*.ini";
  v9.lpfnHook = 0i64;
  result = GetOpenFileNameA(&v9);
  if ( result )
  {
    v6 = fopen(aFiltersIni, "r");
    v7 = v6;
    if ( v6 )
    {
      if ( common_fgets<char>(String, 260i64, v6) && !stricmp("DebugView Filter Definition File v1.0\n", String) )
      {
        sub_14000EBB0((__int64)v7, a2, 0x100u);
        sub_14000EBB0((__int64)v7, (__int64)String, 0x100u);
        SetDlgItemTextA(hWnd, 1003, String);
        sub_14000EBB0((__int64)v7, (__int64)String, 0x100u);
        SetDlgItemTextA(hWnd, 1004, String);
        for ( i = 1; i < 20; ++i )
          sub_14000EBB0((__int64)v7, a2 + ((__int64)i << 8), 0x100u);
        while ( v4 < 20 )
        {
          sub_14000EBB0((__int64)v7, (__int64)String, 0x100u);
          sub_14000EF80(String, "%X\n", &dword_1400A8080[v4]);
          sub_14000EBB0((__int64)v7, (__int64)String, 0x100u);
          sub_14000EF80(String, "%X\n", &dword_1400A8020[v4]);
          qword_1400A7F80[v4] = (__int64)CreateSolidBrush(dword_1400A8020[v4]);
          ++v4;
        }
        InvalidateRect(qword_1400A37F8, 0i64, 1);
        InvalidateRect(hWnd, 0i64, 1);
      }
      else
      {
        sub_140002490(String, "%s\nThe file is not a valid DebugView filter definitions file.", aFiltersIni);
        MessageBoxA(hWnd, String, "DebugView", 0x30u);
      }
      return fclose(v7);
    }
    else
    {
      return MessageBoxA(0i64, "Error opening log file.", "Open Error", 0x10u);
    }
  }
  return result;
}
// 1400411C8: using guessed type __int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD);
// 1400A7F80: using guessed type __int64 qword_1400A7F80[5];
// 1400A8020: using guessed type int dword_1400A8020[];
// 1400A8080: using guessed type int dword_1400A8080[];

//----- (000000014000E6F0) ----------------------------------------------------
bool __fastcall sub_14000E6F0(_BYTE *a1)
{
  return !*a1 || *a1 == 42;
}

//----- (000000014000E710) ----------------------------------------------------
__int64 __fastcall sub_14000E710(char *a1)
{
  _BYTE *v2; // r15
  unsigned int v3; // r14d
  char v4; // al
  char *p_Destination; // rdi
  const char *i; // rsi
  char *v7; // rax
  char *v8; // rbp
  size_t v9; // rbx
  __int64 v10; // rax
  const LPARAM *v12; // rcx
  const LPARAM *v13; // r8
  char Buffer[256]; // [rsp+30h] [rbp-238h] BYREF
  char Destination; // [rsp+130h] [rbp-138h] BYREF

  v2 = &unk_1400A6B81;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(v2 - 1);
    if ( v4 )
    {
      if ( v4 != 32 || *v2 )
        break;
    }
LABEL_18:
    ++v3;
    v2 += 256;
    if ( v3 >= 0x14 )
      return 0xFFFFFFFFi64;
  }
  p_Destination = &Destination;
  for ( i = (char *)&unk_1400A6B80 + 256 * (unsigned __int64)v3; ; i = v8 + 1 )
  {
    v7 = strchr(i, 59);
    v8 = v7;
    if ( v7 )
    {
      v9 = (int)v7 - (int)i;
      strncpy(p_Destination, i, v9);
      p_Destination[v9] = 0;
    }
    else
    {
      p_Destination = (char *)i;
    }
    v10 = -1i64;
    while ( p_Destination[++v10] != 0 )
      ;
    v12 = (const LPARAM *)asc_14007BD58;
    v13 = (const LPARAM *)asc_14007BD58;
    if ( p_Destination[v10 - 1] == 42 )
      v12 = &WindowName;
    if ( *p_Destination == 42 )
      v13 = &WindowName;
    sub_140002490(Buffer, "%s%s%s", v13, p_Destination, v12);
    if ( sub_14000EAC0(Buffer, a1) )
      break;
    if ( !v8 )
      goto LABEL_18;
  }
  return v3;
}

//----- (000000014000E890) ----------------------------------------------------
char __fastcall sub_14000E890(char *a1)
{
  const char *v2; // rsi
  char *v3; // rdi
  char *v4; // rax
  char *v5; // rbp
  size_t v6; // rbx
  char v7; // dl
  __int64 v8; // rcx
  bool v9; // zf
  const LPARAM *v10; // rax
  const LPARAM *v11; // r8
  const char *v12; // rsi
  char *v13; // rdi
  char *v14; // rax
  char *v15; // rbp
  size_t v16; // rbx
  char v17; // dl
  __int64 v18; // rax
  const LPARAM *v19; // rcx
  const LPARAM *v20; // r8
  char Buffer[256]; // [rsp+30h] [rbp-228h] BYREF
  char Destination[256]; // [rsp+130h] [rbp-128h] BYREF

  v2 = &Source;
  v3 = Destination;
  while ( 1 )
  {
    v4 = strchr(v2, 59);
    v5 = v4;
    if ( v4 )
    {
      v6 = (int)v4 - (int)v2;
      strncpy(v3, v2, v6);
      v3[v6] = 0;
    }
    else
    {
      v3 = (char *)v2;
    }
    v7 = *v3;
    if ( *v3 && (v7 != 32 || v3[1]) )
    {
      v8 = -1i64;
      do
        v9 = v3[++v8] == 0;
      while ( !v9 );
      v10 = (const LPARAM *)&byte_14007BD58;
      v11 = (const LPARAM *)&byte_14007BD58;
      if ( v3[v8 - 1] == 42 )
        v10 = &WindowName;
      if ( v7 == 42 )
        v11 = &WindowName;
      sub_140002490(Buffer, "%s%s%s", v11, v3, v10);
      if ( sub_14000EAC0(Buffer, a1) )
        return 0;
    }
    if ( !v5 )
      break;
    v2 = v5 + 1;
  }
  v12 = &byte_1400A81E0;
  v13 = Destination;
  while ( 1 )
  {
    v14 = strchr(v12, 59);
    v15 = v14;
    if ( v14 )
    {
      v16 = (int)v14 - (int)v12;
      strncpy(v13, v12, v16);
      v13[v16] = 0;
    }
    else
    {
      v13 = (char *)v12;
    }
    v17 = *v13;
    if ( *v13 )
    {
      if ( v17 != 32 || v13[1] )
      {
        v18 = -1i64;
        do
          v9 = v13[++v18] == 0;
        while ( !v9 );
        v19 = (const LPARAM *)&byte_14007BD58;
        v20 = (const LPARAM *)&byte_14007BD58;
        if ( v13[v18 - 1] == 42 )
          v19 = &WindowName;
        if ( v17 == 42 )
          v20 = &WindowName;
        sub_140002490(Buffer, "%s%s%s", v20, v13, v19);
        if ( sub_14000EAC0(Buffer, a1) )
          break;
      }
    }
    if ( !v15 )
      return 0;
    v12 = v15 + 1;
  }
  return 1;
}

//----- (000000014000EAC0) ----------------------------------------------------
char __fastcall sub_14000EAC0(char *a1, char *a2)
{
  char v2; // r9
  char *v3; // rbx
  char *v4; // rdi
  char v5; // r8
  char v6; // cl
  char v8; // r9
  char v9; // cl

  v2 = *a1;
  v3 = a2;
  v4 = a1;
  if ( !*a1 )
    return 0;
  v5 = *a2;
  while ( v2 != 42 )
  {
    if ( !v5 )
      return sub_14000E6F0(v4);
    while ( 1 )
    {
      v2 = *v4;
      if ( *v4 == 42 )
        break;
      v6 = v5 - 32;
      if ( (unsigned __int8)(v5 - 97) > 0x19u )
        v6 = v5;
      if ( v2 != v6 )
        return 0;
      v5 = *++v3;
      ++v4;
      if ( !v5 )
        return sub_14000E6F0(v4);
    }
  }
  if ( v5 )
  {
    do
    {
      v8 = v4[1];
      if ( !v8 )
        break;
      v9 = *v3 - 32;
      if ( (unsigned __int8)(*v3 - 97) > 0x19u )
        v9 = *v3;
      if ( v8 == v9 && (unsigned __int8)sub_14000EAC0(v4 + 2, v3 + 1) )
        return 1;
      ++v3;
    }
    while ( *v3 );
  }
  return sub_14000E6F0(v4 + 1);
}
// 14000EB39: conditional instruction was optimized away because r8.1!=0
// 14000EB3E: conditional instruction was optimized away because r9.1==2A

//----- (000000014000EBB0) ----------------------------------------------------
__int64 __fastcall sub_14000EBB0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax

  if ( !common_fgets<char>(a2, a3, a1) )
    RaiseException(0, 0, 0, 0i64);
  result = -1i64;
  while ( *(_BYTE *)(a2 + result++ + 1) != 0 )
    ;
  *(_BYTE *)(result + a2 - 1) = 0;
  return result;
}
// 1400411C8: using guessed type __int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD);

//----- (000000014000EC00) ----------------------------------------------------
int __fastcall sub_14000EC00(HWND hDlg, const char *a2)
{
  __int64 v2; // rbx
  int result; // eax
  FILE *v6; // rax
  FILE *v7; // rdi
  const char *v8; // rsi
  __int64 v9; // rbp
  struct tagOFNA v10; // [rsp+20h] [rbp-1C8h] BYREF
  CHAR String[256]; // [rsp+C0h] [rbp-128h] BYREF

  v2 = 0i64;
  v10.hInstance = hInstance;
  v10.hwndOwner = hDlg;
  v10.lpstrFilter = "DebugView Filters (*.INI)";
  v10.lStructSize = 152;
  v10.lpstrTitle = "Save DebugView Filters to File...";
  v10.lpstrCustomFilter = 0i64;
  v10.lpstrDefExt = "*.ini";
  v10.nMaxCustFilter = 0;
  v10.nFilterIndex = 1;
  v10.lpstrFile = aFiltersIni;
  v10.nMaxFile = 256;
  v10.lpstrFileTitle = 0i64;
  v10.nMaxFileTitle = 0;
  v10.lpstrInitialDir = 0i64;
  *(_QWORD *)&v10.Flags = 2097158i64;
  v10.lpfnHook = 0i64;
  result = GetSaveFileNameA(&v10);
  if ( result )
  {
    v6 = fopen(aFiltersIni, "w");
    v7 = v6;
    if ( v6 )
    {
      sub_14000EF30((__int64)v6, (__int64)"DebugView Filter Definition File v1.0\n");
      sub_14000EF30((__int64)v7, (__int64)"%s\n", a2);
      GetDlgItemTextA(hDlg, 1003, String, 256);
      sub_14000EF30((__int64)v7, (__int64)"%s\n", String);
      GetDlgItemTextA(hDlg, 1004, String, 256);
      sub_14000EF30((__int64)v7, (__int64)"%s\n", String);
      v8 = a2 + 256;
      v9 = 19i64;
      do
      {
        sub_14000EF30((__int64)v7, (__int64)"%s\n", v8);
        v8 += 256;
        --v9;
      }
      while ( v9 );
      do
      {
        sub_14000EF30((__int64)v7, (__int64)"%X\n", (unsigned int)dword_1400A8080[v2]);
        sub_14000EF30((__int64)v7, (__int64)"%X\n", (unsigned int)dword_1400A8020[v2++]);
      }
      while ( v2 < 20 );
      return fclose(v7);
    }
    else
    {
      return MessageBoxA(0i64, "Create File Failed.", "Save Error", 0x10u);
    }
  }
  return result;
}
// 1400A8020: using guessed type int dword_1400A8020[];
// 1400A8080: using guessed type int dword_1400A8080[];

//----- (000000014000EE30) ----------------------------------------------------
BOOL __fastcall sub_14000EE30(HWND hWnd, unsigned int a2)
{
  struct tagCHOOSECOLORA v4; // [rsp+20h] [rbp-A8h] BYREF
  _QWORD v5[7]; // [rsp+70h] [rbp-58h] BYREF
  int v6; // [rsp+A8h] [rbp-20h]

  v4.hwndOwner = hWnd;
  v5[0] = 0xFFFFFF00FFFFFFi64;
  v5[1] = 0xFFFFFF00FFFFFFi64;
  v5[2] = 0xFFFFFF00FFFFFFi64;
  v5[3] = 0xFFFFFF00FFFFFFi64;
  v5[4] = 0xFFFFFF00FFFFFFi64;
  v5[5] = 0xFFFFFF00FFFFFFi64;
  v5[6] = 0xFFFFFF00FFFFFFi64;
  v6 = 0xFFFFFF;
  v4.hInstance = (HWND)hInstance;
  v4.lpCustColors = (COLORREF *)v5;
  v4.lStructSize = 72;
  v4.lCustData = a2;
  v4.rgbResult = dword_1400A8080[a2];
  v4.lpTemplateName = "CHOOSECOLORFG";
  v4.lpfnHook = (LPCCHOOKPROC)sub_14000D370;
  v4.Flags = 53;
  ChooseColorA(&v4);
  InvalidateRect(hWnd, 0i64, 1);
  return InvalidateRect(qword_1400A37F8, 0i64, 1);
}
// 1400A8080: using guessed type int dword_1400A8080[];

//----- (000000014000EF20) ----------------------------------------------------
void *sub_14000EF20()
{
  return &unk_14009CC88;
}

//----- (000000014000EF30) ----------------------------------------------------
__int64 sub_14000EF30(__int64 a1, __int64 a2, ...)
{
  __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, a2);
  v4 = (__int64 *)sub_140002420();
  return sub_14003B384(*v4, a1, a2, 0i64, (__int64)va);
}

//----- (000000014000EF80) ----------------------------------------------------
int sub_14000EF80(char *Buffer, char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_14000EF20();
  return _stdio_common_vsscanf(*v4, Buffer, 0xFFFFFFFFFFFFFFFFui64, Format, 0i64, va);
}

//----- (000000014000EFE0) ----------------------------------------------------
SC_HANDLE __fastcall sub_14000EFE0(SC_HANDLE a1, const CHAR *a2, const CHAR *lpBinaryPathName)
{
  SC_HANDLE result; // rax

  result = CreateServiceA(a1, a2, a2, 0xF01FFu, 0x10u, 3u, 1u, lpBinaryPathName, 0i64, 0i64, 0i64, 0i64, 0i64);
  if ( result )
  {
    CloseServiceHandle(result);
    return (SC_HANDLE)1;
  }
  return result;
}

//----- (000000014000F050) ----------------------------------------------------
__int64 __fastcall sub_14000F050(const CHAR *a1, const CHAR *a2, const CHAR *a3)
{
  SC_HANDLE v5; // rax
  SC_HANDLE v6; // rdi
  unsigned int v8; // ebx

  v5 = OpenSCManagerA(a1, 0i64, 0xF003Fu);
  v6 = v5;
  if ( !v5 )
    return 0i64;
  sub_14000F100(v5, a2);
  if ( !(unsigned int)sub_14000EFE0(v6, a2, a3) )
  {
    GetLastError();
    if ( GetLastError() != 52 && GetLastError() != 1073 )
    {
      CloseServiceHandle(v6);
      return 0i64;
    }
  }
  v8 = (unsigned int)sub_14000F150(v6, a2);
  CloseServiceHandle(v6);
  return v8;
}

//----- (000000014000F100) ----------------------------------------------------
SC_HANDLE __fastcall sub_14000F100(SC_HANDLE a1, const CHAR *a2)
{
  SC_HANDLE result; // rax
  SC_HANDLE v3; // rdi
  unsigned int v4; // ebx

  result = OpenServiceA(a1, a2, 0xF01FFu);
  v3 = result;
  if ( result )
  {
    v4 = DeleteService(result);
    CloseServiceHandle(v3);
    return (SC_HANDLE)v4;
  }
  return result;
}

//----- (000000014000F150) ----------------------------------------------------
SC_HANDLE __fastcall sub_14000F150(SC_HANDLE hSCManager, LPCSTR lpServiceName)
{
  DWORD TickCount; // edi
  SC_HANDLE result; // rax
  unsigned int v6; // ebx
  struct _SERVICE_STATUS ServiceStatus; // [rsp+20h] [rbp-38h] BYREF

  TickCount = GetTickCount();
  if ( hSCObject )
    CloseServiceHandle(hSCObject);
  result = OpenServiceA(hSCManager, lpServiceName, 0xF01FFu);
  hSCObject = result;
  if ( result )
  {
    if ( (StartServiceA(result, 0, 0i64) || GetLastError() == 1056)
      && (v6 = 1, QueryServiceStatus(hSCObject, &ServiceStatus)) )
    {
      while ( ServiceStatus.dwCurrentState != 4 )
      {
        if ( ServiceStatus.dwCurrentState == 1 )
          goto LABEL_13;
        if ( GetTickCount() - TickCount > 0xEA60 )
        {
          SetLastError(0x41Du);
          goto LABEL_13;
        }
        if ( !QueryServiceStatus(hSCObject, &ServiceStatus) )
          goto LABEL_13;
      }
    }
    else
    {
LABEL_13:
      v6 = 0;
    }
    CloseServiceHandle(hSCObject);
    result = (SC_HANDLE)v6;
    hSCObject = 0i64;
  }
  return result;
}

//----- (000000014000F270) ----------------------------------------------------
SC_HANDLE __fastcall sub_14000F270(SC_HANDLE a1, const CHAR *a2)
{
  SC_HANDLE result; // rax
  SC_HANDLE v3; // rbx
  unsigned int v4; // edi
  struct _SERVICE_STATUS ServiceStatus; // [rsp+20h] [rbp-38h] BYREF

  result = OpenServiceA(a1, a2, 0xF01FFu);
  v3 = result;
  if ( result )
  {
    v4 = ControlService(result, 1u, &ServiceStatus);
    if ( QueryServiceStatus(v3, &ServiceStatus) )
    {
      while ( ServiceStatus.dwCurrentState != 1 && QueryServiceStatus(v3, &ServiceStatus) )
        ;
    }
    CloseServiceHandle(v3);
    return (SC_HANDLE)v4;
  }
  return result;
}

//----- (000000014000F320) ----------------------------------------------------
__int64 __fastcall sub_14000F320(const CHAR *a1, const CHAR *a2)
{
  SC_HANDLE v3; // rbx

  v3 = OpenSCManagerA(a1, 0i64, 0xF003Fu);
  sub_14000F270(v3, a2);
  sub_14000F100(v3, a2);
  CloseServiceHandle(v3);
  return 1i64;
}

//----- (000000014000F370) ----------------------------------------------------
LRESULT __fastcall sub_14000F370(HWND hWnd, UINT Msg, WPARAM wParam, const __m128i *lParam)
{
  UINT v6; // edi
  HDC v8; // rbx
  HDC DC; // rbx
  int v10; // eax
  int v11; // edx
  DWORD TickCount; // eax
  struct tagPOINT Point; // [rsp+30h] [rbp-98h] BYREF
  struct tagPAINTSTRUCT Paint; // [rsp+40h] [rbp-88h] BYREF

  v6 = Msg;
  if ( Msg <= 0x10 )
  {
    switch ( Msg )
    {
      case 0x10u:
        DestroyWindow(hWnd);
        break;
      case 2u:
        qword_1400935C8 = 0i64;
        break;
      case 0xFu:
        v8 = BeginPaint(hWnd, &Paint);
        SetTextColor(v8, 0);
        SetBkMode(v8, v6 - 14);
        SelectObject(v8, ::wParam);
        DrawTextA(v8, chText, v6 - 16, &rc, dword_14009B240 | 0x910);
        EndPaint(hWnd, &Paint);
        break;
    }
    return DefWindowProcA(hWnd, v6, wParam, (LPARAM)lParam);
  }
  if ( Msg < 0x201 )
    return DefWindowProcA(hWnd, v6, wParam, (LPARAM)lParam);
  if ( Msg <= 0x209 )
  {
    Point.x = (__int16)lParam;
    Point.y = SWORD1(lParam);
    ClientToScreen(hWnd, &Point);
    if ( ScreenToClient(qword_1400A37F8, &Point) )
    {
      if ( v6 == 513 )
      {
        TickCount = GetTickCount();
        if ( Point == qword_14009A1F8 && TickCount - dword_14009A1F4 < 0x12C )
          v6 = 515;
        dword_14009A1F4 = TickCount;
        qword_14009A1F8 = (__int64)Point;
      }
      PostMessageA(qword_1400A37F8, v6, wParam, SLOWORD(Point.x) | (unsigned __int64)(SLOWORD(Point.y) << 16));
    }
    return DefWindowProcA(hWnd, v6, wParam, (LPARAM)lParam);
  }
  if ( Msg != 1024 )
    return DefWindowProcA(hWnd, v6, wParam, (LPARAM)lParam);
  sub_1400161F0((__m128i *)chText, lParam, 0x1030ui64);
  DC = GetDC(hWnd);
  if ( GetFocus()
    && (rc.right = dword_14009B228 - dword_14009B220,
        rc.bottom = dword_14009B22C - dword_14009B224,
        rc.left = 0,
        rc.top = 1,
        SelectObject(DC, ::wParam),
        DrawTextA(DC, chText, -1, &rc, 0xD00u),
        dword_14009B228 <= rc.right + 3) )
  {
    v10 = 0;
    rc.left = 0;
    if ( rc.right + 3 > dword_14009A1F0 )
      v10 = 16;
    rc.top = 1;
    dword_14009B240 = v10;
    rc.right = dword_14009B228 - dword_14009B220;
    rc.bottom = dword_14009B22C - dword_14009B224;
    SelectObject(DC, ::wParam);
    DrawTextA(DC, chText, -1, &rc, dword_14009B240 | 0xD00);
    v11 = dword_14009B220;
    if ( rc.right + dword_14009B220 + 5 > dword_14009A1F0 )
    {
      v11 = dword_14009A1F0 - rc.right - 10;
      dword_14009B220 = v11;
    }
    MoveWindow(hWnd, v11 - 1, dword_14009B224, rc.right + 6, rc.bottom + 1, 1);
    rc.left += 2;
    rc.right += 2;
    --rc.top;
    InvalidateRect(hWnd, 0i64, 1);
    ShowWindow(hWnd, 4);
    ReleaseDC(hWnd, DC);
    return 0i64;
  }
  else
  {
    ReleaseDC(hWnd, DC);
    ShowWindow(hWnd, 0);
    return -1i64;
  }
}
// 14009A1F0: using guessed type int dword_14009A1F0;
// 14009A1F4: using guessed type int dword_14009A1F4;
// 14009A1F8: using guessed type __int64 qword_14009A1F8;
// 14009B220: using guessed type int dword_14009B220;
// 14009B228: using guessed type int dword_14009B228;
// 14009B22C: using guessed type int dword_14009B22C;
// 14009B240: using guessed type int dword_14009B240;

//----- (000000014000F740) ----------------------------------------------------
__int64 __fastcall sub_14000F740(HWND hWnd, unsigned int a2)
{
  unsigned int v4; // r15d
  unsigned int v5; // ebx
  int v6; // esi
  int v8[4]; // [rsp+20h] [rbp-198h] BYREF
  LPARAM lParam; // [rsp+30h] [rbp-188h] BYREF
  int v10; // [rsp+38h] [rbp-180h]
  char *v11; // [rsp+48h] [rbp-170h]
  int v12; // [rsp+50h] [rbp-168h]
  char Buffer[256]; // [rsp+80h] [rbp-138h] BYREF

  v4 = -1;
  v5 = SendMessageA(hWnd, 0x1004u, 0i64, 0i64);
  v6 = -1;
  if ( (int)(v5 + 1) > 1 )
  {
    do
    {
      v10 = 0;
      v12 = 256;
      v11 = Buffer;
      SendMessageA(hWnd, 0x102Du, (int)(v6 + v5) / 2, (LPARAM)&lParam);
      sub_14000EF80(Buffer, "%d", v8);
      if ( a2 > v8[0] )
        v6 = (int)(v6 + v5) / 2;
      else
        v5 = (int)(v6 + v5) / 2;
    }
    while ( (int)(v5 - v6) > 1 );
  }
  v11 = Buffer;
  v10 = 0;
  v12 = 256;
  SendMessageA(hWnd, 0x102Du, (int)v5, (LPARAM)&lParam);
  sub_14000EF80(Buffer, "%d", v8);
  if ( a2 < v8[0] )
    return v5;
  return v4;
}

//----- (000000014000F890) ----------------------------------------------------
__int64 __fastcall sub_14000F890(HDC hdc, char *Source, int a3, int a4)
{
  SIZE_T v4; // rdi
  unsigned int v5; // ebp
  HANDLE ProcessHeap; // rax
  __int64 result; // rax
  char *v10; // rbx
  __int64 v11; // rax
  int v12; // edi
  int v13; // eax
  __int64 v14; // rdi
  int v15; // eax
  int v16; // eax
  int v17; // eax
  HANDLE v18; // rax
  char *v19; // rsi
  HANDLE v20; // rax
  HANDLE v21; // rax
  HANDLE v22; // rax
  struct tagSIZE psizl; // [rsp+20h] [rbp-38h] BYREF
  struct tagSIZE v24; // [rsp+28h] [rbp-30h] BYREF
  struct tagSIZE v25; // [rsp+30h] [rbp-28h] BYREF
  struct tagSIZE v26; // [rsp+38h] [rbp-20h] BYREF

  v4 = a3;
  v5 = a4 - 4;
  ProcessHeap = GetProcessHeap();
  result = (__int64)HeapAlloc(ProcessHeap, 8u, v4);
  v10 = (char *)result;
  if ( result )
  {
    v11 = -1i64;
    do
      ++v11;
    while ( String2[v11] );
    v12 = v4 - v11;
    strncpy(v10, Source, v12 - 2i64);
    v10[v12 - 2] = 0;
    v13 = lstrlenA(v10);
    v14 = v13;
    if ( !GetTextExtentPoint32A(hdc, v10, v13, &psizl) )
      goto LABEL_9;
    if ( psizl.cx <= v5 )
    {
      v22 = GetProcessHeap();
      HeapFree(v22, 0, v10);
      return 1i64;
    }
    else
    {
      v15 = lstrlenA(String2);
      if ( !GetTextExtentPoint32A(hdc, String2, v15, &v24)
        || (v16 = lstrlenA(asc_14009296C), !GetTextExtentPoint32A(hdc, asc_14009296C, v16, &v25))
        || (v17 = lstrlenA(asc_140092970), !GetTextExtentPoint32A(hdc, asc_140092970, v17, &v26)) )
      {
LABEL_9:
        v18 = GetProcessHeap();
        HeapFree(v18, 0, v10);
        return 0i64;
      }
      if ( (int)v14 <= 0 )
      {
LABEL_15:
        *v10 = *Source;
        if ( psizl.cx + v24.cx > v5 )
        {
          if ( psizl.cx + v25.cx > v5 )
          {
            if ( psizl.cx + v26.cx > v5 )
              *v10 = *Source;
            else
              lstrcatA(v10, asc_140092970);
          }
          else
          {
            lstrcatA(v10, asc_14009296C);
          }
        }
        else
        {
          lstrcatA(v10, String2);
        }
        lstrcpyA(Source, v10);
        v21 = GetProcessHeap();
        HeapFree(v21, 0, v10);
        return 1i64;
      }
      else
      {
        v19 = &v10[v14];
        while ( 1 )
        {
          LODWORD(v14) = v14 - 1;
          *--v19 = 0;
          if ( !GetTextExtentPoint32A(hdc, v10, v14, &psizl) )
            break;
          if ( v24.cx + psizl.cx <= v5 || (int)v14 <= 0 )
            goto LABEL_15;
        }
        v20 = GetProcessHeap();
        HeapFree(v20, 0, v10);
        return 0i64;
      }
    }
  }
  return result;
}

//----- (000000014000FB00) ----------------------------------------------------
int __fastcall sub_14000FB00(HWND a1)
{
  int result; // eax
  WPARAM v3; // rdi
  char *v4; // rdx
  bool v5; // zf
  __int64 v6; // rsi
  unsigned int v7; // esi
  char *v8; // rbx
  HGLOBAL v9; // r14
  signed __int64 v10; // rax
  char v11; // cl
  int i; // eax
  WPARAM v13; // rbp
  char *v14; // rax
  __int64 v15; // rdi
  unsigned int v16; // edi
  char *v17; // rbx
  char *v18; // rcx
  char v19; // al
  _BYTE v20[32]; // [rsp+0h] [rbp-20D8h] BYREF
  LPARAM lParam; // [rsp+20h] [rbp-20B8h] BYREF
  int v22; // [rsp+28h] [rbp-20B0h]
  char *v23; // [rsp+38h] [rbp-20A0h]
  int v24; // [rsp+40h] [rbp-2098h]
  char v25[8256]; // [rsp+70h] [rbp-2068h] BYREF

  result = SendMessageA(qword_1400A37F8, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( result != -1 )
  {
    v3 = result;
    v23 = v25;
    v22 = 2;
    v24 = 4128;
    SendMessageA(qword_1400A37F8, 0x102Du, result, (LPARAM)&lParam);
    v4 = &v20[111];
    do
      v5 = *++v4 == 0;
    while ( !v5 );
    strcpy(v4, "\r\n");
    result = OpenClipboard(a1);
    if ( result )
    {
      EmptyClipboard();
      v6 = -1i64;
      do
        ++v6;
      while ( v25[v6] );
      v7 = v6 + 1;
      v8 = v25;
      v9 = GlobalAlloc(0x2002u, v7);
      v10 = (_BYTE *)GlobalLock(v9) - v25;
      do
      {
        v11 = *v8;
        v8[v10] = *v8;
        ++v8;
      }
      while ( v11 );
      GlobalUnlock(v9);
      for ( i = SendMessageA(qword_1400A37F8, 0x100Cu, v3, 2i64);
            i != -1;
            i = SendMessageA(qword_1400A37F8, 0x100Cu, v13, 2i64) )
      {
        v13 = i;
        v23 = v25;
        v22 = 2;
        v24 = 8256;
        SendMessageA(qword_1400A37F8, 0x102Du, i, (LPARAM)&lParam);
        v14 = &v20[111];
        do
          v5 = *++v14 == 0;
        while ( !v5 );
        v15 = -1i64;
        strcpy(v14, "\r\n");
        do
          ++v15;
        while ( v25[v15] );
        v16 = v7 + v15;
        v17 = v25;
        v9 = GlobalReAlloc(v9, v16, 0);
        v18 = (char *)GlobalLock(v9) + v7 - 1 - (_QWORD)v25;
        do
        {
          v19 = *v17;
          v17[(_QWORD)v18] = *v17;
          ++v17;
        }
        while ( v19 );
        GlobalUnlock(v9);
        v7 = v16;
      }
      SetClipboardData(1u, v9);
      return CloseClipboard();
    }
  }
  return result;
}
// 14000FB00: using guessed type char var_2068[8256];

//----- (000000014000FDA0) ----------------------------------------------------
HWND __fastcall sub_14000FDA0(HWND hWndParent)
{
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ebx
  HWND Window; // rax
  HWND v7; // rsi
  char **i; // rdi
  LPARAM lParam; // [rsp+60h] [rbp-48h] BYREF
  int v11; // [rsp+68h] [rbp-40h]
  char *v12; // [rsp+70h] [rbp-38h]
  int v13; // [rsp+7Ch] [rbp-2Ch]
  struct tagRECT Rect; // [rsp+88h] [rbp-20h] BYREF

  InitCommonControls();
  dword_14009A1F0 = GetSystemMetrics(78);
  if ( !dword_14009A1F0 )
    dword_14009A1F0 = GetSystemMetrics(16);
  v2 = dword_1400A8314;
  if ( (unsigned int)(dword_1400A8314 - 1) > 0xBB7 )
  {
    v2 = dword_140092980;
    dword_1400A8314 = dword_140092980;
  }
  dword_140092980 = v2;
  v3 = dword_1400A8318;
  if ( (unsigned int)(dword_1400A8318 - 1) > 0xBB7 )
  {
    v3 = dword_140092990;
    dword_1400A8318 = dword_140092990;
  }
  dword_140092990 = v3;
  v4 = qword_1400A831C;
  if ( (unsigned int)(qword_1400A831C - 1) > 0xBB7 )
  {
    v4 = dword_1400929A0;
    LODWORD(qword_1400A831C) = dword_1400929A0;
  }
  dword_1400929A0 = v4;
  GetClientRect(hWndParent, &Rect);
  v5 = 0;
  Window = CreateWindowExA(
             0,
             "SysListView32",
             (LPCSTR)&WindowName,
             0x50800401u,
             0,
             byte_1400921CD != 0 ? 0x1C : 0,
             Rect.right - Rect.left,
             Rect.bottom - (byte_1400921CD != 0 ? 0x1C : 0) - Rect.top,
             hWndParent,
             (HMENU)0x3E8,
             hInstance,
             0i64);
  v7 = Window;
  if ( Window )
  {
    SendMessageA(Window, 0x30u, (WPARAM)wParam, 0i64);
    lParam = 15i64;
    for ( i = &off_140092978; ; i += 2 )
    {
      v11 = *((_DWORD *)i + 2);
      v12 = *i;
      v13 = v5;
      if ( (unsigned int)SendMessageA(v7, 0x101Bu, v5, (LPARAM)&lParam) == -1 )
        break;
      if ( (unsigned int)++v5 >= 3 )
      {
        SendMessageA(v7, 0x1036u, 0x20ui64, 32i64);
        lpPrevWndFunc = (WNDPROC)SetWindowLongPtrA(v7, -4, (LONG_PTR)sub_140011350);
        return v7;
      }
    }
  }
  return 0i64;
}
// 1400921CD: using guessed type char byte_1400921CD;
// 140092978: using guessed type char *off_140092978;
// 140092980: using guessed type int dword_140092980;
// 140092990: using guessed type int dword_140092990;
// 1400929A0: using guessed type int dword_1400929A0;
// 14009A1F0: using guessed type int dword_14009A1F0;
// 1400A8314: using guessed type int dword_1400A8314;
// 1400A8318: using guessed type int dword_1400A8318;
// 1400A831C: using guessed type __int64 qword_1400A831C;

//----- (000000014000FFD0) ----------------------------------------------------
BOOL __fastcall sub_14000FFD0(HDC a1, const CHAR *a2, const RECT *a3)
{
  int c; // eax
  CHAR String1[8256]; // [rsp+40h] [rbp-2058h] BYREF

  lstrcpyA(String1, a2);
  sub_14000F890(a1, String1, 8256, a3->right - a3->left);
  c = lstrlenA(String1);
  return ExtTextOutA(a1, a3->left + 2, a3->top + 1, 6u, a3, String1, c, 0i64);
}

//----- (0000000140010090) ----------------------------------------------------
int __fastcall sub_140010090(__int64 a1)
{
  int v1; // eax
  HWND v3; // rcx
  WPARAM v4; // r8
  bool v5; // zf
  DWORD SysColor; // eax
  int v7; // ecx
  unsigned int v8; // eax
  __int64 v9; // rbx
  DWORD v10; // edx
  DWORD v11; // eax
  int v12; // esi
  int i; // ebx
  int v14; // eax
  int v15; // edx
  int v16; // r14d
  const CHAR *v17; // rdx
  WPARAM v18; // r8
  int v19; // ecx
  __int64 v20; // rax
  char v21; // dl
  int v22; // eax
  int result; // eax
  DWORD v24; // eax
  DWORD v25; // eax
  HDC v26; // rcx
  LPARAM v27; // [rsp+20h] [rbp-E0h] BYREF
  int v28; // [rsp+28h] [rbp-D8h]
  __int16 *v29; // [rsp+38h] [rbp-C8h]
  int v30; // [rsp+40h] [rbp-C0h]
  _DWORD lParam[20]; // [rsp+70h] [rbp-90h] BYREF
  RECT rc; // [rsp+C0h] [rbp-40h] BYREF
  __int16 v33[4128]; // [rsp+D0h] [rbp-30h] BYREF
  char v34[8256]; // [rsp+2110h] [rbp+2010h] BYREF

  v1 = *(_DWORD *)(a1 + 8);
  lParam[0] = 10;
  v3 = *(HWND *)(a1 + 24);
  lParam[2] = 0;
  lParam[1] = v1;
  SendMessageA(v3, 0x1005u, 0i64, (LPARAM)lParam);
  v4 = *(unsigned int *)(a1 + 8);
  v29 = (__int16 *)v34;
  v28 = 2;
  v30 = 8256;
  SendMessageA(qword_1400A37F8, 0x102Du, v4, (LPARAM)&v27);
  v5 = (*(_BYTE *)(a1 + 16) & 1) == 0;
  v34[8255] = 0;
  if ( !v5 )
  {
    SysColor = GetSysColor(14);
    SetTextColor(*(HDC *)(a1 + 32), SysColor);
    v7 = 13;
LABEL_6:
    v10 = GetSysColor(v7);
    goto LABEL_7;
  }
  v8 = sub_14000E710(v34);
  if ( v8 == -1 )
  {
    v11 = GetSysColor(8);
    SetTextColor(*(HDC *)(a1 + 32), v11);
    v7 = 5;
    goto LABEL_6;
  }
  v9 = v8;
  SetTextColor(*(HDC *)(a1 + 32), dword_1400A8080[v9]);
  v10 = dword_1400A8020[v9];
LABEL_7:
  SetBkColor(*(HDC *)(a1 + 32), v10);
  v12 = 0;
  for ( i = 0; i < 3; ++i )
  {
    v14 = SendMessageA(qword_1400A37F8, 0x101Du, i, 0i64);
    v15 = *(_DWORD *)(a1 + 40);
    v16 = v14;
    rc.left = v15 + v12;
    rc.right = v12 + v15 + v14;
    rc.top = *(_DWORD *)(a1 + 44);
    rc.bottom = *(_DWORD *)(a1 + 52);
    if ( i == 2 )
    {
      v17 = v34;
    }
    else
    {
      v18 = *(unsigned int *)(a1 + 8);
      v29 = v33;
      v30 = 8256;
      if ( i )
      {
        v28 = i;
        SendMessageA(qword_1400A37F8, 0x102Du, v18, (LPARAM)&v27);
        v17 = (const CHAR *)v33;
      }
      else
      {
        v28 = 0;
        SendMessageA(qword_1400A37F8, 0x102Du, v18, (LPARAM)&v27);
        v19 = 0;
        v20 = 0i64;
        if ( LOBYTE(v33[0]) == 48 )
        {
          do
          {
            ++v20;
            ++v19;
          }
          while ( *((_BYTE *)v33 + v20) == 48 );
        }
        v21 = *((_BYTE *)v33 + v20);
        if ( !v21 )
          v33[0] = 48;
        v22 = 0;
        if ( v21 )
          v22 = v19;
        v17 = (char *)v33 + v22;
      }
    }
    sub_14000FFD0(*(HDC *)(a1 + 32), v17, &rc);
    v12 += v16;
  }
  result = *(_DWORD *)(a1 + 16);
  if ( (result & 1) != 0 )
  {
    v24 = GetSysColor(8);
    SetTextColor(*(HDC *)(a1 + 32), v24);
    v25 = GetSysColor(5);
    SetBkColor(*(HDC *)(a1 + 32), v25);
    result = *(_DWORD *)(a1 + 16);
  }
  if ( (result & 0x10) != 0 )
  {
    v26 = *(HDC *)(a1 + 32);
    rc = *(RECT *)(a1 + 40);
    return DrawFocusRect(v26, &rc);
  }
  return result;
}
// 1400A8020: using guessed type int dword_1400A8020[];
// 1400A8080: using guessed type int dword_1400A8080[];

//----- (0000000140010340) ----------------------------------------------------
char __fastcall sub_140010340(HWND a1, __int64 a2)
{
  unsigned __int8 v4; // r13
  HWND v5; // rcx
  _BYTE *v6; // r15
  int v7; // r14d
  unsigned __int8 *v8; // rax
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  HWND v12; // rcx
  int v13; // esi
  const char *v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rax
  __int64 v17; // rbx
  char v18; // al
  __int64 v20; // rax
  __int64 v21; // r8
  const char *v22; // rax
  size_t v23; // r8
  __int64 v25; // rax
  __int64 v26; // rdx
  __int64 v27; // rax
  char *v29; // rcx
  char v30; // al
  int i; // eax
  int v32; // [rsp+20h] [rbp-E0h]
  LPARAM lParam; // [rsp+30h] [rbp-D0h] BYREF
  int v35; // [rsp+38h] [rbp-C8h]
  int v36; // [rsp+3Ch] [rbp-C4h]
  int v37; // [rsp+40h] [rbp-C0h]
  char *v38; // [rsp+48h] [rbp-B8h]
  int v39; // [rsp+50h] [rbp-B0h]
  CHAR Text[256]; // [rsp+80h] [rbp-80h] BYREF
  char String1[8256]; // [rsp+180h] [rbp+80h] BYREF

  v4 = *(_BYTE *)(a2 + 24) & 1;
  v32 = SendMessageA(qword_1400A37F8, 0x1004u, 0i64, 0i64);
  if ( !v32 )
  {
    MessageBoxA(a1, "No items to search", "DebugView", 0x30u);
    v5 = qword_140093590;
    if ( !qword_140093590 )
      return 0;
LABEL_3:
    SetForegroundWindow(v5);
    return 0;
  }
  v6 = byte_14009E4E0;
  v7 = SendMessageA(qword_1400A37F8, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( v7 == -1 )
  {
    if ( !v4 )
    {
      if ( byte_14009F500 )
      {
LABEL_18:
        sub_140002490(Text, "Cannot find string \"%s\"", *(const char **)(a2 + 32));
        v12 = a1;
LABEL_55:
        MessageBoxA(v12, Text, "DebugView", 0x30u);
        v5 = qword_140093590;
        if ( !qword_140093590 )
        {
          SetFocus(qword_1400A37F8);
          return 0;
        }
        goto LABEL_3;
      }
      v7 = v32;
      goto LABEL_20;
    }
    v7 = 0;
  }
  if ( byte_14009F500 )
  {
    v8 = byte_14009F580;
    do
    {
      v9 = v8[byte_14009E4E0 - byte_14009F580];
      v10 = *v8 - v9;
      if ( v10 )
        break;
      ++v8;
    }
    while ( v9 );
    if ( !v10 )
    {
      v11 = v7 + 2 * v4 - 1;
      if ( !v4 && v11 < 0 )
        goto LABEL_18;
      v7 += 2 * v4 - 1;
      if ( v4 )
      {
        if ( v11 >= v32 )
          goto LABEL_18;
      }
    }
  }
LABEL_20:
  v13 = 2;
  while ( 1 )
  {
    v38 = String1;
    String1[0] = 0;
    v35 = v13;
    v39 = 8256;
    SendMessageA(qword_1400A37F8, 0x102Du, v7, (LPARAM)&lParam);
    v14 = *(const char **)(a2 + 32);
    v15 = -1i64;
    do
      ++v15;
    while ( String1[v15] );
    v16 = -1i64;
    do
      ++v16;
    while ( v14[v16] );
    if ( v15 >= v16 )
    {
      LODWORD(v17) = 0;
      if ( (*(_BYTE *)(a2 + 24) & 2) != 0 )
      {
        v18 = String1[0];
        if ( String1[0] )
        {
          while ( 1 )
          {
            do
            {
              if ( v18 == 32 )
                break;
              v17 = (unsigned int)(v17 + 1);
              v18 = String1[v17];
            }
            while ( v18 );
            if ( (*(_BYTE *)(a2 + 24) & 4) != 0
               ? strcmp(String1, *(const char **)(a2 + 32)) == 0
               : stricmp(String1, *(const char **)(a2 + 32)) == 0 )
            {
              goto LABEL_58;
            }
            v17 = (unsigned int)(v17 + 1);
            v18 = String1[v17];
            if ( !v18 )
              goto LABEL_51;
          }
        }
        goto LABEL_51;
      }
      v20 = -1i64;
      do
        ++v20;
      while ( v14[v20] );
      if ( v15 - v20 != -1i64 )
        break;
    }
LABEL_51:
    if ( ++v13 >= 3 )
    {
      v7 = v7 + 2 * v4 - 1;
      if ( v7 <= 0 || v7 == v32 + 1 )
      {
        sub_140002490(Text, "Cannot find string \"%s\"", *(const char **)(a2 + 32));
        v12 = a1;
        goto LABEL_55;
      }
      goto LABEL_20;
    }
  }
  v21 = 0i64;
  while ( 1 )
  {
    v22 = &String1[v21];
    v23 = -1i64;
    do
      ++v23;
    while ( v14[v23] );
    if ( !((*(_BYTE *)(a2 + 24) & 4) != 0 ? strncmp(v22, v14, v23) : strnicmp(v22, v14, v23)) )
      break;
    v14 = *(const char **)(a2 + 32);
    LODWORD(v17) = v17 + 1;
    v21 = (unsigned int)v17;
    v25 = -1i64;
    do
      ++v25;
    while ( v14[v25] );
    v26 = 1 - v25;
    v27 = -1i64;
    do
      ++v27;
    while ( String1[v27] );
    if ( (unsigned int)v17 >= (unsigned __int64)(v27 + v26) )
      goto LABEL_51;
  }
LABEL_58:
  v29 = *(char **)(a2 + 32);
  do
  {
    v30 = *v29++;
    *v6++ = v30;
  }
  while ( v30 );
  byte_14009F500 = 1;
  for ( i = SendMessageA(qword_1400A37F8, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
        i != -1;
        i = SendMessageA(qword_1400A37F8, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64) )
  {
    v37 = 3;
    v36 = 0;
    SendMessageA(qword_1400A37F8, 0x102Bu, i, (LPARAM)&lParam);
  }
  v37 = 3;
  v36 = 3;
  SendMessageA(qword_1400A37F8, 0x102Bu, v7, (LPARAM)&lParam);
  SendMessageA(qword_1400A37F8, 0x1013u, v7, 0i64);
  SetFocus(qword_1400A37F8);
  return 1;
}
// 14009E4E0: using guessed type _BYTE byte_14009E4E0[4128];
// 14009F500: using guessed type char byte_14009F500;
// 14009F580: using guessed type _BYTE byte_14009F580[4128];
// 140010340: using guessed type char String1[8256];

//----- (0000000140010800) ----------------------------------------------------
INT_PTR __fastcall sub_140010800(HWND a1, int a2, __int16 a3)
{
  HWND v3; // rbx
  int v4; // edx
  int v5; // edx
  HWND DlgItem; // rax
  int v8[4]; // [rsp+20h] [rbp-68h] BYREF
  CHAR String[64]; // [rsp+30h] [rbp-58h] BYREF

  v3 = a1;
  v4 = a2 - 16;
  if ( !v4 )
    goto LABEL_8;
  v5 = v4 - 256;
  if ( !v5 )
  {
    sub_140002490(String, "%d", (unsigned int)dword_1400935B4);
    SetDlgItemTextA(v3, 1005, String);
    DlgItem = GetDlgItem(v3, 1022);
    SendMessageA(DlgItem, 0x465u, 0i64, 9999i64);
    return 1i64;
  }
  if ( v5 == 1 )
  {
    switch ( a3 )
    {
      case 1:
        GetDlgItemTextA(a1, 1005, String, 64);
        if ( !sub_14000EF80(String, "%d", v8) )
        {
          MessageBoxA(0i64, "Invalid History Depth.", "Filter Error", 0x30u);
          return 1i64;
        }
        a1 = v3;
        dword_1400935B4 = v8[0];
LABEL_8:
        EndDialog(a1, 1i64);
        return 1i64;
      case 2:
        EndDialog(a1, 1i64);
        return 0i64;
      case 3:
        SetDlgItemTextA(a1, 1005, a0_0);
        break;
    }
  }
  return 0i64;
}
// 1400935B4: using guessed type int dword_1400935B4;
// 140010800: using guessed type int var_68[4];

//----- (0000000140010940) ----------------------------------------------------
INT_PTR __fastcall sub_140010940(HWND a1, int a2, int a3)
{
  __int16 v3; // di
  int v5; // edx
  HWND DlgItem; // rax
  HWND v8; // rax
  HWND v9; // rax
  struct _FILETIME FileTime; // [rsp+30h] [rbp-2088h] BYREF
  FILETIME v11; // [rsp+38h] [rbp-2080h]
  LARGE_INTEGER PerformanceCount; // [rsp+40h] [rbp-2078h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+48h] [rbp-2070h] BYREF
  CHAR String[8256]; // [rsp+60h] [rbp-2058h] BYREF

  v3 = a3;
  v5 = a2 - 272;
  if ( v5 )
  {
    if ( v5 == 1 )
    {
      if ( HIWORD(a3) == 768 )
      {
        GetDlgItemTextA(a1, 1037, String, 8256);
        if ( String[0] )
        {
          DlgItem = GetDlgItem(a1, 1);
          EnableWindow(DlgItem, 1);
        }
      }
      if ( v3 == 1 )
      {
        GetDlgItemTextA(a1, 1037, String, 8256);
        if ( String[0] )
        {
          qword_1400A36B8 = *((_QWORD *)&unk_1400A2640 + 48 * (unsigned int)ArgList + 37);
          GetSystemTime(&SystemTime);
          SystemTimeToFileTime(&SystemTime, &FileTime);
          v11 = FileTime;
          QueryPerformanceCounter(&PerformanceCount);
          sub_140010B40(
            *((HWND *)&unk_1400A2640 + 48 * (unsigned int)ArgList + 1),
            ArgList,
            *((_DWORD *)&unk_1400A2640 + 96 * (unsigned int)ArgList + 81)
          + 1
          + *((_DWORD *)&unk_1400A2640 + 96 * (unsigned int)ArgList + 80),
            v11,
            PerformanceCount.QuadPart,
            String);
          ++*((_DWORD *)&unk_1400A2640 + 96 * (unsigned int)ArgList + 78);
          SetDlgItemTextA(a1, 1037, (LPCSTR)&WindowName);
          v8 = GetDlgItem(a1, 1);
          EnableWindow(v8, 0);
        }
      }
      else if ( v3 == 2 )
      {
        EndDialog(a1, 1i64);
        return 0i64;
      }
    }
    return 0i64;
  }
  else
  {
    v9 = GetDlgItem(a1, 1037);
    SetFocus(v9);
    return 1i64;
  }
}
// 1400A36B8: using guessed type __int64 qword_1400A36B8;

//----- (0000000140010B40) ----------------------------------------------------
__int64 __fastcall sub_140010B40(HWND hWnd, unsigned int a2, unsigned int a3, FILETIME a4, __int64 a5, char *a6)
{
  __int64 v8; // r14
  unsigned int v9; // r13d
  size_t v10; // rsi
  unsigned int v11; // r10d
  unsigned int v12; // r9d
  __int64 v13; // rax
  __int64 v14; // r8
  char v15; // dl
  unsigned __int64 v16; // rax
  char *v17; // rbx
  int i; // edi
  _QWORD *v19; // r12
  HWND v20; // rdi
  int v21; // eax
  size_t v23; // r8
  __int64 v24; // rax
  float v25; // xmm1_4
  signed int v26; // eax
  CHAR *v27; // rdx
  CHAR j; // cl
  unsigned __int64 v29; // r9
  CHAR *v30; // r8
  CHAR *v31; // rcx
  __int64 v32; // rdx
  CHAR v33; // al
  __int64 v34; // rcx
  CHAR v35; // al
  size_t v36; // r8
  unsigned int v37; // r8d
  __int64 v38; // rax
  __int64 v39; // rdx
  char v40; // cl
  unsigned __int64 v41; // rax
  CHAR *v42; // rcx
  CHAR v43; // al
  fpos_t Position; // [rsp+38h] [rbp-C8h] BYREF
  HWND hWnda; // [rsp+40h] [rbp-C0h]
  struct _FILETIME LocalFileTime; // [rsp+48h] [rbp-B8h] BYREF
  FILETIME FileTime; // [rsp+50h] [rbp-B0h] BYREF
  int lParam; // [rsp+60h] [rbp-A0h] BYREF
  int lParam_4; // [rsp+64h] [rbp-9Ch]
  int v51; // [rsp+68h] [rbp-98h]
  __int64 v52; // [rsp+78h] [rbp-88h]
  _QWORD *v53; // [rsp+88h] [rbp-78h]
  CHAR TimeStr[64]; // [rsp+B0h] [rbp-50h] BYREF
  char v55[16]; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v56; // [rsp+100h] [rbp+0h] BYREF
  CHAR DateStr[64]; // [rsp+130h] [rbp+30h] BYREF

  hWnda = hWnd;
  FileTime = a4;
  v8 = 384i64 * a2;
  if ( *((_BYTE *)&unk_1400A2640 + v8 + 316) )
  {
    *(_QWORD *)((char *)&unk_1400A2640 + v8 + 328) = a5;
    *((_BYTE *)&unk_1400A2640 + v8 + 316) = 0;
  }
  if ( !byte_1400921CE || a3 < *(_DWORD *)((char *)&unk_1400A2640 + v8 + 320) )
    return 0i64;
  v9 = 0;
  v10 = -1i64;
  v11 = 0;
  v12 = 0;
  v13 = -1i64;
  do
    ++v13;
  while ( a6[v13] );
  if ( !v13 )
    goto LABEL_24;
  v14 = 0i64;
  do
  {
    v15 = a6[v14];
    if ( v15 == 1 && *((_BYTE *)&unk_1400A2640 + v8 + 311) )
    {
      a6[v14] = 91;
      v15 = 91;
    }
    if ( v15 == 2 )
    {
      if ( *((_BYTE *)&unk_1400A2640 + v8 + 311) )
        a6[v14] = 93;
      else
        v11 = v12 + 2;
    }
    else if ( ((v15 - 9) & 0xFA) == 0 && v15 != 14 )
    {
      a6[v14] = 32;
    }
    ++v12;
    v16 = -1i64;
    v14 = v12;
    do
      ++v16;
    while ( a6[v16] );
  }
  while ( v12 < v16 );
  if ( v11 )
    v17 = &a6[v11];
  else
LABEL_24:
    v17 = a6;
  if ( !sub_14000E890(a6) )
    return 0i64;
  if ( *v17 )
  {
    i = sub_14000F740(hWnd, a3 - *(_DWORD *)((char *)&unk_1400A2640 + v8 + 320));
    if ( i == -1 )
      i = 0x7FFFFFFF;
  }
  else
  {
    lParam = 4;
    v51 = 0;
    for ( i = SendMessageA(hWnd, 0x1004u, 0i64, 0i64) - 1; i >= 0; --i )
    {
      lParam_4 = i;
      if ( (unsigned int)SendMessageA(hWnd, 0x1005u, 0i64, (LPARAM)&lParam) && (_DWORD)v53 == a3 )
        break;
    }
    if ( i == -1 )
      return 0i64;
  }
  if ( !*v17 )
  {
    v19 = (_QWORD *)LocalFileTime;
LABEL_55:
    v20 = hWnda;
    goto LABEL_56;
  }
  if ( a3 == -1 )
    sub_140002490(::TimeStr, "W32");
  else
    sub_140002490(::TimeStr, "%08d", a3 - *(_DWORD *)((char *)&unk_1400A2640 + v8 + 320));
  v19 = j__malloc_base(0x30ui64);
  *v19 = 0i64;
  v19[1] = 0i64;
  v19[2] = 0i64;
  v19[3] = 0i64;
  v19[4] = 0i64;
  v19[5] = 0i64;
  v19[3] = strdup(::TimeStr);
  lParam_4 = i;
  v20 = hWnda;
  lParam = 5;
  v51 = 0;
  v52 = -1i64;
  v53 = v19;
  v21 = SendMessageA(hWnda, 0x1007u, 0i64, (LPARAM)&lParam);
  if ( v21 == -1 )
  {
    sub_140002490(::TimeStr, "Error adding item %d to list view", a3);
    MessageBoxA(hWnda, ::TimeStr, "DebugView Error", 0);
    return 0i64;
  }
  dword_1400935C0 = v21;
  if ( Stream )
  {
    fgetpos(Stream, &Position);
    if ( !byte_1400935A7 )
    {
      if ( !dword_1400935C4 )
      {
LABEL_49:
        if ( dword_1400921E0 != a2 )
          sub_14000EF30((__int64)Stream, (__int64)"[\\\\%s]\r\n", (const char *)&unk_1400A2640 + v8 + 16);
        dword_1400921E0 = a2;
        v23 = -1i64;
        do
          ++v23;
        while ( ::TimeStr[v23] );
        fwrite(::TimeStr, 1ui64, v23, Stream);
        fwrite("\t", 1ui64, 1ui64, Stream);
        goto LABEL_55;
      }
      if ( Position / 0x100000 >= (unsigned int)dword_1400935C4 )
      {
        sub_140012BF0(hWndParent, 1);
        SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C6Eui64, 21i64);
        InvalidateRect(qword_1400A37E8, 0i64, 1);
        goto LABEL_56;
      }
    }
    if ( dword_1400935C4 && Position / 0x100000 >= (unsigned int)dword_1400935C4 )
    {
      Position = 0i64;
      fsetpos(Stream, &Position);
    }
    goto LABEL_49;
  }
LABEL_56:
  *(_DWORD *)((char *)&unk_1400A2640 + v8 + 324) = a3 - *(_DWORD *)((char *)&unk_1400A2640 + v8 + 320);
  FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
  FileTimeToSystemTime(&LocalFileTime, (LPSYSTEMTIME)v19);
  v24 = a5 - *(_QWORD *)((char *)&unk_1400A2640 + v8 + 328);
  v25 = 0.0;
  *((float *)v19 + 4) = (float)(int)v24;
  if ( (float)(int)v24 >= 0.0 )
    v25 = (float)(int)v24;
  else
    *((_DWORD *)v19 + 4) = 0;
  *((float *)v19 + 4) = v25 / (float)(int)qword_1400A36B8;
  v19[4] = 0i64;
  if ( Stream )
  {
    if ( byte_1400921CC )
    {
      GetTimeFormatA(0x400u, 0, (const SYSTEMTIME *)v19, 0i64, TimeStr, 64);
      if ( byte_1400935A4 )
      {
        v26 = (unsigned int)strrchr(TimeStr, 58) - ((unsigned int)&v56 - 80);
        v27 = &TimeStr[v26];
        for ( j = *v27; j; ++v26 )
        {
          if ( j == 32 )
            break;
          j = *++v27;
        }
        v29 = v26;
        v30 = &TimeStr[v26];
        v31 = v30;
        v32 = -16 - (v26 - 80i64);
        do
        {
          v33 = *v31;
          v31[v32] = *v31;
          ++v31;
        }
        while ( v33 );
        if ( v29 >= 0x40 )
          _report_rangecheckfailure(v31);
        *v30 = 0;
        sub_140002490(::TimeStr, "%s.%03d%s", TimeStr, *((unsigned __int16 *)v19 + 7), v55);
      }
      else
      {
        v34 = 0i64;
        do
        {
          v35 = TimeStr[v34];
          ::TimeStr[v34++] = v35;
        }
        while ( v35 );
      }
    }
    else
    {
      sub_140002490(::TimeStr, "%10.8f", *((float *)v19 + 4));
    }
    v36 = -1i64;
    do
      ++v36;
    while ( ::TimeStr[v36] );
    fwrite(::TimeStr, 1ui64, v36, Stream);
    fwrite("\t", 1ui64, 1ui64, Stream);
  }
  v37 = 0;
  v38 = -1i64;
  do
    ++v38;
  while ( v17[v38] );
  if ( v38 )
  {
    v39 = 0i64;
    do
    {
      v40 = v17[v39];
      if ( v40 == 1 && *((_BYTE *)&unk_1400A2640 + v8 + 311) )
      {
        v17[v39] = 91;
        v40 = 91;
      }
      if ( v40 == 2 )
      {
        if ( *((_BYTE *)&unk_1400A2640 + v8 + 311) )
          v17[v39] = 93;
        else
          v9 = v37 + 2;
      }
      else if ( ((v40 - 9) & 0xFA) == 0 && v40 != 14 )
      {
        v17[v39] = 32;
      }
      ++v37;
      v41 = -1i64;
      v39 = v37;
      do
        ++v41;
      while ( v17[v41] );
    }
    while ( v37 < v41 );
    if ( v9 )
      v17 += (int)v9;
  }
  v42 = (CHAR *)(::TimeStr - v17);
  do
  {
    v43 = *v17;
    v42[(_QWORD)v17] = *v17;
    ++v17;
  }
  while ( v43 );
  if ( !::TimeStr[0] )
    strcpy(::TimeStr, " ");
  v19[5] = strdup(::TimeStr);
  if ( Stream )
  {
    do
      ++v10;
    while ( ::TimeStr[v10] );
    fwrite(::TimeStr, 1ui64, v10, Stream);
    fwrite(&word_14007CF34, 1ui64, 2ui64, Stream);
    fflush(Stream);
    if ( nIDButton == 1040 )
    {
      GetDateFormatA(0x400u, 0, 0i64, 0i64, DateStr, 64);
      if ( strcmp(DateStr, ::DateStr) )
        sub_140012BF0(hWndParent, 1);
    }
  }
  if ( strstr(::TimeStr, "DBGVIEWCLEAR") )
    sub_14000A640(v20);
  SendMessageA(v20, 0x1015u, lParam_4, lParam_4);
  return 1i64;
}
// 14001503C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 14007CF34: using guessed type __int16 word_14007CF34;
// 1400921CC: using guessed type char byte_1400921CC;
// 1400921CE: using guessed type char byte_1400921CE;
// 1400921E0: using guessed type int dword_1400921E0;
// 1400935A4: using guessed type char byte_1400935A4;
// 1400935A7: using guessed type char byte_1400935A7;
// 1400935C0: using guessed type int dword_1400935C0;
// 1400935C4: using guessed type int dword_1400935C4;
// 1400A36B8: using guessed type __int64 qword_1400A36B8;
// 140010B40: using guessed type CHAR TimeStr[64];
// 140010B40: using guessed type char var_D0[16];

//----- (0000000140011350) ----------------------------------------------------
LRESULT __fastcall sub_140011350(HWND a1, UINT a2, HWND a3, LPARAM a4)
{
  HWND v8; // rcx
  HWND Focus; // rax
  HWND v10; // rax
  HWND v11; // rcx
  int v13; // r8d
  int v14; // ecx
  __int16 *v15; // rax
  char v16; // dl
  int v17; // eax
  char *v18; // rcx
  __int64 v19; // rdx
  char v20; // al
  __int64 v21; // rax
  unsigned int v22; // ecx
  unsigned int v23; // eax
  int v24; // eax
  HWND Window; // rax
  DWORD dwProcessId; // [rsp+60h] [rbp-A0h] BYREF
  struct tagPOINT Point; // [rsp+68h] [rbp-98h] BYREF
  struct tagPOINT v28; // [rsp+70h] [rbp-90h] BYREF
  struct tagPOINT v29; // [rsp+78h] [rbp-88h] BYREF
  LPARAM v30; // [rsp+80h] [rbp-80h] BYREF
  int v31; // [rsp+88h] [rbp-78h]
  __int16 *v32; // [rsp+98h] [rbp-68h]
  int v33; // [rsp+A0h] [rbp-60h]
  _DWORD v34[3]; // [rsp+D0h] [rbp-30h] BYREF
  int v35; // [rsp+DCh] [rbp-24h]
  int v36; // [rsp+E0h] [rbp-20h]
  struct tagRECT Rect; // [rsp+E8h] [rbp-18h] BYREF
  __int16 Param[2063]; // [rsp+100h] [rbp+0h] BYREF
  char v39; // [rsp+111Fh] [rbp+101Fh]
  LPARAM v40; // [rsp+1120h] [rbp+1020h] BYREF
  int v41; // [rsp+1128h] [rbp+1028h]
  int v42; // [rsp+112Ch] [rbp+102Ch]

  if ( a2 > 0x115 )
  {
    if ( a2 - 512 > 9 )
      return CallWindowProcA(lpPrevWndFunc, a1, a2, (WPARAM)a3, a4);
    dword_14009B244 = a4;
  }
  else if ( a2 < 0x114 )
  {
    if ( a2 != 8 )
    {
      if ( a2 == 256 && a3 == (HWND)27 && qword_140093590 )
      {
        DestroyWindow(qword_140093590);
        qword_140093590 = 0i64;
      }
      return CallWindowProcA(lpPrevWndFunc, a1, a2, (WPARAM)a3, a4);
    }
    GetWindowThreadProcessId(a3, &dwProcessId);
    if ( dwProcessId == GetCurrentProcessId() )
      return CallWindowProcA(lpPrevWndFunc, a1, a2, (WPARAM)a3, a4);
    goto LABEL_9;
  }
  Focus = GetFocus();
  GetWindowThreadProcessId(Focus, &dwProcessId);
  if ( dwProcessId != GetCurrentProcessId() )
    return CallWindowProcA(lpPrevWndFunc, a1, a2, (WPARAM)a3, a4);
  GetCursorPos(&Point);
  GetClientRect(a1, &Rect);
  v28.x = Rect.left;
  v28.y = Rect.top;
  ClientToScreen(a1, &v28);
  v29 = *(struct tagPOINT *)&Rect.right;
  ClientToScreen(a1, &v29);
  if ( Point.x < v28.x || Point.x > v29.x || Point.y < v28.y || Point.y > v29.y )
  {
LABEL_19:
    v8 = qword_1400935C8;
    if ( !qword_1400935C8 )
      return CallWindowProcA(lpPrevWndFunc, a1, a2, (WPARAM)a3, a4);
LABEL_20:
    ShowWindow(v8, 0);
    return CallWindowProcA(lpPrevWndFunc, a1, a2, (WPARAM)a3, a4);
  }
  if ( qword_140093590 )
  {
    v10 = GetFocus();
    v11 = qword_1400A37F8;
    if ( v10 != qword_1400A37F8 )
      goto LABEL_19;
  }
  else
  {
    v11 = qword_1400A37F8;
  }
  v34[0] = (__int16)dword_14009B244;
  v34[1] = SHIWORD(dword_14009B244);
  if ( (unsigned int)SendMessageA(v11, 0x1039u, 0i64, (LPARAM)v34) == -1 || v36 == -1 )
    goto LABEL_9;
  v31 = v36;
  v32 = Param;
  LOBYTE(Param[0]) = 0;
  v33 = 4128;
  SendMessageA(qword_1400A37F8, 0x102Du, v35, (LPARAM)&v30);
  v13 = v36;
  v39 = 0;
  if ( !v36 && Param[0] != 48 )
  {
    v14 = 0;
    if ( LOBYTE(Param[0]) == 48 )
    {
      v15 = Param;
      do
      {
        ++v14;
        v15 = (__int16 *)((char *)v15 + 1);
      }
      while ( *(_BYTE *)v15 == 48 );
    }
    v16 = *((_BYTE *)Param + v14);
    if ( !v16 )
      Param[0] = 48;
    v17 = 0;
    if ( v16 )
      v17 = v14;
    v18 = (char *)Param + v17;
    v19 = -(__int64)v17;
    do
    {
      v20 = *v18;
      v18[v19] = *v18;
      ++v18;
    }
    while ( v20 );
  }
  v21 = -1i64;
  do
    ++v21;
  while ( *((_BYTE *)Param + v21) );
  if ( !v21 )
  {
LABEL_9:
    v8 = qword_1400935C8;
    goto LABEL_20;
  }
  if ( v13 )
  {
    HIDWORD(v40) = v13;
    LODWORD(v40) = 0;
    SendMessageA(qword_1400A37F8, 0x1038u, v35, (LPARAM)&v40);
    v22 = HIDWORD(v40);
    v42 -= HIDWORD(v40);
    v23 = v40;
    v41 -= v40;
  }
  else
  {
    v40 = 0i64;
    SendMessageA(qword_1400A37F8, 0x1038u, v35, (LPARAM)&v40);
    v42 -= HIDWORD(v40);
    v24 = SendMessageA(qword_1400A37F8, 0x101Du, 0i64, 0i64);
    v22 = HIDWORD(v40);
    v41 = v24;
    v23 = 0;
    LODWORD(v40) = 0;
  }
  Point = (struct tagPOINT)__PAIR64__(v22, v23);
  ClientToScreen(a1, &Point);
  v40 = (LPARAM)Point;
  Window = qword_1400935C8;
  if ( !qword_1400935C8 )
  {
    Window = CreateWindowExA(
               0,
               "BALLOON",
               "balloon",
               0x80800000,
               100,
               100,
               200,
               200,
               hWndParent,
               0i64,
               hInstance,
               Param);
    qword_1400935C8 = Window;
  }
  SendMessageA(Window, 0x400u, 0i64, (LPARAM)Param);
  return CallWindowProcA(lpPrevWndFunc, a1, a2, (WPARAM)a3, a4);
}
// 14009B244: using guessed type int dword_14009B244;
// 140011350: using guessed type _DWORD var_10A0[3];

//----- (0000000140011780) ----------------------------------------------------
int __fastcall sub_140011780(HWND hWnd)
{
  const CHAR *v2; // rdx
  __int64 v3; // rcx
  char v4; // al
  HWND TextA; // rax

  if ( !(unsigned int)SendMessageA(*(&qword_1400A2648 + 48 * (unsigned int)ArgList), 0x1004u, 0i64, 0i64) )
  {
    v2 = "No items to search.";
LABEL_7:
    LODWORD(TextA) = MessageBoxA(hWnd, v2, "DebugView", 0x10u);
    return (int)TextA;
  }
  v3 = 0i64;
  do
  {
    v4 = byte_14009E4E0[v3];
    byte_14009F580[v3++] = v4;
  }
  while ( v4 );
  stru_14009F520.hInstance = hInstance;
  stru_14009F520.Flags = dword_1400921D0;
  stru_14009F520.lStructSize = 80;
  stru_14009F520.lpfnHook = 0i64;
  stru_14009F520.lpTemplateName = 0i64;
  *(_DWORD *)&stru_14009F520.wFindWhatLen = 4128;
  stru_14009F520.lCustData = 0i64;
  stru_14009F520.lpstrReplaceWith = 0i64;
  stru_14009F520.hwndOwner = hWnd;
  stru_14009F520.lpstrFindWhat = byte_14009F580;
  TextA = FindTextA(&stru_14009F520);
  qword_140093590 = TextA;
  if ( !TextA )
  {
    v2 = "Unable to create Find dialog";
    goto LABEL_7;
  }
  return (int)TextA;
}
// 1400921D0: using guessed type int dword_1400921D0;
// 14009E4E0: using guessed type _BYTE byte_14009E4E0[4128];
// 14009F580: using guessed type _BYTE byte_14009F580[4128];

//----- (0000000140011890) ----------------------------------------------------
__int64 __fastcall sub_140011890(const char *a1, char a2, const char **a3)
{
  int v3; // esi
  unsigned int v5; // edi
  char *v6; // rax
  _QWORD *v7; // rbx
  const char *v8; // rax

  v3 = a2;
  *a3 = a1;
  v5 = 1;
  v6 = strchr(a1, a2);
  if ( v6 )
  {
    v7 = a3 + 1;
    do
    {
      *v6 = 0;
      ++v7;
      v8 = v6 + 1;
      *(v7 - 1) = v8;
      ++v5;
      v6 = strchr(v8, v3);
    }
    while ( v6 );
  }
  return v5;
}

//----- (0000000140011900) ----------------------------------------------------
INT_PTR __fastcall sub_140011900(HWND a1, int a2, __int16 a3)
{
  int v4; // edx
  int v5; // edx
  _QWORD *v6; // rax
  void *v7; // rbx
  INT_PTR v8; // rdx
  __int64 v9; // rcx
  char v10; // al
  char *v11; // rcx
  char *v12; // rdx
  char v13; // al
  FILE *v14; // r14
  DWORD LastError; // eax
  char *v16; // rdx
  char *v17; // r15
  unsigned int *i; // rsi
  unsigned int *v19; // rax
  __int64 v20; // rbx
  unsigned int v21; // ebx
  _QWORD *v23; // rax
  void *v24; // rbx
  CHAR Buffer[8]; // [rsp+40h] [rbp-C0h] BYREF
  unsigned int ThrdAddr; // [rsp+48h] [rbp-B8h] BYREF
  struct _FILETIME LocalFileTime; // [rsp+50h] [rbp-B0h] BYREF
  struct tagOFNA v28; // [rsp+60h] [rbp-A0h] BYREF
  struct tagOFNA v29; // [rsp+100h] [rbp+0h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+A0h] BYREF
  char FileName[272]; // [rsp+1B0h] [rbp+B0h] BYREF
  char Str[272]; // [rsp+2C0h] [rbp+1C0h] BYREF
  CHAR Text[256]; // [rsp+3D0h] [rbp+2D0h] BYREF

  v4 = a2 - 16;
  if ( !v4 )
  {
    byte_14009E248 = 1;
    WaitForSingleObject(hHandle, 0xFFFFFFFF);
    CloseHandle(hHandle);
    v23 = qword_1400935E0;
    if ( qword_1400935E0 )
    {
      do
      {
        v24 = (void *)v23[1];
        j__free_base(v23);
        qword_1400935E0 = v24;
        v23 = v24;
      }
      while ( v24 );
    }
LABEL_37:
    v8 = 0i64;
LABEL_38:
    EndDialog(a1, v8);
    return 0i64;
  }
  v5 = v4 - 256;
  if ( !v5 )
  {
    v29.hwndOwner = hWndParent;
    v29.hInstance = hInstance;
    v29.lpstrFilter = "DebugView Dump (*.dmp)";
    v29.lpstrFile = aMemoryDmp;
    v29.lpstrTitle = "Open crash dump...";
    v29.lpstrDefExt = "*.dmp";
    v29.lStructSize = 152;
    v29.lpstrCustomFilter = 0i64;
    v29.nMaxCustFilter = 0;
    v29.nFilterIndex = 1;
    v29.nMaxFile = 260;
    v29.lpstrFileTitle = 0i64;
    v29.nMaxFileTitle = 0;
    v29.lpstrInitialDir = 0i64;
    *(_QWORD *)&v29.Flags = 2103296i64;
    v29.lpfnHook = 0i64;
    if ( GetOpenFileNameA(&v29) )
    {
      byte_14009E248 = 0;
      hHandle = (HANDLE)beginthreadex(0i64, 0, (_beginthreadex_proc_type)sub_140011E80, a1, 0, &ThrdAddr);
      return 1i64;
    }
    goto LABEL_37;
  }
  if ( v5 != 1 )
    return 0i64;
  if ( a3 != 1 )
  {
    if ( a3 == 2 )
    {
      byte_14009E248 = 1;
      WaitForSingleObject(hHandle, 0xFFFFFFFF);
      CloseHandle(hHandle);
      v6 = qword_1400935E0;
      if ( qword_1400935E0 )
      {
        do
        {
          v7 = (void *)v6[1];
          j__free_base(v6);
          qword_1400935E0 = v7;
          v6 = v7;
        }
        while ( v7 );
      }
      v8 = 1i64;
      goto LABEL_38;
    }
    return 0i64;
  }
  EndDialog(a1, 1i64);
  CloseHandle(hHandle);
  if ( qword_1400935E0 )
  {
    while ( 1 )
    {
      v9 = 0i64;
      strcpy(FileName, "dbgview.log");
      do
      {
        v10 = String[v9];
        Str[v9++] = v10;
      }
      while ( v10 );
      if ( strrchr(Str, 92) )
      {
        v11 = strrchr(Str, 92) + 1;
        v12 = (char *)(FileName - v11);
        do
        {
          v13 = *v11;
          v11[(_QWORD)v12] = *v11;
          ++v11;
        }
        while ( v13 );
        *strrchr(Str, 92) = 0;
      }
      v28.hInstance = hInstance;
      v28.lpstrFile = FileName;
      v28.lpstrInitialDir = Str;
      v28.lStructSize = 152;
      v28.hwndOwner = a1;
      v28.lpstrFilter = "DebugView Log (*.LOG)";
      v28.lpstrCustomFilter = 0i64;
      v28.nMaxCustFilter = 0;
      v28.nFilterIndex = 1;
      v28.nMaxFile = 260;
      v28.lpstrFileTitle = 0i64;
      v28.nMaxFileTitle = 0;
      v28.lpstrTitle = "Specify DebugView Crash Log File...";
      *(_QWORD *)&v28.Flags = 2656260i64;
      v28.lpstrDefExt = "*.log";
      v28.lpfnHook = 0i64;
      if ( !GetSaveFileNameA(&v28) )
        break;
      v14 = fopen(FileName, "wb");
      if ( v14 )
      {
        v16 = (char *)qword_1400935E0;
        if ( qword_1400935E0 )
        {
          do
          {
            v17 = (char *)*((_QWORD *)v16 + 1);
            for ( i = (unsigned int *)(v16 + 20); ; i = (unsigned int *)((char *)i + v21 + 20) )
            {
              v19 = (unsigned int *)(v16 + 4100);
              if ( &v16[*((unsigned int *)v16 + 4) + 20] < v16 + 4100 )
                v19 = (unsigned int *)&v16[*((unsigned int *)v16 + 4) + 20];
              if ( i >= v19 )
                break;
              v20 = -1i64;
              do
                ++v20;
              while ( *((_BYTE *)i + v20 + 20) );
              v21 = (v20 + 4) & 0xFFFFFFFC;
              if ( v21 > 0x101F )
                *((_BYTE *)i + 4147) = 0;
              FileTimeToLocalFileTime((const FILETIME *)(i + 1), &LocalFileTime);
              FileTimeToSystemTime(&LocalFileTime, &SystemTime);
              GetTimeFormatA(0x400u, 0, &SystemTime, 0i64, TimeStr, 64);
              sub_14000EF30((__int64)v14, (__int64)"%08d\t%s\t%s\t\r\n", *i, TimeStr, (const char *)i + 20);
              v16 = (char *)qword_1400935E0;
            }
            j__free_base(v16);
            v16 = v17;
            qword_1400935E0 = v17;
          }
          while ( v17 );
        }
        fclose(v14);
        return 1i64;
      }
      LastError = GetLastError();
      FormatMessageA(0x1100u, 0i64, LastError, 0x400u, Buffer, 0, 0i64);
      sub_140002490(Text, "Error opening log file %s: %s", FileName, *(const char **)Buffer);
      MessageBoxA(hWndParent, Text, "DebugView", 0x10u);
      LocalFree(*(HLOCAL *)Buffer);
    }
  }
  else
  {
    MessageBoxA(hWndParent, "No DebugView output was found in the crash dump file", "DebugView", 0x30u);
  }
  return 1i64;
}
// 14009E248: using guessed type char byte_14009E248;
// 140011900: using guessed type char Str[272];

//----- (0000000140011E80) ----------------------------------------------------
__int64 __fastcall sub_140011E80(HWND a1)
{
  HANDLE FileA; // rax
  void *v3; // rsi
  WPARAM v4; // r8
  UINT v5; // edx
  signed int FileSize; // r15d
  int v7; // ebp
  double v8; // xmm8_8
  _DWORD *v9; // rdi
  DWORD v10; // eax
  _QWORD *v11; // rcx
  unsigned int v12; // edx
  __int64 v13; // rax
  double v14; // xmm6_8
  unsigned __int64 v15; // rax
  double v16; // xmm0_8
  WPARAM v17; // rbx
  HWND DlgItem; // rax
  DWORD NumberOfBytesRead; // [rsp+B0h] [rbp+8h] BYREF

  FileA = CreateFileA(aMemoryDmp, 0x80000000, 1u, 0i64, 3u, 0x8000000u, 0i64);
  v3 = FileA;
  if ( FileA == (HANDLE)-1i64 )
  {
    v4 = 0i64;
    v5 = 16;
LABEL_27:
    SendMessageA(a1, v5, v4, 0i64);
    return 0i64;
  }
  FileSize = GetFileSize(FileA, 0i64);
  v7 = 0;
  v8 = 0.0;
  v9 = j__malloc_base(0x1004ui64);
  while ( ReadFile(v3, v9, 0x1004u, &NumberOfBytesRead, 0i64) )
  {
    v10 = NumberOfBytesRead;
    if ( NumberOfBytesRead != 4100 || byte_14009E248 )
      break;
    if ( *v9 == -22159697 && v9[4] )
    {
      *((_QWORD *)v9 + 1) = 0i64;
      v11 = qword_1400935E0;
      if ( qword_1400935E0 )
      {
        v12 = v9[1];
        if ( v12 >= *((_DWORD *)qword_1400935E0 + 1) )
        {
          if ( qword_1400935E0 )
          {
            while ( v12 > *((_DWORD *)v11 + 1) )
            {
              v13 = v11[1];
              if ( !v13 || v12 < *(_DWORD *)(v13 + 4) )
                break;
              v11 = (_QWORD *)v11[1];
            }
          }
          *((_QWORD *)v9 + 1) = v11[1];
          v11[1] = v9;
        }
        else
        {
          *((_QWORD *)v9 + 1) = qword_1400935E0;
          qword_1400935E0 = v9;
        }
      }
      else
      {
        qword_1400935E0 = v9;
      }
      v9 = j__malloc_base(0x1004ui64);
      v10 = NumberOfBytesRead;
    }
    v7 += v10;
    v14 = (double)v7 / (double)FileSize * 100.0;
    if ( v14 != v8 )
    {
      v15 = 0i64;
      v16 = (double)v7 / (double)FileSize * 100.0;
      if ( v14 >= 9.223372036854776e18 )
      {
        v16 = v14 - 9.223372036854776e18;
        if ( v14 - 9.223372036854776e18 < 9.223372036854776e18 )
          v15 = 0x8000000000000000ui64;
      }
      v17 = v15 + (unsigned int)(int)v16;
      DlgItem = GetDlgItem(a1, 1029);
      PostMessageA(DlgItem, 0x402u, v17, 0i64);
      v8 = (double)v7 / (double)FileSize * 100.0;
    }
  }
  CloseHandle(v3);
  j__free_base(v9);
  if ( !byte_14009E248 )
  {
    v5 = 273;
    v4 = 1i64;
    goto LABEL_27;
  }
  return 0i64;
}
// 140011FF9: conditional instruction was optimized away because rax.8!=0
// 14009E248: using guessed type char byte_14009E248;

//----- (0000000140012130) ----------------------------------------------------
int __fastcall sub_140012130(HWND a1, unsigned int a2, HWND a3, const char *a4)
{
  __int64 v6; // r14
  int result; // eax
  char *v9; // rdx
  char *v10; // rcx
  char v11; // al
  FILE *v12; // rsi
  int v13; // r15d
  char *v14; // r12
  CHAR *v15; // r14
  int v16; // esi
  char *v17; // rax
  char *v18; // rdi
  char *v19; // rax
  _QWORD *v20; // rbx
  __int64 v21; // r8
  HWND v22; // rsi
  int v23; // eax
  unsigned int v24; // [rsp+20h] [rbp-22D8h] BYREF
  int v25; // [rsp+24h] [rbp-22D4h]
  unsigned int v26; // [rsp+28h] [rbp-22D0h]
  int v27; // [rsp+2Ch] [rbp-22CCh]
  FILE *Stream; // [rsp+30h] [rbp-22C8h]
  char *v29; // [rsp+38h] [rbp-22C0h]
  HWND hWnd; // [rsp+40h] [rbp-22B8h]
  char *Source; // [rsp+48h] [rbp-22B0h]
  HWND v32; // [rsp+50h] [rbp-22A8h]
  HWND v33; // [rsp+58h] [rbp-22A0h]
  __int64 v34; // [rsp+60h] [rbp-2298h]
  __int64 v35; // [rsp+68h] [rbp-2290h]
  struct tagOFNA v36; // [rsp+70h] [rbp-2288h] BYREF
  _DWORD lParam[6]; // [rsp+110h] [rbp-21E8h] BYREF
  __int64 v38; // [rsp+128h] [rbp-21D0h]
  _QWORD *v39; // [rsp+138h] [rbp-21C0h]
  char FileName[272]; // [rsp+160h] [rbp-2198h] BYREF
  CHAR Text[8256]; // [rsp+270h] [rbp-2088h] BYREF

  hWnd = a3;
  v6 = a2;
  v26 = a2;
  v32 = a1;
  v33 = a3;
  sub_140016650((__int64)FileName, 0, 0x104ui64);
  if ( !(unsigned int)SendMessageA(a3, 0x1004u, 0i64, 0i64)
    || (result = MessageBoxA(
                   a1,
                   "Continuing will cause the current entries to be deleted.\n\nContinue?",
                   "DebugView",
                   0x34u),
        result != 7) )
  {
    SendMessageA(a3, 0x1009u, 0i64, 0i64);
    if ( a4 )
    {
      v12 = fopen(a4, "r");
      Stream = v12;
      sub_140002490(Text, "Error opening %s.", a4);
    }
    else
    {
      v9 = (char *)&unk_1400A2640 + 384 * (unsigned int)ArgList + 16;
      v10 = (char *)(FileName - v9);
      do
      {
        v11 = *v9;
        v9[(_QWORD)v10] = *v9;
        ++v9;
      }
      while ( v11 );
      v36.lStructSize = 152;
      v36.hwndOwner = a1;
      v36.hInstance = hInstance;
      v36.lpstrFilter = "DebugView Data (*.LOG)";
      v36.lpstrCustomFilter = 0i64;
      v36.nMaxCustFilter = 0;
      v36.nFilterIndex = 1;
      v36.lpstrFile = FileName;
      v36.nMaxFile = 256;
      v36.lpstrFileTitle = 0i64;
      v36.nMaxFileTitle = 0;
      v36.lpstrInitialDir = 0i64;
      v36.lpstrTitle = "Open DebugView Log File...";
      *(_QWORD *)&v36.Flags = 0x200000i64;
      v36.lpstrDefExt = "*.log";
      v36.lpfnHook = 0i64;
      result = GetOpenFileNameA(&v36);
      if ( !result )
        return result;
      v12 = fopen(FileName, "r");
      Stream = v12;
      sub_140002490(Text, "Error opening %s.", FileName);
    }
    if ( v12 )
    {
      SetCapture(a1);
      qword_1400A05A8 = SetCursor(qword_1400A05A0);
      v13 = 0;
      v25 = 0;
      v34 = v6;
      v35 = v6;
      *((_DWORD *)&unk_1400A2640 + 96 * v6 + 80) = 0;
      v24 = 0;
      v14 = Source;
      while ( common_fgets<char>(Text, 4128i64, v12) )
      {
        v15 = Text;
        if ( Text[0] != 91 )
        {
          v16 = 0;
          v27 = 0;
          while ( v16 < 3 )
          {
            if ( v16 >= 2 )
            {
              v19 = strchr(v15, 0);
              v18 = v19;
              v29 = v19;
              *(v19 - 1) = 0;
              if ( *(v19 - 2) == 9 )
                *(v19 - 2) = 0;
            }
            else
            {
              v17 = strchr(v15, 9);
              v18 = v17;
              v29 = v17;
              if ( v17 )
              {
                *v17 = 0;
                v18 = v17 + 1;
                v29 = v17 + 1;
              }
            }
            if ( v16 )
            {
              if ( v16 == 1 )
              {
                v14 = v15;
                Source = v15;
              }
              else if ( v16 == 2 )
              {
                if ( v24 == -1 )
                  sub_140002490(TimeStr, "W32");
                else
                  sub_140002490(TimeStr, "%08d", v24);
                if ( (v24 & 0x80000000) == 0 )
                {
                  v20 = j__malloc_base(0x30ui64);
                  *v20 = 0i64;
                  v20[1] = 0i64;
                  v20[2] = 0i64;
                  v20[3] = 0i64;
                  v20[4] = 0i64;
                  v20[5] = 0i64;
                  v20[3] = strdup(TimeStr);
                  v20[4] = strdup(v14);
                  v20[5] = strdup(v15);
                  lParam[0] = 5;
                  lParam[1] = v13;
                  lParam[2] = 0;
                  v38 = -1i64;
                  v39 = v20;
                  SendMessageA(hWnd, 0x1007u, 0i64, (LPARAM)lParam);
                }
              }
            }
            else
            {
              sub_14000EF80(v15, "%d", &v24);
              v21 = v24;
              if ( !v13 )
                *((_DWORD *)&unk_1400A2640 + 96 * v26 + 80) = v24;
              sub_140002490(TimeStr, "%08d", v21);
            }
            v15 = v18;
            v27 = ++v16;
          }
          v25 = ++v13;
          v12 = Stream;
        }
      }
      v22 = hWnd;
      *((_DWORD *)&unk_1400A2640 + 96 * v34 + 81) = v24;
      fclose(Stream);
      dword_1400935C0 = *((_DWORD *)&unk_1400A2640 + 96 * v35 + 81) - *((_DWORD *)&unk_1400A2640 + 96 * v35 + 80);
      if ( dword_1400935B4 && v13 )
      {
        SendMessageA(v22, 0xBu, 0i64, 0i64);
        for ( ; dword_1400935C0 >= (unsigned int)dword_1400935B4; --dword_1400935C0 )
          SendMessageA(v22, 0x1008u, 0i64, 0i64);
        SendMessageA(v22, 0xBu, 1ui64, 0i64);
      }
      if ( byte_1400921B3 && v13 )
      {
        if ( *((HWND *)&unk_1400A2640 + 48 * (unsigned int)ArgList + 1) == v22 && qword_1400935C8 )
          ShowWindow(qword_1400935C8, 0);
        v23 = SendMessageA(v22, 0x1004u, 0i64, 0i64);
        SendMessageA(v22, 0x1013u, v23 - 1, 0i64);
      }
      SetCursor(qword_1400A05A8);
      return ReleaseCapture();
    }
    else
    {
      return MessageBoxA(0i64, Text, "Log File Open Error", 0x10u);
    }
  }
  return result;
}
// 1400411C8: using guessed type __int64 __fastcall common_fgets<char>(_QWORD, _QWORD, _QWORD);
// 1400921B3: using guessed type char byte_1400921B3;
// 1400935B4: using guessed type int dword_1400935B4;
// 1400935C0: using guessed type int dword_1400935C0;

//----- (0000000140012770) ----------------------------------------------------
INT_PTR __fastcall sub_140012770(HWND a1, int a2, unsigned __int16 a3)
{
  int v5; // edx
  BOOL v6; // ebx
  HWND v7; // rax
  BOOL v8; // esi
  HWND v9; // rax
  HWND v10; // rax
  __int64 v12; // rcx
  CHAR v13; // al
  char *v14; // rcx
  CHAR *v15; // r8
  char v16; // al
  HWND DlgItem; // rax
  int v18; // edx
  HWND v19; // rax
  HWND v20; // rax
  HWND v21; // rax
  struct tagOFNA v22; // [rsp+20h] [rbp-E0h] BYREF
  CHAR Str[272]; // [rsp+C0h] [rbp-40h] BYREF
  CHAR String[272]; // [rsp+1D0h] [rbp+D0h] BYREF

  v5 = a2 - 272;
  if ( !v5 )
  {
    SetDlgItemTextA(a1, 1024, ::String);
    sub_140002490(Str, "%d", (unsigned int)dword_1400935C4);
    SetDlgItemTextA(a1, 1026, Str);
    CheckDlgButton(a1, 1025, byte_1400935A6 != 0);
    CheckDlgButton(a1, 1027, byte_1400935A7 != 0);
    CheckDlgButton(a1, 1042, byte_1400935D0 != 0);
    DlgItem = GetDlgItem(a1, 1022);
    SendMessageA(DlgItem, 0x465u, 0i64, 9999i64);
    CheckDlgButton(a1, nIDButton, 1u);
    switch ( nIDButton )
    {
      case 1039:
        v19 = GetDlgItem(a1, 1042);
        EnableWindow(v19, 0);
        break;
      case 1040:
        break;
      case 1041:
        v18 = 1042;
LABEL_31:
        v21 = GetDlgItem(a1, v18);
        EnableWindow(v21, 0);
        return 1i64;
      default:
        return 1i64;
    }
    v20 = GetDlgItem(a1, 1026);
    EnableWindow(v20, 0);
    v18 = 1027;
    goto LABEL_31;
  }
  if ( v5 != 1 )
    return 0i64;
  if ( a3 == 1 )
  {
    GetDlgItemTextA(a1, 1024, ::String, 260);
    byte_1400935A6 = IsDlgButtonChecked(a1, 1025) == 1;
    byte_1400935A7 = IsDlgButtonChecked(a1, 1027) == 1;
    GetDlgItemTextA(a1, 1026, Str, 260);
    dword_1400935C4 = sub_14003FD10((__int64)Str);
    if ( IsDlgButtonChecked(a1, 1039) == 1 )
    {
      nIDButton = 1039;
    }
    else if ( IsDlgButtonChecked(a1, 1041) == 1 )
    {
      nIDButton = 1041;
    }
    else
    {
      nIDButton = 1040;
      byte_1400935D0 = IsDlgButtonChecked(a1, 1042) == 1;
    }
    EndDialog(a1, 1i64);
    return 0i64;
  }
  if ( a3 == 2 )
  {
    EndDialog(a1, 0i64);
    return 0i64;
  }
  if ( a3 != 1009 )
  {
    if ( a3 > 0x40Eu && a3 <= 0x411u )
    {
      v6 = a3 == 1040;
      v7 = GetDlgItem(a1, 1042);
      EnableWindow(v7, v6);
      v8 = a3 == 1041;
      v9 = GetDlgItem(a1, 1026);
      EnableWindow(v9, v8);
      v10 = GetDlgItem(a1, 1027);
      EnableWindow(v10, v8);
      return 0i64;
    }
    return 0i64;
  }
  strcpy(String, "dbgview.log");
  v12 = 0i64;
  do
  {
    v13 = ::String[v12];
    Str[v12++] = v13;
  }
  while ( v13 );
  if ( strrchr(Str, 92) )
  {
    v14 = strrchr(Str, 92) + 1;
    v15 = (CHAR *)(String - v14);
    do
    {
      v16 = *v14;
      v14[(_QWORD)v15] = *v14;
      ++v14;
    }
    while ( v16 );
    *strrchr(Str, 92) = 0;
  }
  v22.hInstance = hInstance;
  v22.lpstrFilter = "DebugView Log (*.LOG)";
  v22.lpstrFile = String;
  v22.lpstrInitialDir = Str;
  v22.lpstrTitle = "Specify DebugView Log File...";
  v22.lpstrDefExt = "*.log";
  v22.lStructSize = 152;
  v22.hwndOwner = a1;
  v22.lpstrCustomFilter = 0i64;
  v22.nMaxCustFilter = 0;
  v22.nFilterIndex = 1;
  v22.nMaxFile = 260;
  v22.lpstrFileTitle = 0i64;
  v22.nMaxFileTitle = 0;
  *(_QWORD *)&v22.Flags = 2656260i64;
  v22.lpfnHook = 0i64;
  if ( GetSaveFileNameA(&v22) )
    SetDlgItemTextA(a1, 1024, String);
  return 1i64;
}
// 1400935A6: using guessed type char byte_1400935A6;
// 1400935A7: using guessed type char byte_1400935A7;
// 1400935C4: using guessed type int dword_1400935C4;
// 1400935D0: using guessed type char byte_1400935D0;
// 140012770: using guessed type CHAR Str[272];

//----- (0000000140012BF0) ----------------------------------------------------
int __fastcall sub_140012BF0(HWND hWndParent, char a2)
{
  char v3; // r15
  __int64 v4; // rsi
  __int64 v6; // rcx
  char v7; // al
  HWND *v8; // rbx
  __int64 v9; // rdi
  __int64 v10; // rcx
  char v11; // al
  char *i; // rax
  __int64 v13; // rax
  char v14; // cl
  char *v15; // rbx
  const char *v16; // rdx
  FILE *v17; // rax
  DWORD LastError; // eax
  INT_PTR v19; // rax
  fpos_t Position; // [rsp+40h] [rbp-C0h] BYREF
  CHAR Buffer[8]; // [rsp+48h] [rbp-B8h] BYREF
  char Str[64]; // [rsp+50h] [rbp-B0h] BYREF
  char v24[272]; // [rsp+90h] [rbp-70h] BYREF
  char FileName[272]; // [rsp+1A0h] [rbp+A0h] BYREF
  CHAR Text[256]; // [rsp+2B0h] [rbp+1B0h] BYREF

  v3 = 0;
  v4 = 0i64;
  if ( Stream )
  {
    v3 = 1;
    fclose(Stream);
    Stream = 0i64;
    dword_1400921E0 = -1;
  }
  while ( 1 )
  {
    v6 = 0i64;
    do
    {
      v7 = String[v6];
      FileName[v6++] = v7;
    }
    while ( v7 );
    if ( a2 )
    {
      if ( byte_1400935D0 )
      {
        v8 = &qword_1400A2648;
        v9 = 10i64;
        do
        {
          if ( *v8 )
            sub_14000A640(*v8);
          v8 += 48;
          --v9;
        }
        while ( v9 );
      }
      GetDateFormatA(0x400u, 0, 0i64, 0i64, DateStr, 64);
      v10 = 0i64;
      do
      {
        v11 = DateStr[v10];
        Str[v10++] = v11;
      }
      while ( v11 );
      for ( i = strchr(Str, 47); i; i = strchr(Str, 47) )
        *i = 45;
      v13 = 0i64;
      do
      {
        v14 = String[v13];
        v24[v13++] = v14;
      }
      while ( v14 );
      v15 = strrchr(v24, 46);
      if ( v15 && strrchr(v24, 92) <= v15 )
      {
        *v15 = 0;
        sub_140002490(FileName, "%s-%s.%s", v24, Str, v15 + 1);
      }
      else
      {
        sub_140002490(FileName, "%s-%s", v24, Str);
      }
    }
    if ( v3 && !a2 )
      break;
    v16 = "ab";
    if ( !byte_1400935A6 )
      v16 = "wb";
    v17 = fopen(FileName, v16);
    Stream = v17;
    if ( v17 )
    {
      setvbuf(v17, 0i64, 0, 0x8000ui64);
      if ( dword_1400935C4 )
      {
        if ( nIDButton == 1041 )
        {
          fgetpos(Stream, &Position);
          if ( dword_1400935C4 )
          {
            if ( Position / 0x100000 >= (unsigned int)dword_1400935C4 )
            {
              if ( byte_1400935A7 )
              {
                Position = 0i64;
                fsetpos(Stream, &Position);
              }
              else
              {
                MessageBoxA(::hWndParent, "The log file is full.", "DebugView", 0x30u);
                fclose(Stream);
                Stream = 0i64;
              }
            }
          }
        }
      }
      break;
    }
    LastError = GetLastError();
    FormatMessageA(0x1100u, 0i64, LastError, 0x400u, Buffer, 0, 0i64);
    sub_140002490(Text, "Error opening log file %s: %s", FileName, *(const char **)Buffer);
    MessageBoxA(hWndParent, Text, "DebugView", 0x10u);
    LocalFree(*(HLOCAL *)Buffer);
    v19 = DialogBoxParamA(hInstance, "LOGFILE", hWndParent, (DLGPROC)sub_140012770, 0i64);
    if ( !v19 )
    {
      byte_1400935AF = 0;
      return v19;
    }
  }
  CheckMenuItem(hMenu, 0x9C6Eu, Stream != 0i64 ? 8 : 0);
  LOBYTE(v4) = Stream != 0i64;
  byte_1400935AF = 1;
  SendMessageA(qword_1400A37E8, 0x42Bu, 0x9C6Eui64, v4 + 19);
  LODWORD(v19) = InvalidateRect(qword_1400A37E8, 0i64, 1);
  return v19;
}
// 1400921E0: using guessed type int dword_1400921E0;
// 1400935A6: using guessed type char byte_1400935A6;
// 1400935A7: using guessed type char byte_1400935A7;
// 1400935AF: using guessed type char byte_1400935AF;
// 1400935C4: using guessed type int dword_1400935C4;
// 1400935D0: using guessed type char byte_1400935D0;
// 140012BF0: using guessed type char FileName[272];
// 140012BF0: using guessed type char Str[64];
// 140012BF0: using guessed type char var_350[272];

//----- (0000000140013030) ----------------------------------------------------
bool __fastcall proc(HDC a1, int a2)
{
  bool result; // al

  result = 0;
  if ( !a2 )
    return byte_1400935AE == 0;
  return result;
}
// 1400935AE: using guessed type char byte_1400935AE;

//----- (0000000140013040) ----------------------------------------------------
INT_PTR __fastcall sub_140013040(HWND a1, int a2, __int16 a3)
{
  int v4; // edx
  int v5; // edx

  v4 = a2 - 16;
  if ( !v4 )
  {
LABEL_6:
    byte_1400935AE = 1;
    EnterCriticalSection(&CriticalSection);
    if ( qword_1400921D8 != (HANDLE)-1i64 )
      TerminateThread(qword_1400921D8, 0);
    qword_1400921D8 = (HANDLE)-1i64;
    LeaveCriticalSection(&CriticalSection);
    EndDialog(a1, 1i64);
    return 1i64;
  }
  v5 = v4 - 256;
  if ( v5 )
  {
    if ( v5 != 1 || a3 != 2 )
      return 0i64;
    goto LABEL_6;
  }
  return 1i64;
}
// 1400935AE: using guessed type char byte_1400935AE;

//----- (00000001400130D0) ----------------------------------------------------
int __fastcall sub_1400130D0(HWND a1, __int64 a2)
{
  __int64 v2; // rbx
  HWND v4; // r12
  int result; // eax
  int DeviceCaps; // eax
  unsigned int v7; // r14d
  HFONT FontA; // rax
  unsigned int v9; // esi
  unsigned int v10; // r13d
  int v11; // edi
  int v12; // eax
  unsigned __int64 v13; // r15
  __int64 v14; // rax
  int v15; // ebx
  unsigned int v16; // eax
  unsigned int v17; // edi
  WPARAM v18; // rsi
  unsigned int v19; // eax
  __int64 v20; // rax
  int v21; // ebx
  bool v22; // zf
  char *v23; // rax
  char *v24; // rcx
  unsigned int v25; // esi
  unsigned __int64 v26; // rax
  int v27; // ecx
  __int64 v28; // rax
  unsigned __int64 v29; // rax
  int v30; // [rsp+70h] [rbp-90h]
  int x; // [rsp+74h] [rbp-8Ch]
  unsigned int v32; // [rsp+78h] [rbp-88h]
  const char *v33; // [rsp+80h] [rbp-80h]
  struct tagPDA pPD; // [rsp+90h] [rbp-70h] BYREF
  struct tagSIZE sz; // [rsp+110h] [rbp+10h] BYREF
  HWND v37; // [rsp+118h] [rbp+18h]
  LRESULT v38; // [rsp+120h] [rbp+20h]
  HGDIOBJ h; // [rsp+128h] [rbp+28h]
  DOCINFOA v40; // [rsp+130h] [rbp+30h] BYREF
  LPARAM lParam; // [rsp+160h] [rbp+60h] BYREF
  int v42; // [rsp+168h] [rbp+68h]
  char *v43; // [rsp+178h] [rbp+78h]
  int v44; // [rsp+180h] [rbp+80h]
  struct tagTEXTMETRICA tm; // [rsp+1B0h] [rbp+B0h] BYREF
  char v46; // [rsp+1EFh] [rbp+EFh] BYREF
  CHAR String[8256]; // [rsp+1F0h] [rbp+F0h] BYREF
  char v48[4128]; // [rsp+2230h] [rbp+2130h] BYREF

  pPD.hwndOwner = a1;
  v2 = 384 * a2;
  pPD.lStructSize = 120;
  *(_QWORD *)&pPD.Flags = 262484i64;
  *(_OWORD *)&pPD.hDevMode = 0i64;
  v4 = (HWND)*((_QWORD *)&unk_1400A2640 + 48 * a2 + 1);
  pPD.hInstance = hInstance;
  v37 = v4;
  *(_DWORD *)&pPD.nMinPage = 0;
  pPD.nCopies = 0;
  memset(&pPD.lpfnPrintHook, 0, 32);
  result = PrintDlgA(&pPD);
  if ( result == 1 )
  {
    if ( SetAbortProc(pPD.hDC, (ABORTPROC)proc) == -1 )
      return MessageBoxA(a1, "Error setting up AbortProc", "DebugView", 0x10u);
    v40.lpszDocName = "DebugView Output";
    v40.cbSize = 40;
    v40.lpszOutput = 0i64;
    v40.fwType = 0;
    SendMessageA(hWndParent, 0x40Au, 0i64, (LPARAM)"Printing...");
    StartDocA(pPD.hDC, &v40);
    v38 = SendMessageA(v4, 0x1004u, 0i64, 0i64);
    DeviceCaps = GetDeviceCaps(pPD.hDC, 90);
    v7 = 2;
    FontA = CreateFontA(-10 * DeviceCaps / 72, 0, 0, 0, 400, 0, 0, 0, 1u, 2u, 1u, 0, 0, pszFaceName);
    h = SelectObject(pPD.hDC, FontA);
    GetTextMetricsA(pPD.hDC, &tm);
    v9 = tm.tmHeight + tm.tmExternalLeading;
    v30 = tm.tmHeight + tm.tmExternalLeading;
    GetTextExtentPointA(pPD.hDC, "-", 1, &sz);
    v10 = (GetDeviceCaps(pPD.hDC, 10) - 7 * v9) / v9;
    v11 = GetDeviceCaps(pPD.hDC, 112);
    x = v11;
    v12 = GetDeviceCaps(pPD.hDC, 8);
    v13 = (unsigned int)(v12 - v11) / sz.cx;
    StartPage(pPD.hDC);
    v33 = (char *)&unk_1400A2640 + v2 + 16;
    sub_140002490(String, "DebugView on \\\\%s - Page %d", v33, 1i64);
    v14 = -1i64;
    do
      ++v14;
    while ( String[v14] );
    v15 = v11;
    TextOutA(pPD.hDC, v11, 5 * v9, String, v14);
    sub_140002490(String, "Printing page %d...", 1i64);
    SendMessageA(hWndParent, 0x40Bu, 0i64, (LPARAM)String);
    v16 = 0;
    v17 = 1;
    v32 = 0;
LABEL_7:
    v43 = v48;
    v42 = 0;
    v44 = 4128;
    v18 = v16;
    SendMessageA(v4, 0x102Du, v16, (LPARAM)&lParam);
    v19 = sub_14003FD10((__int64)v48);
    if ( v19 < dword_14009E3A8 )
      goto LABEL_44;
    if ( v19 <= dword_14009E3A4 )
    {
      String[0] = 0;
      if ( v17 && !(v17 % v10) )
      {
        EndPage(pPD.hDC);
        StartPage(pPD.hDC);
        sub_140002490(String, "DebugView on \\\\%s - Page %d", v33, v7);
        v20 = -1i64;
        do
          ++v20;
        while ( String[v20] );
        TextOutA(pPD.hDC, v15, 5 * v30, String, v20);
        sub_140002490(String, "Printing page %d...", v7);
        SendMessageA(hWndParent, 0x40Bu, 0i64, (LPARAM)String);
        ++v7;
        v17 = 1;
      }
      v21 = 0;
      while ( 1 )
      {
        if ( v21 )
        {
          if ( v21 != 1 )
            goto LABEL_20;
          v22 = byte_14009E4C4 == 0;
        }
        else
        {
          v22 = byte_14009E4C5 == 0;
        }
        if ( !v22 )
        {
LABEL_20:
          v48[0] = 0;
          v43 = v48;
          v42 = v21;
          v44 = 4128;
          SendMessageA(v4, 0x102Du, v18, (LPARAM)&lParam);
          v23 = &v46;
          do
            v22 = *++v23 == 0;
          while ( !v22 );
          strcpy(v23, v48);
          v24 = &v46;
          do
            v22 = *++v24 == 0;
          while ( !v22 );
          strcpy(v24, "  ");
        }
        if ( (unsigned int)++v21 >= 3 )
        {
          v25 = 0;
          v26 = -1i64;
          do
            ++v26;
          while ( String[v26] );
          if ( v26 / v13 == -1i64 )
          {
            v15 = x;
          }
          else
          {
            do
            {
              if ( lstrlenA(&String[(unsigned int)v13 * v25]) >= (int)v13 )
                v27 = v13;
              else
                v27 = lstrlenA(&String[(unsigned int)v13 * v25]);
              v15 = x;
              TextOutA(pPD.hDC, x, v30 * (v17 % v10 + 5), &String[(unsigned int)v13 * v25], v27);
              if ( ++v17 && !(v17 % v10) )
              {
                EndPage(pPD.hDC);
                StartPage(pPD.hDC);
                sub_140002490(String, "DebugView on \\\\%s - Page %d", v33, v7);
                v28 = -1i64;
                do
                  ++v28;
                while ( String[v28] );
                TextOutA(pPD.hDC, x, 5 * v30, String, v28);
                sub_140002490(String, "Printing page %d...", v7);
                SendMessageA(hWndParent, 0x40Bu, 0i64, (LPARAM)String);
                ++v7;
                v17 = 1;
              }
              ++v25;
              v29 = -1i64;
              do
                ++v29;
              while ( String[v29] );
            }
            while ( v25 < v29 / v13 + 1 );
          }
          if ( byte_1400935AE )
            goto LABEL_50;
          v4 = v37;
LABEL_44:
          v16 = v32 + 1;
          v32 = v16;
          if ( v16 > (unsigned int)v38 )
            break;
          goto LABEL_7;
        }
      }
    }
    if ( !byte_1400935AE )
    {
      if ( EndPage(pPD.hDC) > 0 )
      {
        if ( EndDoc(pPD.hDC) <= 0 )
          MessageBoxA(a1, "Error in Printer EndDoc.", "DebugView", 0x10u);
      }
      else
      {
        MessageBoxA(a1, "Error in Printer EndPage.", "DebugView", 0x10u);
        AbortDoc(pPD.hDC);
      }
    }
LABEL_50:
    SelectObject(pPD.hDC, h);
    DeleteDC(pPD.hDC);
    if ( pPD.hDevMode )
      GlobalFree(pPD.hDevMode);
    if ( pPD.hDevNames )
      GlobalFree(pPD.hDevNames);
    return SendMessageA(hWndParent, 0x40Cu, 0i64, 0i64);
  }
  return result;
}
// 1400935AE: using guessed type char byte_1400935AE;
// 14009E3A4: using guessed type int dword_14009E3A4;
// 14009E3A8: using guessed type int dword_14009E3A8;
// 14009E4C4: using guessed type char byte_14009E4C4;
// 14009E4C5: using guessed type char byte_14009E4C5;
// 1400130D0: using guessed type CHAR String[8256];

//----- (0000000140013850) ----------------------------------------------------
INT_PTR __fastcall sub_140013850(HWND a1, int a2, __int16 a3, __int64 a4)
{
  HWND v5; // rbx
  int v6; // edx
  int v7; // edx
  INT_PTR v9; // rdx
  unsigned int v10; // eax
  UINT v11; // eax
  UINT v12; // esi
  unsigned int v13; // eax
  LPARAM lParam; // [rsp+20h] [rbp-10C8h] BYREF
  int v15; // [rsp+28h] [rbp-10C0h]
  CHAR *v16; // [rsp+38h] [rbp-10B0h]
  int v17; // [rsp+40h] [rbp-10A8h]
  CHAR String[32]; // [rsp+70h] [rbp-1078h] BYREF
  CHAR v19[32]; // [rsp+90h] [rbp-1058h] BYREF
  CHAR Text[4128]; // [rsp+B0h] [rbp-1038h] BYREF

  v5 = a1;
  v6 = a2 - 16;
  if ( !v6 )
  {
    v9 = 0i64;
    goto LABEL_17;
  }
  v7 = v6 - 256;
  if ( !v7 )
  {
    v12 = 0;
    v17 = 4128;
    v15 = 0;
    v16 = Text;
    SendMessageA(qword_1400A37F8, 0x102Du, 0i64, (LPARAM)&lParam);
    v13 = sub_14003FD10((__int64)Text);
    dword_14009B254 = v13;
    dword_14009B250 = *((_DWORD *)&unk_1400A2784 + 96 * a4);
    if ( dword_14009B250 == v13 )
    {
      MessageBoxA(hWndParent, "Nothing to print.", "DebugView", 0x30u);
      EndDialog(v5, 0i64);
      v13 = dword_14009B254;
    }
    sub_140002490(Text, "%d", v13);
    SetDlgItemTextA(v5, 1018, Text);
    sub_140002490(Text, "%d", (unsigned int)dword_14009B250);
    SetDlgItemTextA(v5, 1019, Text);
    CheckDlgButton(v5, 1021, byte_14009E4C5 != 0);
    LOBYTE(v12) = byte_14009E4C4 != 0;
    CheckDlgButton(v5, 1020, v12);
    return 1i64;
  }
  if ( v7 != 1 )
    return 0i64;
  if ( a3 == 1 )
  {
    GetDlgItemTextA(a1, 1018, String, 32);
    GetDlgItemTextA(v5, 1019, v19, 32);
    dword_14009E3A8 = sub_14003FD10((__int64)String);
    v10 = sub_14003FD10((__int64)v19);
    dword_14009E3A4 = v10;
    if ( dword_14009E3A8 >= (unsigned int)dword_14009B254 && v10 <= dword_14009B250 && v10 > dword_14009E3A8 )
    {
      byte_14009E4C5 = IsDlgButtonChecked(v5, 1021) == 1;
      v11 = IsDlgButtonChecked(v5, 1020);
      v9 = 1i64;
      a1 = v5;
      byte_14009E4C4 = v11 == 1;
      goto LABEL_17;
    }
    sub_140002490(
      Text,
      "Invalid range: range must be %d-%d.",
      (unsigned int)dword_14009B254,
      (unsigned int)dword_14009B250);
    MessageBoxA(v5, Text, "DebugView", 0x10u);
  }
  else if ( a3 == 2 )
  {
    v9 = 0i64;
LABEL_17:
    EndDialog(a1, v9);
  }
  return 1i64;
}
// 14009B250: using guessed type int dword_14009B250;
// 14009B254: using guessed type int dword_14009B254;
// 14009E3A4: using guessed type int dword_14009E3A4;
// 14009E3A8: using guessed type int dword_14009E3A8;
// 14009E4C4: using guessed type char byte_14009E4C4;
// 14009E4C5: using guessed type char byte_14009E4C5;

//----- (0000000140013B10) ----------------------------------------------------
void __fastcall sub_140013B10(__int64 a1)
{
  byte_1400935AE = 0;
  sub_1400130D0(hWndParent, a1);
  qword_1400921D8 = (HANDLE)-1i64;
}
// 1400935AE: using guessed type char byte_1400935AE;

//----- (0000000140013B40) ----------------------------------------------------
int __fastcall sub_140013B40(HWND a1, char *a2, HWND a3, char a4)
{
  __int64 v8; // rdi
  __int64 v9; // rcx
  char v10; // al
  char *v11; // rcx
  char v12; // al
  int result; // eax
  FILE *v14; // r12
  int v15; // eax
  WPARAM v16; // rsi
  __int64 v17; // r15
  int i; // ebx
  char *v19; // rax
  bool v20; // zf
  char *v21; // rcx
  char v22; // al
  struct tagOFNA v23; // [rsp+20h] [rbp-E0h] BYREF
  LPARAM lParam; // [rsp+C0h] [rbp-40h] BYREF
  int v25; // [rsp+C8h] [rbp-38h]
  char *v26; // [rsp+D8h] [rbp-28h]
  int v27; // [rsp+E0h] [rbp-20h]
  char FileName[272]; // [rsp+110h] [rbp+10h] BYREF
  char v29[4127]; // [rsp+220h] [rbp+120h] BYREF
  char v30; // [rsp+123Fh] [rbp+113Fh] BYREF
  char v31[8256]; // [rsp+1240h] [rbp+1140h] BYREF

  sub_140016650((__int64)FileName, 0, 0x104ui64);
  if ( a4 || !byte_1400935AD )
  {
    v11 = (char *)(FileName - a2);
    do
    {
      v12 = *a2;
      a2[(_QWORD)v11] = *a2;
      ++a2;
    }
    while ( v12 );
    v8 = 0i64;
    v23.hInstance = hInstance;
    v23.lStructSize = 152;
    v23.lpstrFilter = "DebugView Data (*.LOG)";
    v23.lpstrFile = FileName;
    v23.lpstrTitle = "Save DebugView Output to File...";
    v23.lpstrDefExt = "*.log";
    v23.hwndOwner = a1;
    v23.lpstrCustomFilter = 0i64;
    v23.nMaxCustFilter = 0;
    v23.nFilterIndex = 1;
    v23.nMaxFile = 256;
    v23.lpstrFileTitle = 0i64;
    v23.nMaxFileTitle = 0;
    v23.lpstrInitialDir = 0i64;
    *(_QWORD *)&v23.Flags = 2097158i64;
    v23.lpfnHook = 0i64;
    result = GetSaveFileNameA(&v23);
    if ( !result )
      return result;
  }
  else
  {
    v8 = 0i64;
    v9 = 0i64;
    do
    {
      v10 = byte_14009E3C0[v9];
      FileName[v9++] = v10;
    }
    while ( v10 );
  }
  v14 = fopen(FileName, "w");
  if ( !v14 )
    return MessageBoxA(0i64, "Create File Failed.", "Save Error", 0x10u);
  SetCapture(a1);
  qword_1400A05A8 = SetCursor(qword_1400A05A0);
  v15 = SendMessageA(a3, 0x1004u, 0i64, 0i64);
  if ( v15 > 0 )
  {
    v16 = 0i64;
    v17 = (unsigned int)v15;
    do
    {
      v31[0] = 0;
      for ( i = 0; i < 3; ++i )
      {
        v29[0] = 0;
        v26 = v29;
        v25 = i;
        v27 = 4128;
        SendMessageA(a3, 0x102Du, v16, (LPARAM)&lParam);
        v19 = &v30;
        do
          v20 = *++v19 == 0;
        while ( !v20 );
        strcpy(v19, v29);
        v21 = &v30;
        do
          v20 = *++v21 == 0;
        while ( !v20 );
        strcpy(v21, "\t");
      }
      sub_14000EF30((__int64)v14, (__int64)"%s\n", v31);
      ++v16;
      --v17;
    }
    while ( v17 );
  }
  fclose(v14);
  do
  {
    v22 = FileName[v8];
    byte_14009E3C0[v8++] = v22;
  }
  while ( v22 );
  byte_1400935AD = 1;
  SetCursor(qword_1400A05A8);
  return ReleaseCapture();
}
// 1400935AD: using guessed type char byte_1400935AD;
// 14009E3C0: using guessed type _BYTE byte_14009E3C0[260];
// 140013B40: using guessed type char FileName[272];
// 140013B40: using guessed type char var_2080[8256];

//----- (0000000140013E50) ----------------------------------------------------
void __fastcall CompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
{
  CloseHandle(lpOverlapped->hEvent);
  j__free_base(lpOverlapped);
}

//----- (0000000140013E70) ----------------------------------------------------
BOOL __fastcall sub_140013E70(
        HWND hWnd,
        unsigned int a2,
        void *a3,
        DWORD a4,
        LPDWORD lpNumberOfBytesRead,
        char a6,
        DWORD dwMilliseconds)
{
  __int64 v11; // rbp
  struct _OVERLAPPED *lpOverlapped; // r15
  void *v13; // rcx
  BOOL File; // edi
  bool v16; // zf
  HMENU SubMenu; // rax

  v11 = 384i64 * a2;
  lpOverlapped = (struct _OVERLAPPED *)((char *)&unk_1400A2640 + v11 + 336);
  lpOverlapped->Internal = 0i64;
  lpOverlapped->InternalHigh = 0i64;
  lpOverlapped->Pointer = 0i64;
  lpOverlapped->hEvent = 0i64;
  v13 = *(void **)((char *)&unk_1400A2640 + v11 + 368);
  *(_QWORD *)((char *)&unk_1400A2640 + v11 + 360) = v13;
  ResetEvent(v13);
  File = ReadFile(*(HANDLE *)((char *)&unk_1400A2640 + v11 + 280), a3, a4, lpNumberOfBytesRead, lpOverlapped);
  if ( File )
    return File;
  if ( GetLastError() != 997 )
  {
    if ( !*((_BYTE *)&unk_1400A2640 + v11 + 1) )
    {
      GetLastError();
      v16 = (_DWORD)ArgList == a2;
      *((_BYTE *)&unk_1400A2640 + v11 + 1) = 1;
      if ( v16 )
        sub_140009E50(hWnd, a2);
      sub_140002490(TimeStr, "The connection with %s was broken", (const char *)&unk_1400A2640 + v11 + 16);
      if ( a2 == (_DWORD)ArgList )
        sub_140002F30(hWndParent, a2, a2);
      MessageBoxA(hWnd, TimeStr, "DebugView", 0x30u);
      SubMenu = GetSubMenu(hMenu, 4);
      SetMenuItemBitmaps(SubMenu, a2 + 50000, 0, qword_1400A05B0, hBitmapChecked);
    }
    return File;
  }
  return a6 != File
      && (!dwMilliseconds || WaitForSingleObject(*(HANDLE *)((char *)&unk_1400A2640 + v11 + 368), dwMilliseconds) != 258)
      && GetOverlappedResult(
           *(HANDLE *)((char *)&unk_1400A2640 + v11 + 280),
           (LPOVERLAPPED)((char *)&unk_1400A2640 + v11 + 336),
           lpNumberOfBytesRead,
           1);
}

//----- (0000000140014040) ----------------------------------------------------
__int64 __fastcall sub_140014040(
        HWND hWnd,
        unsigned int a2,
        const void *a3,
        DWORD a4,
        LPDWORD lpNumberOfBytesWritten,
        char a6,
        char a7)
{
  __int64 v8; // rbx
  struct _OVERLAPPED *lpOverlapped; // rdi
  __int64 v12; // rbp
  void *v13; // rcx
  BOOL v14; // eax
  unsigned int OverlappedResult; // esi
  HMENU SubMenu; // rax

  v8 = a2;
  lpOverlapped = (struct _OVERLAPPED *)j__malloc_base(0x20ui64);
  lpOverlapped->Internal = 0i64;
  lpOverlapped->InternalHigh = 0i64;
  lpOverlapped->Pointer = 0i64;
  lpOverlapped->hEvent = 0i64;
  lpOverlapped->hEvent = CreateEventA(0i64, 1, 0, 0i64);
  v12 = 384 * v8;
  v13 = (void *)*((_QWORD *)&unk_1400A2640 + 48 * v8 + 35);
  if ( a6 )
    v14 = WriteFile(v13, a3, a4, lpNumberOfBytesWritten, lpOverlapped);
  else
    v14 = WriteFileEx(v13, a3, a4, lpOverlapped, (LPOVERLAPPED_COMPLETION_ROUTINE)CompletionRoutine);
  OverlappedResult = v14;
  if ( !v14 )
  {
    if ( GetLastError() != 997 )
      goto LABEL_22;
    if ( a6 == (_BYTE)OverlappedResult )
      return 0i64;
    OverlappedResult = GetOverlappedResult(
                         *(HANDLE *)((char *)&unk_1400A2640 + v12 + 280),
                         lpOverlapped,
                         lpNumberOfBytesWritten,
                         OverlappedResult + 1);
    if ( !OverlappedResult )
    {
LABEL_22:
      if ( !*((_BYTE *)&unk_1400A2640 + v12 + 1) )
      {
        *((_BYTE *)&unk_1400A2640 + v12 + 1) = 1;
        sub_140002490(TimeStr, "The connection with %s was broken", (const char *)&unk_1400A2640 + v12 + 16);
        if ( (_DWORD)ArgList == (_DWORD)v8 )
        {
          sub_140009E50(hWnd, v8);
          if ( (_DWORD)v8 == (_DWORD)ArgList )
            sub_140002F30(hWndParent, v8, v8);
        }
        if ( a7 )
          LeaveCriticalSection(&CriticalSection);
        MessageBoxA(hWnd, TimeStr, "DebugView", 0x30u);
        SubMenu = GetSubMenu(hMenu, 4);
        SetMenuItemBitmaps(SubMenu, v8 + 50000, 0, qword_1400A05B0, hBitmapChecked);
        if ( a7 )
          EnterCriticalSection(&CriticalSection);
      }
    }
  }
  CloseHandle(lpOverlapped->hEvent);
  if ( a6 )
    j__free_base(lpOverlapped);
  return OverlappedResult;
}

//----- (0000000140014250) ----------------------------------------------------
DWORD __fastcall sub_140014250(int a1, int a2)
{
  _DWORD *v4; // rax

  v4 = j__malloc_base(8ui64);
  *v4 = a1;
  v4[1] = a2;
  return QueueUserAPC((PAPCFUNC)sub_1400142C0, (HANDLE)qword_14009E210, (ULONG_PTR)v4);
}
// 14009E210: using guessed type __int64 qword_14009E210;

//----- (0000000140014290) ----------------------------------------------------
void __fastcall __noreturn sub_140014290(void *a1)
{
  while ( 1 )
    SleepEx(0xFFFFFFFF, 1);
}

//----- (00000001400142C0) ----------------------------------------------------
void __fastcall sub_1400142C0(unsigned int *Block)
{
  unsigned int *v1; // r14
  DWORD TickCount; // r15d
  unsigned int v3; // esi
  void **v4; // rdi
  void *v5; // rax
  HWND v6; // rcx
  __int64 v7; // r12
  int *v8; // rdx
  __int64 v9; // r8
  int v10; // eax
  HMENU SubMenu; // rax
  int v13; // [rsp+98h] [rbp+20h] BYREF
  DWORD NumberOfBytesRead; // [rsp+A0h] [rbp+28h] BYREF
  DWORD v15; // [rsp+A8h] [rbp+30h] BYREF

  v1 = Block;
  switch ( Block[1] )
  {
    case 0u:
      TickCount = GetTickCount();
      if ( !byte_1400921B1 || !byte_1400A2770 )
        goto LABEL_21;
      TickCount = GetTickCount();
      break;
    case 1u:
      v13 = -2096824320;
      goto LABEL_54;
    case 2u:
      v13 = -2096824316;
      goto LABEL_54;
    case 3u:
      v13 = -2096824296;
      goto LABEL_54;
    case 4u:
      v13 = -2096824292;
      goto LABEL_54;
    case 5u:
      v13 = -2096824312;
      goto LABEL_54;
    case 6u:
      v13 = -2096824304;
      goto LABEL_54;
    case 7u:
      v13 = -2096824300;
      goto LABEL_54;
    case 8u:
      v13 = -2096824268;
      goto LABEL_54;
    case 9u:
      v13 = -2096824264;
LABEL_54:
      sub_140014040(hWndParent, *Block, &v13, 4u, &NumberOfBytesRead, 1, 0);
      goto LABEL_55;
    default:
      goto LABEL_55;
  }
  while ( hDevice == (HANDLE)-1i64
       || DeviceIoControl(hDevice, 0x8305000F, 0i64, 0, &unk_1400A3880, 0xFF0u, &::NumberOfBytesRead, 0i64) )
  {
    if ( byte_1400921B1 )
    {
      if ( byte_1400A2772 )
      {
        if ( WaitForSingleObject(qword_1400A3680, 0) == 258 )
          SetEvent(qword_1400A3690);
        else
          sub_14000A960(0);
      }
      if ( byte_1400A2773 )
      {
        if ( WaitForSingleObject(qword_1400A3688, 0) == 258 )
          SetEvent(qword_1400A3698);
        else
          sub_14000A960(1u);
      }
    }
    if ( ::NumberOfBytesRead || byte_1400935AC )
    {
      dword_14009E200 = ::NumberOfBytesRead;
      qword_14009E1F0 = qword_1400A2648;
      qword_14009E1F8 = (__int64)&unk_1400A3880;
      SendMessageA(hWndParent, 0x401u, 0i64, 0i64);
      WaitForSingleObject(qword_14009E208, 0xFFFFFFFF);
      if ( GetTickCount() - TickCount <= 0x12C )
        continue;
    }
    goto LABEL_21;
  }
  sub_140002BF0(hWndParent, "Couldn't access device driver");
LABEL_21:
  v3 = 1;
  v4 = (void **)&unk_1400A2938;
  do
  {
    EnterCriticalSection(&CriticalSection);
    if ( *(v4 - 46) && !*((_BYTE *)v4 - 375) )
    {
      if ( !*v4 )
      {
        v5 = j__malloc_base(0xFF0ui64);
        v6 = hWndParent;
        *v4 = v5;
        sub_140013E70(v6, v3, v5, 4u, &NumberOfBytesRead, 0, 0);
      }
      v7 = 384i64 * v3;
      if ( GetOverlappedResult(*(v4 - 12), (LPOVERLAPPED)((char *)&unk_1400A2790 + v7), &::NumberOfBytesRead, 0) )
      {
        while ( 1 )
        {
          v8 = (int *)*v4;
          v9 = ::NumberOfBytesRead - 4;
          ::NumberOfBytesRead = v9;
          v10 = *v8;
          if ( (unsigned int)v9 < *v8 )
          {
            while ( sub_140013E70(hWndParent, v3, (char *)v8 + v9 + 4, v10 - v9, &v15, 1, 0) )
            {
              v8 = (int *)*v4;
              ::NumberOfBytesRead += v15;
              v9 = ::NumberOfBytesRead;
              v10 = *v8;
              if ( ::NumberOfBytesRead >= *v8 )
                goto LABEL_32;
            }
            ::NumberOfBytesRead = 0;
          }
LABEL_32:
          if ( byte_1400921B2 )
          {
            LeaveCriticalSection(&CriticalSection);
            qword_14009E1F0 = (HWND)*(v4 - 46);
            qword_14009E1F8 = (__int64)*v4 + 4;
            dword_14009E200 = ::NumberOfBytesRead - 4;
            SendMessageA(hWndParent, 0x401u, 0i64, 0i64);
            WaitForSingleObject(qword_14009E208, 0xFFFFFFFF);
            EnterCriticalSection(&CriticalSection);
          }
          if ( !*(v4 - 46) )
            break;
          if ( *((_BYTE *)v4 - 375) )
            break;
          sub_140013E70(hWndParent, v3, *v4, 4u, &::NumberOfBytesRead, 0, 0);
          if ( GetTickCount() - TickCount > 0x12C )
            break;
          if ( !GetOverlappedResult(*(v4 - 12), (LPOVERLAPPED)((char *)&unk_1400A2790 + v7), &::NumberOfBytesRead, 0) )
            goto LABEL_38;
        }
      }
      else
      {
LABEL_38:
        if ( GetLastError() != 996 && !*((_BYTE *)v4 - 375) )
        {
          *((_BYTE *)v4 - 375) = 1;
          LeaveCriticalSection(&CriticalSection);
          if ( (_DWORD)ArgList == v3 )
          {
            sub_140009E50(hWndParent, v3);
            sub_140002F30(hWndParent, v3, v3);
          }
          sub_140002490(TimeStr, "The connection with %s was broken", &byte_1400A2650[v7]);
          MessageBoxA(hWndParent, TimeStr, "DebugView", 0x10030u);
          SubMenu = GetSubMenu(hMenu, 4);
          SetMenuItemBitmaps(SubMenu, v3 + 50000, 0, qword_1400A05B0, hBitmapChecked);
          EnterCriticalSection(&CriticalSection);
        }
      }
    }
    LeaveCriticalSection(&CriticalSection);
    ++v3;
    v4 += 48;
  }
  while ( v3 < 0xA );
  v1 = Block;
LABEL_55:
  j__free_base(v1);
}
// 1400921B1: using guessed type char byte_1400921B1;
// 1400921B2: using guessed type char byte_1400921B2;
// 1400935AC: using guessed type char byte_1400935AC;
// 14009E1F8: using guessed type __int64 qword_14009E1F8;
// 14009E200: using guessed type int dword_14009E200;
// 1400A2770: using guessed type char byte_1400A2770;
// 1400A2772: using guessed type char byte_1400A2772;
// 1400A2773: using guessed type char byte_1400A2773;

//----- (0000000140015680) ----------------------------------------------------
void sub_140015680()
{
  sub_1400533B4(2);
}

//----- (0000000140015CD0) ----------------------------------------------------
__int64 __fastcall UserMathErrorFunction(struct _exception *a1)
{
  return 0i64;
}

//----- (0000000140015CDC) ----------------------------------------------------
__int64 sub_140015CDC()
{
  return 0i64;
}

//----- (0000000140015CE8) ----------------------------------------------------
__int64 sub_140015CE8()
{
  return 0i64;
}

//----- (0000000140015CEC) ----------------------------------------------------
__int64 sub_140015CEC()
{
  return 0i64;
}

//----- (0000000140015CF0) ----------------------------------------------------
void sub_140015CF0()
{
  InitializeSListHead(stru_14009B850);
}
// 14009B850: using guessed type union _SLIST_HEADER stru_14009B850[2];

//----- (0000000140015D00) ----------------------------------------------------
__int64 sub_140015D00()
{
  return _std_type_info_destroy_list(stru_14009B850);
}
// 140016F80: using guessed type __int64 __fastcall _std_type_info_destroy_list(_QWORD);
// 14009B850: using guessed type union _SLIST_HEADER stru_14009B850[2];

//----- (0000000140015D0C) ----------------------------------------------------
char sub_140015D0C()
{
  return 1;
}

//----- (0000000140015D40) ----------------------------------------------------
void *sub_140015D40()
{
  return &unk_1400A8548;
}

//----- (0000000140015D48) ----------------------------------------------------
void *sub_140015D48()
{
  return &unk_1400A8540;
}

//----- (0000000140015D50) ----------------------------------------------------
void sub_140015D50()
{
  dword_14009B870 = 0;
}
// 14009B870: using guessed type int dword_14009B870;

//----- (0000000140015EE8) ----------------------------------------------------
__int64 sub_140015EE8()
{
  return 0i64;
}

//----- (0000000140015F50) ----------------------------------------------------
__int64 sub_140015F50()
{
  return 0i64;
}

//----- (0000000140015F8C) ----------------------------------------------------
void sub_140015F8C()
{
  void (**i)(void); // rbx

  for ( i = qword_1400881C0; i < qword_1400881C0; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1400881C0: using guessed type void (*qword_1400881C0[2])(void);

//----- (0000000140015FC8) ----------------------------------------------------
void __fastcall sub_140015FC8()
{
  void (**i)(void); // rbx

  for ( i = &qword_1400881D0; i < &qword_1400881D0; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1400881D0: using guessed type void (*qword_1400881D0)(void);

//----- (0000000140016008) ----------------------------------------------------
__int64 __fastcall sub_140016008(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014001600C) ----------------------------------------------------
__int64 __fastcall sub_14001600C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001400161D0) ----------------------------------------------------
__int64 __fastcall sub_1400161D0(void *a1, __int64 a2, unsigned __int64 a3)
{
  const void *v3; // r10
  __int64 v4; // r11
  __int64 result; // rax

  result = v4;
  qmemcpy(a1, v3, a3);
  return result;
}
// 1400161D2: variable 'v4' is possibly undefined
// 1400161DE: variable 'v3' is possibly undefined

//----- (00000001400161F0) ----------------------------------------------------
__int64 __fastcall sub_1400161F0(__m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  bool v5; // cf
  __int64 v6; // rdx
  __int64 result; // rax
  __m128i v8; // xmm1
  __int8 v9; // r8
  __int16 v10; // cx
  __int8 v11; // r9
  __int8 v12; // r8
  __int16 v13; // r8
  __int16 v14; // r8
  __int8 v15; // r9
  __int32 v16; // ecx
  __int8 v17; // r9
  __int8 v18; // cl
  __int16 v19; // cx
  __int32 v20; // ecx
  __int32 v21; // ecx
  __int16 v22; // r9
  __int32 v23; // ecx
  __int16 v24; // r9
  __int8 v25; // r10
  __m128 v26; // xmm0
  __int8 *v27; // r8
  unsigned __int64 v28; // rcx
  __m128 v29; // xmm1
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // r8
  unsigned __int64 v32; // r9
  __int128 v33; // xmm0
  __int128 v34; // xmm1
  __int128 v35; // xmm1
  __int128 v36; // xmm1
  __m128 v37; // xmm0
  __m128 v38; // xmm1
  unsigned __int64 j; // r9
  unsigned __int64 v40; // r8
  __m128 v41; // xmm0
  __m128 v42; // xmm1
  __m128 v43; // xmm1
  __m128 v44; // xmm0
  __m128 v45; // xmm1
  __int8 *v46; // rcx
  __int128 v47; // xmm0
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // r8
  _OWORD *v50; // rax
  __int128 v51; // xmm1
  unsigned __int64 v52; // r9
  __int128 v53; // xmm0
  __int128 v54; // xmm1
  __int128 v55; // xmm1
  __int128 v56; // xmm1
  __int128 v57; // xmm0
  __int128 v58; // xmm1
  unsigned __int64 i; // r9

  result = (__int64)a1;
  switch ( a3 )
  {
    case 0ui64:
      return result;
    case 1ui64:
      a1->m128i_i8[0] = a2->m128i_i8[0];
      break;
    case 2ui64:
      a1->m128i_i16[0] = a2->m128i_i16[0];
      break;
    case 3ui64:
      v9 = a2->m128i_i8[2];
      a1->m128i_i16[0] = a2->m128i_i16[0];
      a1->m128i_i8[2] = v9;
      break;
    case 4ui64:
      a1->m128i_i32[0] = a2->m128i_i32[0];
      break;
    case 5ui64:
      v12 = a2->m128i_i8[4];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i8[4] = v12;
      break;
    case 6ui64:
      v13 = a2->m128i_i16[2];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i16[2] = v13;
      break;
    case 7ui64:
      v14 = a2->m128i_i16[2];
      v15 = a2->m128i_i8[6];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i16[2] = v14;
      a1->m128i_i8[6] = v15;
      break;
    case 8ui64:
      a1->m128i_i64[0] = a2->m128i_i64[0];
      break;
    case 9ui64:
      v18 = a2->m128i_i8[8];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_BYTE *)(result + 8) = v18;
      break;
    case 0xAui64:
      v19 = a2->m128i_i16[4];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_WORD *)(result + 8) = v19;
      break;
    case 0xBui64:
      v10 = a2->m128i_i16[4];
      v11 = a2->m128i_i8[10];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_WORD *)(result + 8) = v10;
      *(_BYTE *)(result + 10) = v11;
      break;
    case 0xCui64:
      v20 = a2->m128i_i32[2];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_DWORD *)(result + 8) = v20;
      break;
    case 0xDui64:
      v16 = a2->m128i_i32[2];
      v17 = a2->m128i_i8[12];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_DWORD *)(result + 8) = v16;
      *(_BYTE *)(result + 12) = v17;
      break;
    case 0xEui64:
      v21 = a2->m128i_i32[2];
      v22 = a2->m128i_i16[6];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_DWORD *)(result + 8) = v21;
      *(_WORD *)(result + 12) = v22;
      break;
    case 0xFui64:
      v23 = a2->m128i_i32[2];
      v24 = a2->m128i_i16[6];
      v25 = a2->m128i_i8[14];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_DWORD *)(result + 8) = v23;
      *(_WORD *)(result + 12) = v24;
      *(_BYTE *)(result + 14) = v25;
      break;
    case 0x10ui64:
      *a1 = _mm_loadu_si128(a2);
      break;
    default:
      if ( a3 <= 0x20 )
      {
        v8 = *(const __m128i *)((char *)&a2[-1] + a3);
        *a1 = *a2;
        *(__m128i *)((char *)&a1[-1] + a3) = v8;
        result = (__int64)a1;
      }
      else
      {
        v5 = a2 < a1;
        v6 = (char *)a2 - (char *)a1;
        if ( v5 && a1 < (__m128i *)&a2->m128i_i8[a3] )
        {
          v46 = &a1->m128i_i8[a3];
          v47 = *(_OWORD *)&v46[v6 - 16];
          v48 = (unsigned __int64)(v46 - 16);
          v49 = a3 - 16;
          if ( (v48 & 0xF) != 0 )
          {
            v50 = (_OWORD *)v48;
            v48 &= 0xFFFFFFFFFFFFFFF0ui64;
            v51 = v47;
            v47 = *(_OWORD *)(v48 + v6);
            *v50 = v51;
            v49 = v48 - (_QWORD)a1;
          }
          v52 = v49 >> 7;
          if ( v49 >> 7 )
          {
            for ( *(_OWORD *)v48 = v47; ; *(_OWORD *)v48 = v58 )
            {
              v53 = *(_OWORD *)(v48 + v6 - 16);
              v54 = *(_OWORD *)(v48 + v6 - 32);
              v48 -= 128i64;
              *(_OWORD *)(v48 + 112) = v53;
              *(_OWORD *)(v48 + 96) = v54;
              v55 = *(_OWORD *)(v48 + v6 + 64);
              --v52;
              *(_OWORD *)(v48 + 80) = *(_OWORD *)(v48 + v6 + 80);
              *(_OWORD *)(v48 + 64) = v55;
              v56 = *(_OWORD *)(v48 + v6 + 32);
              *(_OWORD *)(v48 + 48) = *(_OWORD *)(v48 + v6 + 48);
              *(_OWORD *)(v48 + 32) = v56;
              v57 = *(_OWORD *)(v48 + v6 + 16);
              v58 = *(_OWORD *)(v48 + v6);
              if ( !v52 )
                break;
              *(_OWORD *)(v48 + 16) = v57;
            }
            *(_OWORD *)(v48 + 16) = v57;
            v49 &= 0x7Fu;
            v47 = v58;
          }
          for ( i = v49 >> 4; i; --i )
          {
            *(_OWORD *)v48 = v47;
            v48 -= 16i64;
            v47 = *(_OWORD *)(v48 + v6);
          }
          if ( (v49 & 0xF) != 0 )
            *a1 = *a2;
          *(_OWORD *)v48 = v47;
          result = (__int64)a1;
        }
        else
        {
          if ( a3 <= 0x80 )
          {
            v26 = *(__m128 *)((char *)a1 + v6);
            v28 = (unsigned __int64)&a1[1];
            v31 = a3 - 16;
          }
          else
          {
            if ( _bittest(&dword_14009B874, 1u) )
              return sub_1400161D0(a1, v6, a3);
            v26 = *(__m128 *)((char *)a1 + v6);
            v27 = &a1->m128i_i8[a3];
            v28 = (unsigned __int64)&a1[1];
            if ( ((unsigned __int8)a1 & 0xF) != 0 )
            {
              v29 = v26;
              v30 = v28 & 0xFFFFFFFFFFFFFFF0ui64;
              v26 = *(__m128 *)(v30 + v6);
              v28 = v30 + 16;
              *a1 = (__m128i)v29;
            }
            v31 = (unsigned __int64)&v27[-v28];
            v32 = v31 >> 7;
            if ( v31 >> 7 )
            {
              *(__m128 *)(v28 - 16) = v26;
              if ( v32 <= qword_1400929D8 )
              {
                while ( 1 )
                {
                  v33 = *(_OWORD *)(v28 + v6);
                  v34 = *(_OWORD *)(v28 + v6 + 16);
                  v28 += 128i64;
                  *(_OWORD *)(v28 - 128) = v33;
                  *(_OWORD *)(v28 - 112) = v34;
                  v35 = *(_OWORD *)(v28 + v6 - 80);
                  --v32;
                  *(_OWORD *)(v28 - 96) = *(_OWORD *)(v28 + v6 - 96);
                  *(_OWORD *)(v28 - 80) = v35;
                  v36 = *(_OWORD *)(v28 + v6 - 48);
                  *(_OWORD *)(v28 - 64) = *(_OWORD *)(v28 + v6 - 64);
                  *(_OWORD *)(v28 - 48) = v36;
                  v37 = *(__m128 *)(v28 + v6 - 32);
                  v38 = *(__m128 *)(v28 + v6 - 16);
                  if ( !v32 )
                    break;
                  *(__m128 *)(v28 - 32) = v37;
                  *(__m128 *)(v28 - 16) = v38;
                }
              }
              else
              {
                while ( 1 )
                {
                  _mm_prefetch((const char *)(v28 + v6 + 512), 0);
                  v41 = *(__m128 *)(v28 + v6);
                  v42 = *(__m128 *)(v28 + v6 + 16);
                  v28 += 128i64;
                  _mm_stream_ps((float *)(v28 - 128), v41);
                  _mm_stream_ps((float *)(v28 - 112), v42);
                  v43 = *(__m128 *)(v28 + v6 - 80);
                  --v32;
                  _mm_stream_ps((float *)(v28 - 96), *(__m128 *)(v28 + v6 - 96));
                  _mm_stream_ps((float *)(v28 - 80), v43);
                  v44 = *(__m128 *)(v28 + v6 - 64);
                  v45 = *(__m128 *)(v28 + v6 - 48);
                  _mm_prefetch((const char *)(v28 + v6 + 576), 0);
                  _mm_stream_ps((float *)(v28 - 64), v44);
                  _mm_stream_ps((float *)(v28 - 48), v45);
                  v37 = *(__m128 *)(v28 + v6 - 32);
                  v38 = *(__m128 *)(v28 + v6 - 16);
                  if ( !v32 )
                    break;
                  _mm_stream_ps((float *)(v28 - 32), v37);
                  _mm_stream_ps((float *)(v28 - 16), v38);
                }
                _mm_sfence();
              }
              *(__m128 *)(v28 - 32) = v37;
              v31 &= 0x7Fu;
              v26 = v38;
            }
          }
          for ( j = v31 >> 4; j; --j )
          {
            *(__m128 *)(v28 - 16) = v26;
            v26 = *(__m128 *)(v28 + v6);
            v28 += 16i64;
          }
          v40 = v31 & 0xF;
          if ( v40 )
            *(_OWORD *)(v28 + v40 - 16) = *(_OWORD *)(v28 + v40 + v6 - 16);
          *(__m128 *)(v28 - 16) = v26;
          result = (__int64)a1;
        }
      }
      break;
  }
  return result;
}
// 1400929D8: using guessed type __int64 qword_1400929D8;
// 14009B874: using guessed type int dword_14009B874;

//----- (0000000140016630) ----------------------------------------------------
__int64 __fastcall sub_140016630(void *a1, char a2, unsigned __int64 a3)
{
  __int64 v3; // r11

  memset(a1, a2, a3);
  return v3;
}
// 14001663B: variable 'v3' is possibly undefined

//----- (0000000140016650) ----------------------------------------------------
__int64 __fastcall sub_140016650(__int64 a1, unsigned __int8 a2, unsigned __int64 a3)
{
  __m128i v4; // xmm0
  __int8 *v5; // r8
  __m128i *v6; // rcx
  unsigned __int64 v7; // r9
  unsigned __int64 i; // r9
  unsigned __int64 v9; // r8
  __int64 result; // rax
  __int64 v11; // rdx

  v11 = 0x101010101010101i64 * a2;
  v6 = (__m128i *)(a3 + a1);
  result = a1;
  switch ( a3 )
  {
    case 0ui64:
      return result;
    case 1ui64:
      goto LABEL_16;
    case 2ui64:
      goto LABEL_24;
    case 3ui64:
      goto LABEL_15;
    case 4ui64:
      goto LABEL_18;
    case 5ui64:
      goto LABEL_21;
    case 6ui64:
      goto LABEL_23;
    case 7ui64:
      goto LABEL_14;
    case 8ui64:
      *(_QWORD *)a1 = v11;
      return result;
    case 9ui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 7) = v11;
      v6[-1].m128i_i8[15] = v11;
      return result;
    case 0xAui64:
      *(_QWORD *)a1 = v11;
      *(_WORD *)(a1 + 8) = v11;
      return result;
    case 0xBui64:
      *(_QWORD *)a1 = v11;
      *(_WORD *)(a1 + 8) = v11;
      *(_BYTE *)(a1 + 10) = v11;
      return result;
    case 0xCui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 4) = v11;
LABEL_18:
      v6[-1].m128i_i32[3] = v11;
      return result;
    case 0xDui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 3) = v11;
LABEL_21:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 3) = v11;
      v6[-1].m128i_i8[15] = v11;
      return result;
    case 0xEui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 2) = v11;
LABEL_23:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 2) = v11;
LABEL_24:
      v6[-1].m128i_i16[7] = v11;
      return result;
    case 0xFui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 1) = v11;
LABEL_14:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 1) = v11;
LABEL_15:
      *(__int16 *)((char *)&v6[-1].m128i_i16[6] + 1) = v11;
LABEL_16:
      v6[-1].m128i_i8[15] = v11;
      return result;
    case 0x10ui64:
      *(_QWORD *)a1 = v11;
      *(_QWORD *)(a1 + 8) = v11;
      return result;
    default:
      v4 = _mm_unpacklo_epi8((__m128i)0x140000000ui64, (__m128i)0x140000000ui64);
      if ( a3 <= 0x80 )
        goto LABEL_7;
      if ( _bittest(&dword_14009B874, 1u) )
        return sub_140016630(v6, v11, a3);
      *v6 = v4;
      v5 = &v6->m128i_i8[a3];
      v6 = (__m128i *)((unsigned __int64)&v6[1] & 0xFFFFFFFFFFFFFFF0ui64);
      a3 = v5 - (__int8 *)v6;
      v7 = a3 >> 7;
      if ( a3 >> 7 )
      {
        do
        {
          *v6 = v4;
          v6[1] = v4;
          v6 += 8;
          v6[-6] = v4;
          v6[-5] = v4;
          --v7;
          v6[-4] = v4;
          v6[-3] = v4;
          v6[-2] = v4;
          v6[-1] = v4;
        }
        while ( v7 );
        a3 &= 0x7Fu;
      }
LABEL_7:
      for ( i = a3 >> 4; i; --i )
        *v6++ = v4;
      v9 = a3 & 0xF;
      if ( v9 )
        *(__m128i *)((char *)&v6[-1] + v9) = v4;
      return a1;
  }
}
// 14009B874: using guessed type int dword_14009B874;

//----- (0000000140016E64) ----------------------------------------------------
void __fastcall sub_140016E64(__int64 a1, void *a2)
{
  j__free_base(a2);
}

//----- (0000000140016E6C) ----------------------------------------------------
void __fastcall sub_140016E6C(__int64 a1, void *a2)
{
  j__free_base(a2);
}

//----- (0000000140016E80) ----------------------------------------------------
__int64 __fastcall sub_140016E80(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140016ECC) ----------------------------------------------------
void (__cdecl *sub_140016ECC())(void *Block)
{
  return j_j__free_base;
}

//----- (0000000140016ED4) ----------------------------------------------------
void *(__cdecl *sub_140016ED4())(size_t Size)
{
  return j_j__malloc_base;
}

//----- (0000000140016EEC) ----------------------------------------------------
void __fastcall sub_140016EEC(__int64 a1, void *a2)
{
  j__free_base(a2);
}

//----- (0000000140016EF4) ----------------------------------------------------
void *__fastcall sub_140016EF4(__int64 a1, size_t a2)
{
  return j__malloc_base(a2);
}

//----- (0000000140016EFC) ----------------------------------------------------
__int64 __fastcall sub_140016EFC(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140016F08) ----------------------------------------------------
__int64 __fastcall sub_140016F08(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140016F0C) ----------------------------------------------------
__int64 __fastcall sub_140016F0C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001400172A8) ----------------------------------------------------
__int64 __fastcall sub_1400172A8(__int64 a1)
{
  return a1 + 16;
}

//----- (00000001400172E0) ----------------------------------------------------
void __fastcall sub_1400172E0(__int64 a1)
{
  qword_14009B878 = a1;
}
// 14009B878: using guessed type __int64 qword_14009B878;

//----- (00000001400173F0) ----------------------------------------------------
void __noreturn sub_1400173F0()
{
  terminate();
}
// 1400572F8: using guessed type void __noreturn terminate(void);

//----- (00000001400174A4) ----------------------------------------------------
void __fastcall sub_1400174A4(__int64 a1, void *a2)
{
  j__free_base(a2);
}

//----- (00000001400174EC) ----------------------------------------------------
void __fastcall sub_1400174EC(DWORD *a1)
{
  SetLastError(*a1);
}

//----- (0000000140017508) ----------------------------------------------------
__int64 __fastcall sub_140017508(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001400177CC) ----------------------------------------------------
void __fastcall sub_1400177CC(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)&unk_14009B910 + a1);
}

//----- (0000000140017820) ----------------------------------------------------
void __fastcall sub_140017820(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)&unk_14009B910 + a1);
}

//----- (000000014001783C) ----------------------------------------------------
uintptr_t sub_14001783C()
{
  return _security_cookie;
}

//----- (0000000140017894) ----------------------------------------------------
__int64 __fastcall sub_140017894(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140017898) ----------------------------------------------------
__int64 __fastcall sub_140017898(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140017908) ----------------------------------------------------
__int64 sub_140017908()
{
  return try_get_function(3i64, "FlsSetValue", &unk_14007D5B0, "FlsSetValue");
}
// 140017A64: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140017928) ----------------------------------------------------
__int64 sub_140017928()
{
  return try_get_function(4i64, "InitializeCriticalSectionEx", &qword_14007D5C8, "InitializeCriticalSectionEx");
}
// 140017A64: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);
// 14007D5C8: using guessed type __int64 qword_14007D5C8;

//----- (00000001400180E8) ----------------------------------------------------
uintptr_t sub_1400180E8()
{
  return _security_cookie;
}

//----- (0000000140018468) ----------------------------------------------------
_QWORD *__fastcall sub_140018468(_QWORD *a1)
{
  *a1 = &DNameNode::`vftable';
  return a1;
}
// 14007E438: using guessed type void *DNameNode::`vftable';

//----- (00000001400185C4) ----------------------------------------------------
void *__fastcall sub_1400185C4(unsigned __int64 a1, __int64 a2, int a3)
{
  return _HeapManager::getMemory((_HeapManager *)&qword_14009B9C8, a1, a3);
}
// 14009B9C8: using guessed type __int64 qword_14009B9C8;

//----- (0000000140018730) ----------------------------------------------------
__int64 __fastcall sub_140018730(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rax
  char v7[24]; // [rsp+20h] [rbp-18h] BYREF

  v5 = unknown_libname_18(v7);
  DName::operator+(v5, a1, a3);
  return a1;
}
// 140018204: using guessed type __int64 __fastcall unknown_libname_18(_QWORD);
// 1400187EC: using guessed type __int64 __fastcall DName::operator+(_QWORD, _QWORD, _QWORD);
// 140018730: using guessed type char var_18[24];

//----- (000000014001C040) ----------------------------------------------------
char __fastcall sub_14001C040(__int64 a1)
{
  return *(_BYTE *)(a1 + 8);
}

//----- (000000014001EE14) ----------------------------------------------------
__int64 __fastcall sub_14001EE14(__int64 a1)
{
  return *(unsigned int *)(a1 + 12);
}

//----- (000000014001EE9C) ----------------------------------------------------
__int64 __fastcall sub_14001EE9C(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (000000014001F398) ----------------------------------------------------
__int64 __fastcall sub_14001F398(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014001F620) ----------------------------------------------------
__int64 __fastcall sub_14001F620(__int64 a1)
{
  return a1;
}

//----- (000000014001F624) ----------------------------------------------------
__int64 __fastcall sub_14001F624(__int64 a1)
{
  return a1;
}

//----- (000000014001F97C) ----------------------------------------------------
_QWORD *__fastcall sub_14001F97C(_QWORD *a1, ULONG64 *a2, __int64 a3, _QWORD *a4)
{
  __int64 v4; // rdi
  int v9; // ebp
  _DWORD *v10; // rbx
  PRUNTIME_FUNCTION v11; // rax
  __int64 v12; // rcx
  unsigned __int64 v13; // r8
  unsigned int v14; // r9d
  _DWORD *v15; // rdx
  unsigned __int64 ImageBase; // [rsp+50h] [rbp+8h] BYREF

  LODWORD(v4) = *(_DWORD *)(a3 + 12);
  v9 = sub_1400203D8(a3, a2);
  *a4 = *a1;
  while ( (_DWORD)v4 )
  {
    v4 = (unsigned int)(v4 - 1);
    v10 = (_DWORD *)(a2[1] + *(int *)(a3 + 16) + 20 * v4);
    if ( v9 > v10[1] && v9 <= v10[2] )
    {
      v11 = RtlLookupFunctionEntry(*a2, &ImageBase, 0i64);
      v12 = 0i64;
      v13 = ImageBase + (int)v10[4];
      v14 = v10[3];
      if ( v14 )
      {
        v15 = (_DWORD *)(v13 + 12);
        do
        {
          if ( *v15 == (unsigned __int64)v11->BeginAddress )
            break;
          v12 = (unsigned int)(v12 + 1);
          v15 += 5;
        }
        while ( (unsigned int)v12 < v14 );
      }
      if ( (unsigned int)v12 < v14 )
      {
        *a4 = *(_QWORD *)(*(int *)(v13 + 20 * v12 + 16) + *a1);
        return a4;
      }
    }
  }
  return a4;
}

//----- (000000014001FF98) ----------------------------------------------------
__int64 __fastcall sub_14001FF98(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014002033C) ----------------------------------------------------
__int64 __fastcall sub_14002033C(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // rax

  result = *(unsigned int *)(*(int *)(a3 + 28) + *a1);
  if ( (_DWORD)result == -2 )
    return unknown_libname_42(a3, a2, *a2);
  return result;
}
// 1400203E8: using guessed type __int64 __fastcall unknown_libname_42(_QWORD, _QWORD, _QWORD);

//----- (0000000140020364) ----------------------------------------------------
__int64 __fastcall sub_140020364(_QWORD *a1, ULONG64 *a2, __int64 a3)
{
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v7; // [rsp+40h] [rbp+18h] BYREF

  v4 = *sub_14001F97C(a1, a2, a3, &v7);
  v5 = *(int *)(a3 + 28);
  v7 = v4;
  return *(unsigned int *)(v5 + v4 + 4);
}

//----- (000000014002039C) ----------------------------------------------------
__int64 __fastcall sub_14002039C(_QWORD *a1, ULONG64 *a2, __int64 a3, int a4)
{
  __int64 v6; // rcx
  __int64 result; // rax
  __int64 v8; // [rsp+40h] [rbp+18h] BYREF

  v6 = *sub_14001F97C(a1, a2, a3, &v8);
  result = *(int *)(a3 + 28);
  v8 = v6;
  if ( a4 > *(_DWORD *)(result + v6 + 4) )
    *(_DWORD *)(result + v6 + 4) = a4;
  return result;
}

//----- (00000001400203D8) ----------------------------------------------------
__int64 __fastcall sub_1400203D8(__int64 a1, _QWORD *a2)
{
  return unknown_libname_42(a1, a2, *a2);
}
// 1400203E8: using guessed type __int64 __fastcall unknown_libname_42(_QWORD, _QWORD, _QWORD);

//----- (0000000140020540) ----------------------------------------------------
__int64 __fastcall sub_140020540(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (0000000140022274) ----------------------------------------------------
_QWORD *__fastcall sub_140022274(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  _std_exception_copy(a2 + 8);
  *a1 = &std::bad_exception::`vftable';
  return a1;
}
// 14002379C: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 14007E6A0: using guessed type void *std::exception::`vftable';
// 14007E6D0: using guessed type void *std::bad_exception::`vftable';

//----- (00000001400222B4) ----------------------------------------------------
_QWORD *__fastcall sub_1400222B4(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad exception";
  *a1 = &std::bad_exception::`vftable';
  return a1;
}
// 14007E6D0: using guessed type void *std::bad_exception::`vftable';

//----- (0000000140022440) ----------------------------------------------------
__int64 __fastcall sub_140022440(__int64 a1)
{
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

//----- (00000001400230E0) ----------------------------------------------------
__int64 __fastcall sub_1400230E0(__int64 a1, __int64 a2)
{
  return *(unsigned int *)(a2 + 4);
}

//----- (0000000140023414) ----------------------------------------------------
__int64 sub_140023414()
{
  return 0i64;
}

//----- (0000000140023484) ----------------------------------------------------
__int64 sub_140023484()
{
  return 429065506i64;
}

//----- (0000000140023494) ----------------------------------------------------
__int64 __fastcall sub_140023494(unsigned int *a1)
{
  return *a1;
}

//----- (0000000140023610) ----------------------------------------------------
void __fastcall sub_140023610(__FrameHandler4::HandlerMap *a1)
{
  *((_QWORD *)a1 + 1) = *((_QWORD *)a1 + 2);
  __FrameHandler4::HandlerMap::DecompHandler(a1);
}

//----- (00000001400236F0) ----------------------------------------------------
__int64 __fastcall sub_1400236F0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  void (__fastcall *v4)(__int64); // rax
  __int64 v5; // rax

  v4 = (void (__fastcall *)(__int64))NLG_Notify(a1, a2, a4);
  v4(a3);
  v5 = _NLG_Return2();
  return NLG_Notify(v5, a2, 2i64);
}
// 140017120: using guessed type __int64 __fastcall NLG_Notify(_QWORD, _QWORD, _QWORD);
// 140017150: using guessed type __int64 _NLG_Return2(void);

//----- (0000000140023738) ----------------------------------------------------
void __fastcall sub_140023738(__int64 a1, void *a2)
{
  j__free_base(a2);
}

//----- (0000000140023774) ----------------------------------------------------
__int64 __fastcall sub_140023774(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140023914) ----------------------------------------------------
__int64 __fastcall sub_140023914(unsigned int *a1)
{
  return *a1;
}

//----- (00000001400239C4) ----------------------------------------------------
__int64 __fastcall sub_1400239C4(unsigned int *a1)
{
  return *a1;
}

//----- (0000000140023D4C) ----------------------------------------------------
bool __fastcall sub_140023D4C(HMODULE a1)
{
  return FreeLibrary(a1);
}

//----- (0000000140023F18) ----------------------------------------------------
__int64 __fastcall sub_140023F18(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140023F1C) ----------------------------------------------------
__int64 __fastcall sub_140023F1C(__int64 a1)
{
  return a1;
}

//----- (0000000140024018) ----------------------------------------------------
void __fastcall sub_140024018(__int64 a1)
{
  qword_14009B9F8 = a1;
}
// 14009B9F8: using guessed type __int64 qword_14009B9F8;

//----- (000000014002404C) ----------------------------------------------------
__int64 sub_14002404C()
{
  return (unsigned int)dword_14009B9F0;
}
// 14009B9F0: using guessed type int dword_14009B9F0;

//----- (00000001400240B0) ----------------------------------------------------
void __fastcall sub_1400240B0(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (00000001400240E4) ----------------------------------------------------
__int64 __fastcall sub_1400240E4(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001400242E4) ----------------------------------------------------
void __fastcall sub_1400242E4(__int64 a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (00000001400242F0) ----------------------------------------------------
void __fastcall sub_1400242F0(__int64 a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (0000000140024B34) ----------------------------------------------------
__int64 __fastcall sub_140024B34(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140024AB4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140024B5C) ----------------------------------------------------
__int64 __fastcall sub_140024B5C(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 1400249B4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140024B84) ----------------------------------------------------
__int64 __fastcall sub_140024B84(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140024AF4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140024BAC) ----------------------------------------------------
__int64 __fastcall sub_140024BAC(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140024A34: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140024BD4) ----------------------------------------------------
__int64 __fastcall sub_140024BD4(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 1400249F4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140024BFC) ----------------------------------------------------
__int64 __fastcall sub_140024BFC(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140024A74: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140024C24) ----------------------------------------------------
__int64 __fastcall sub_140024C24(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v6[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v13 = a4;
  v12 = a3;
  v11 = a2;
  v10 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v11;
    v8 = a2;
    v9[1] = (__int64)&v13;
    v9[2] = (__int64)&v10;
    v9[3] = (__int64)&v12;
    v9[4] = (__int64)&a5;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             v6,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140024A34: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140024C24: using guessed type char var_40[8];

//----- (0000000140024CAC) ----------------------------------------------------
__int64 __fastcall sub_140024CAC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v6[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v13 = a4;
  v12 = a3;
  v11 = a2;
  v10 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v11;
    v8 = a2;
    v9[1] = (__int64)&v13;
    v9[2] = (__int64)&v10;
    v9[3] = (__int64)&v12;
    v9[4] = (__int64)&a5;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             v6,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 1400249F4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140024CAC: using guessed type char var_40[8];

//----- (0000000140024D34) ----------------------------------------------------
__int64 __fastcall sub_140024D34(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v6[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v13 = a4;
  v12 = a3;
  v11 = a2;
  v10 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v11;
    v8 = a2;
    v9[1] = (__int64)&v13;
    v9[2] = (__int64)&v10;
    v9[3] = (__int64)&v12;
    v9[4] = (__int64)&a5;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             v6,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 1400249B4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140024D34: using guessed type char var_40[8];

//----- (0000000140024DBC) ----------------------------------------------------
__int64 __fastcall sub_140024DBC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v6[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v13 = a4;
  v12 = a3;
  v11 = a2;
  v10 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v11;
    v8 = a2;
    v9[1] = (__int64)&v13;
    v9[2] = (__int64)&v10;
    v9[3] = (__int64)&v12;
    v9[4] = (__int64)&a5;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             v6,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140024AF4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140024DBC: using guessed type char var_40[8];

//----- (0000000140024E44) ----------------------------------------------------
__int64 __fastcall sub_140024E44(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v6[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v13 = a4;
  v12 = a3;
  v11 = a2;
  v10 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v11;
    v8 = a2;
    v9[1] = (__int64)&v13;
    v9[2] = (__int64)&v10;
    v9[3] = (__int64)&v12;
    v9[4] = (__int64)&a5;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             v6,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140024AB4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140024E44: using guessed type char var_40[8];

//----- (0000000140024ECC) ----------------------------------------------------
__int64 __fastcall sub_140024ECC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v6[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v13 = a4;
  v12 = a3;
  v11 = a2;
  v10 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v11;
    v8 = a2;
    v9[1] = (__int64)&v13;
    v9[2] = (__int64)&v10;
    v9[3] = (__int64)&v12;
    v9[4] = (__int64)&a5;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             v6,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140024A74: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140024ECC: using guessed type char var_40[8];

//----- (00000001400251F0) ----------------------------------------------------
__int64 __fastcall sub_1400251F0(
        int a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4,
        struct __crt_locale_pointers *a5,
        __int64 a6)
{
  int v6; // ebx
  int v11; // eax
  unsigned __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v15; // [rsp+40h] [rbp-C0h]
  char v16; // [rsp+48h] [rbp-B8h]
  __int64 *v17; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v18; // [rsp+58h] [rbp-A8h] BYREF
  char v19[32]; // [rsp+60h] [rbp-A0h] BYREF
  char v20[1120]; // [rsp+80h] [rbp-80h] BYREF
  void *Block; // [rsp+4E0h] [rbp+3E0h]

  v6 = a4;
  if ( !a4 || a3 && !a2 )
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v18, a5);
  sub_140016650((__int64)v14, 0, 0x20ui64);
  v15 = 0i64;
  v14[0] = (__int64)a2;
  v14[1] = a3;
  if ( (a1 & 2) != 0 || (v16 = 0, !a2) )
    v16 = 1;
  v17 = v14;
  unknown_libname_432((unsigned int)v20, (unsigned int)&v17, a1, v6, (__int64)v19, a6);
  v11 = __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::format_validation_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(v20);
  v12 = v11;
  if ( !a2 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( (a1 & 2) != 0 )
    {
      if ( !a3 )
        goto LABEL_22;
      if ( v11 < 0 )
      {
        *a2 = 0;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
      {
LABEL_21:
        a2[v13] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a3 )
      {
LABEL_26:
        LODWORD(v12) = -1;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
        goto LABEL_21;
      LODWORD(v12) = -2;
    }
    a2[a3 - 1] = 0;
    goto LABEL_22;
  }
  if ( !a3 && v11 )
    goto LABEL_26;
  v13 = v15;
  if ( v15 != a3 )
    goto LABEL_21;
  if ( (v12 & 0x80000000) == 0i64 && v12 > a3 )
    goto LABEL_26;
LABEL_22:
  free_base(Block);
  Block = 0i64;
  if ( v19[16] )
    *(_DWORD *)(v18 + 936) &= ~2u;
  return (unsigned int)v12;
}
// 14002A594: using guessed type __int64 __fastcall unknown_libname_432(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 14002D178: using guessed type __int64 __fastcall __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::format_validation_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(_QWORD);

//----- (0000000140025398) ----------------------------------------------------
__int64 __fastcall sub_140025398(
        int a1,
        _WORD *a2,
        unsigned __int64 a3,
        __int64 a4,
        struct __crt_locale_pointers *a5,
        __int64 a6)
{
  int v6; // ebx
  int v11; // eax
  unsigned __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v15; // [rsp+40h] [rbp-C0h]
  char v16; // [rsp+48h] [rbp-B8h]
  __int64 *v17; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v18; // [rsp+58h] [rbp-A8h] BYREF
  char v19[32]; // [rsp+60h] [rbp-A0h] BYREF
  char v20[1120]; // [rsp+80h] [rbp-80h] BYREF
  void *Block; // [rsp+4E0h] [rbp+3E0h]

  v6 = a4;
  if ( !a4 || a3 && !a2 )
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v18, a5);
  sub_140016650((__int64)v14, 0, 0x20ui64);
  v14[0] = (__int64)a2;
  v14[1] = a3;
  v15 = 0i64;
  if ( (a1 & 2) != 0 || (v16 = 0, !a2) )
    v16 = 1;
  v17 = v14;
  unknown_libname_438((unsigned int)v20, (unsigned int)&v17, a1, v6, (__int64)v19, a6);
  v11 = __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::format_validation_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(v20);
  v12 = v11;
  if ( !a2 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( (a1 & 2) != 0 )
    {
      if ( !a3 )
        goto LABEL_22;
      if ( v11 < 0 )
      {
        *a2 = 0;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
      {
LABEL_21:
        a2[v13] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a3 )
      {
LABEL_26:
        LODWORD(v12) = -1;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
        goto LABEL_21;
      LODWORD(v12) = -2;
    }
    a2[a3 - 1] = 0;
    goto LABEL_22;
  }
  if ( !a3 && v11 )
    goto LABEL_26;
  v13 = v15;
  if ( v15 != a3 )
    goto LABEL_21;
  if ( (v12 & 0x80000000) == 0i64 && v12 > a3 )
    goto LABEL_26;
LABEL_22:
  free_base(Block);
  Block = 0i64;
  if ( v19[16] )
    *(_DWORD *)(v18 + 936) &= ~2u;
  return (unsigned int)v12;
}
// 14002A8C4: using guessed type __int64 __fastcall unknown_libname_438(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 14002DFD0: using guessed type __int64 __fastcall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::format_validation_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(_QWORD);

//----- (00000001400258A8) ----------------------------------------------------
__int64 __fastcall sub_1400258A8(
        int a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4,
        struct __crt_locale_pointers *a5,
        __int64 a6)
{
  int v6; // ebx
  int v11; // eax
  unsigned __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v15; // [rsp+40h] [rbp-C0h]
  char v16; // [rsp+48h] [rbp-B8h]
  __int64 *v17; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v18; // [rsp+58h] [rbp-A8h] BYREF
  char v19[32]; // [rsp+60h] [rbp-A0h] BYREF
  char v20[1120]; // [rsp+80h] [rbp-80h] BYREF
  void *Block; // [rsp+4E0h] [rbp+3E0h]

  v6 = a4;
  if ( !a4 || a3 && !a2 )
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v18, a5);
  sub_140016650((__int64)v14, 0, 0x20ui64);
  v15 = 0i64;
  v14[0] = (__int64)a2;
  v14[1] = a3;
  if ( (a1 & 2) != 0 || (v16 = 0, !a2) )
    v16 = 1;
  v17 = v14;
  unknown_libname_434((unsigned int)v20, (unsigned int)&v17, a1, v6, (__int64)v19, a6);
  v11 = __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::standard_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(v20);
  v12 = v11;
  if ( !a2 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( (a1 & 2) != 0 )
    {
      if ( !a3 )
        goto LABEL_22;
      if ( v11 < 0 )
      {
        *a2 = 0;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
      {
LABEL_21:
        a2[v13] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a3 )
      {
LABEL_26:
        LODWORD(v12) = -1;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
        goto LABEL_21;
      LODWORD(v12) = -2;
    }
    a2[a3 - 1] = 0;
    goto LABEL_22;
  }
  if ( !a3 && v11 )
    goto LABEL_26;
  v13 = v15;
  if ( v15 != a3 )
    goto LABEL_21;
  if ( (v12 & 0x80000000) == 0i64 && v12 > a3 )
    goto LABEL_26;
LABEL_22:
  free_base(Block);
  Block = 0i64;
  if ( v19[16] )
    *(_DWORD *)(v18 + 936) &= ~2u;
  return (unsigned int)v12;
}
// 14002A6AC: using guessed type __int64 __fastcall unknown_libname_434(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 14002D61C: using guessed type __int64 __fastcall __crt_stdio_output::output_processor<char,__crt_stdio_output::string_output_adapter<char>,__crt_stdio_output::standard_base<char,__crt_stdio_output::string_output_adapter<char>>>::process(_QWORD);

//----- (0000000140025A50) ----------------------------------------------------
__int64 __fastcall sub_140025A50(
        int a1,
        _WORD *a2,
        unsigned __int64 a3,
        __int64 a4,
        struct __crt_locale_pointers *a5,
        __int64 a6)
{
  int v6; // ebx
  int v11; // eax
  unsigned __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v15; // [rsp+40h] [rbp-C0h]
  char v16; // [rsp+48h] [rbp-B8h]
  __int64 *v17; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v18; // [rsp+58h] [rbp-A8h] BYREF
  char v19[32]; // [rsp+60h] [rbp-A0h] BYREF
  char v20[1120]; // [rsp+80h] [rbp-80h] BYREF
  void *Block; // [rsp+4E0h] [rbp+3E0h]

  v6 = a4;
  if ( !a4 || a3 && !a2 )
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v18, a5);
  sub_140016650((__int64)v14, 0, 0x20ui64);
  v14[0] = (__int64)a2;
  v14[1] = a3;
  v15 = 0i64;
  if ( (a1 & 2) != 0 || (v16 = 0, !a2) )
    v16 = 1;
  v17 = v14;
  unknown_libname_440((unsigned int)v20, (unsigned int)&v17, a1, v6, (__int64)v19, a6);
  v11 = __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::standard_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(v20);
  v12 = v11;
  if ( !a2 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( (a1 & 2) != 0 )
    {
      if ( !a3 )
        goto LABEL_22;
      if ( v11 < 0 )
      {
        *a2 = 0;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
      {
LABEL_21:
        a2[v13] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a3 )
      {
LABEL_26:
        LODWORD(v12) = -1;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
        goto LABEL_21;
      LODWORD(v12) = -2;
    }
    a2[a3 - 1] = 0;
    goto LABEL_22;
  }
  if ( !a3 && v11 )
    goto LABEL_26;
  v13 = v15;
  if ( v15 != a3 )
    goto LABEL_21;
  if ( (v12 & 0x80000000) == 0i64 && v12 > a3 )
    goto LABEL_26;
LABEL_22:
  free_base(Block);
  Block = 0i64;
  if ( v19[16] )
    *(_DWORD *)(v18 + 936) &= ~2u;
  return (unsigned int)v12;
}
// 14002A9E0: using guessed type __int64 __fastcall unknown_libname_440(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 14002E50C: using guessed type __int64 __fastcall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::standard_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::process(_QWORD);

//----- (0000000140025DC0) ----------------------------------------------------
char __fastcall sub_140025DC0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(char **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(char *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140025E84) ----------------------------------------------------
char __fastcall sub_140025E84(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(char **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(char *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140025F48) ----------------------------------------------------
char __fastcall sub_140025F48(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(char **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(char *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026010) ----------------------------------------------------
char __fastcall sub_140026010(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(char **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(char *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026128) ----------------------------------------------------
char __fastcall sub_140026128(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned __int8 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400261EC) ----------------------------------------------------
char __fastcall sub_1400261EC(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned __int8 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400262B0) ----------------------------------------------------
char __fastcall sub_1400262B0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned __int8 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026374) ----------------------------------------------------
char __fastcall sub_140026374(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned __int8 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026488) ----------------------------------------------------
char __fastcall sub_140026488(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(__int16 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(__int16 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002654C) ----------------------------------------------------
char __fastcall sub_14002654C(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(__int16 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(__int16 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026610) ----------------------------------------------------
char __fastcall sub_140026610(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(__int16 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(__int16 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400266D8) ----------------------------------------------------
char __fastcall sub_1400266D8(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(__int16 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(__int16 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400267F0) ----------------------------------------------------
char __fastcall sub_1400267F0(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(_BYTE **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(_BYTE *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400268B0) ----------------------------------------------------
char __fastcall sub_1400268B0(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(_BYTE **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(_BYTE *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026998) ----------------------------------------------------
char __fastcall sub_140026998(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned __int16 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026A5C) ----------------------------------------------------
char __fastcall sub_140026A5C(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned __int16 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026B20) ----------------------------------------------------
char __fastcall sub_140026B20(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned __int16 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026BE4) ----------------------------------------------------
char __fastcall sub_140026BE4(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned __int16 **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026CF8) ----------------------------------------------------
char __fastcall sub_140026CF8(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(int **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(int *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026DBC) ----------------------------------------------------
char __fastcall sub_140026DBC(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(int **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(int *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026E80) ----------------------------------------------------
char __fastcall sub_140026E80(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(int **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(int *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140026F44) ----------------------------------------------------
char __fastcall sub_140026F44(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(int **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(int *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140027058) ----------------------------------------------------
char __fastcall sub_140027058(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned int **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned int *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140027118) ----------------------------------------------------
char __fastcall sub_140027118(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned int **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned int *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400271D8) ----------------------------------------------------
char __fastcall sub_1400271D8(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned int **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned int *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014002729C) ----------------------------------------------------
char __fastcall sub_14002729C(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(unsigned int **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(unsigned int *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140027E70) ----------------------------------------------------
char __fastcall sub_140027E70(__int64 a1, _QWORD *a2)
{
  __int64 v2; // xmm0_8
  __int64 v3; // rax
  char result; // al
  int v5; // r8d
  char v6; // r9
  char v7; // bl
  __int64 v8; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v3 = *(int *)(a1 + 3564);
    if ( (unsigned int)v3 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      v2 = **(_QWORD **)(a1 + 24 * v3 + 1168);
      goto LABEL_13;
    }
    v5 = *(_DWORD *)(a1 + 60);
    v6 = *(_BYTE *)(a1 + 65);
    v7 = 0;
    v8 = a1 + 8 * (v3 + 2 * v3 + 145);
    if ( *(_DWORD *)v8 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v8, 4, v6, v5) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v7;
      }
    }
    else
    {
      *(_DWORD *)v8 = 4;
      *(_BYTE *)(v8 + 4) = v6;
      *(_DWORD *)(v8 + 16) = v5;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
LABEL_13:
  result = 1;
  *a2 = v2;
  return result;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140027F38) ----------------------------------------------------
char __fastcall sub_140027F38(__int64 a1, _QWORD *a2)
{
  __int64 v2; // xmm0_8
  __int64 v3; // rax
  char result; // al
  int v5; // r8d
  char v6; // r9
  char v7; // bl
  __int64 v8; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v3 = *(int *)(a1 + 3564);
    if ( (unsigned int)v3 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      v2 = **(_QWORD **)(a1 + 24 * v3 + 1168);
      goto LABEL_13;
    }
    v5 = *(_DWORD *)(a1 + 60);
    v6 = *(_BYTE *)(a1 + 65);
    v7 = 0;
    v8 = a1 + 8 * (v3 + 2 * v3 + 145);
    if ( *(_DWORD *)v8 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v8, 4, v6, v5) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v7;
      }
    }
    else
    {
      *(_DWORD *)v8 = 4;
      *(_BYTE *)(v8 + 4) = v6;
      *(_DWORD *)(v8 + 16) = v5;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
LABEL_13:
  result = 1;
  *a2 = v2;
  return result;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140028000) ----------------------------------------------------
char __fastcall sub_140028000(__int64 a1, _QWORD *a2)
{
  __int64 v2; // xmm0_8
  __int64 v3; // rax
  char result; // al
  int v5; // r8d
  int v6; // r9d
  char v7; // bl
  __int64 v8; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v3 = *(int *)(a1 + 3564);
    if ( (unsigned int)v3 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      v2 = **(_QWORD **)(a1 + 24 * v3 + 1168);
      goto LABEL_13;
    }
    v5 = *(_DWORD *)(a1 + 60);
    v6 = *(unsigned __int16 *)(a1 + 66);
    v7 = 0;
    v8 = a1 + 8 * (v3 + 2 * v3 + 145);
    if ( *(_DWORD *)v8 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v8, 4, v6, v5) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v7;
      }
    }
    else
    {
      *(_DWORD *)v8 = 4;
      *(_WORD *)(v8 + 4) = v6;
      *(_DWORD *)(v8 + 16) = v5;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
LABEL_13:
  result = 1;
  *a2 = v2;
  return result;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400280C8) ----------------------------------------------------
char __fastcall sub_1400280C8(__int64 a1, _QWORD *a2)
{
  __int64 v2; // xmm0_8
  __int64 v3; // rax
  char result; // al
  int v5; // r8d
  int v6; // r9d
  char v7; // bl
  __int64 v8; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v3 = *(int *)(a1 + 3564);
    if ( (unsigned int)v3 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      v2 = **(_QWORD **)(a1 + 24 * v3 + 1168);
      goto LABEL_13;
    }
    v5 = *(_DWORD *)(a1 + 60);
    v6 = *(unsigned __int16 *)(a1 + 66);
    v7 = 0;
    v8 = a1 + 8 * (v3 + 2 * v3 + 145);
    if ( *(_DWORD *)v8 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v8, 4, v6, v5) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v7;
      }
    }
    else
    {
      *(_DWORD *)v8 = 4;
      *(_WORD *)(v8 + 4) = v6;
      *(_DWORD *)(v8 + 16) = v5;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
LABEL_13:
  result = 1;
  *a2 = v2;
  return result;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400288B0) ----------------------------------------------------
char __fastcall sub_1400288B0(__int64 a1, _WORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(_WORD **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(_WORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140028974) ----------------------------------------------------
char __fastcall sub_140028974(__int64 a1, _WORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  char v5; // r9
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(_WORD **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(_BYTE *)(a1 + 65);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_BYTE *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(_WORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140028A38) ----------------------------------------------------
char __fastcall sub_140028A38(__int64 a1, _WORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(_WORD **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(_WORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140028B00) ----------------------------------------------------
char __fastcall sub_140028B00(__int64 a1, _WORD *a2)
{
  __int64 v2; // rax
  int v4; // r8d
  int v5; // r9d
  char v6; // bl
  __int64 v7; // rdx

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(int *)(a1 + 3564);
    if ( (unsigned int)v2 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    if ( *(_DWORD *)(a1 + 1144) != 1 )
    {
      *a2 = **(_WORD **)(a1 + 24 * v2 + 1168);
      return 1;
    }
    v4 = *(_DWORD *)(a1 + 60);
    v5 = *(unsigned __int16 *)(a1 + 66);
    v6 = 0;
    v7 = a1 + 8 * (v2 + 2 * v2 + 145);
    if ( *(_DWORD *)v7 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v7, 1, v5, v4) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v6;
      }
    }
    else
    {
      *(_DWORD *)v7 = 1;
      *(_WORD *)(v7 + 4) = v5;
      *(_DWORD *)(v7 + 16) = v4;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *a2 = *(_WORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140028C18) ----------------------------------------------------
__int64 sub_140028C18()
{
  return 3i64;
}

//----- (0000000140028C20) ----------------------------------------------------
__int64 sub_140028C20()
{
  return 3i64;
}

//----- (0000000140028C28) ----------------------------------------------------
__int64 sub_140028C28()
{
  return 3i64;
}

//----- (0000000140028C30) ----------------------------------------------------
__int64 sub_140028C30()
{
  return 3i64;
}

//----- (0000000140028C38) ----------------------------------------------------
__int64 sub_140028C38()
{
  return 3i64;
}

//----- (0000000140028C40) ----------------------------------------------------
__int64 sub_140028C40()
{
  return 3i64;
}

//----- (0000000140028C48) ----------------------------------------------------
__int64 sub_140028C48()
{
  return 3i64;
}

//----- (0000000140028C50) ----------------------------------------------------
__int64 sub_140028C50()
{
  return 3i64;
}

//----- (0000000140028C58) ----------------------------------------------------
__int64 sub_140028C58()
{
  return 3i64;
}

//----- (0000000140028C60) ----------------------------------------------------
__int64 sub_140028C60()
{
  return 3i64;
}

//----- (0000000140028C68) ----------------------------------------------------
__int64 sub_140028C68()
{
  return 3i64;
}

//----- (0000000140028C70) ----------------------------------------------------
__int64 sub_140028C70()
{
  return 3i64;
}

//----- (0000000140028E1C) ----------------------------------------------------
char __fastcall sub_140028E1C(__int64 a1)
{
  return *(_BYTE *)a1;
}

//----- (0000000140028E20) ----------------------------------------------------
char __fastcall sub_140028E20(__int64 a1)
{
  return *(_BYTE *)a1;
}

//----- (0000000140028E2C) ----------------------------------------------------
__int64 __fastcall sub_140028E2C(unsigned int *a1)
{
  return *a1;
}

//----- (0000000140028E30) ----------------------------------------------------
__int64 __fastcall sub_140028E30(unsigned int *a1)
{
  return *a1;
}

//----- (0000000140028E34) ----------------------------------------------------
__int64 __fastcall sub_140028E34(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028E38) ----------------------------------------------------
__int64 __fastcall sub_140028E38(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028E3C) ----------------------------------------------------
__int64 __fastcall sub_140028E3C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028E40) ----------------------------------------------------
__int64 __fastcall sub_140028E40(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028E44) ----------------------------------------------------
__int64 __fastcall sub_140028E44(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028E48) ----------------------------------------------------
__int64 __fastcall sub_140028E48(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028E4C) ----------------------------------------------------
__int64 __fastcall sub_140028E4C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028E50) ----------------------------------------------------
__int64 __fastcall sub_140028E50(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028E54) ----------------------------------------------------
__int64 __fastcall sub_140028E54(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140028FD4) ----------------------------------------------------
int __fastcall sub_140028FD4(const char **a1, char ***a2, int *a3)
{
  return strtol(*a1, *a2, *a3);
}

//----- (0000000140028FE4) ----------------------------------------------------
int __fastcall sub_140028FE4(const wchar_t **a1, wchar_t ***a2, int *a3)
{
  return wcstol(*a1, *a2, *a3);
}

//----- (0000000140028FF4) ----------------------------------------------------
int __fastcall sub_140028FF4(const char **a1, char ***a2, int *a3)
{
  return strtol(*a1, *a2, *a3);
}

//----- (0000000140029004) ----------------------------------------------------
int __fastcall sub_140029004(const wchar_t **a1, wchar_t ***a2, int *a3)
{
  return wcstol(*a1, *a2, *a3);
}

//----- (000000014002AEFC) ----------------------------------------------------
__int64 __fastcall sub_14002AEFC(__int64 *a1)
{
  __int64 v1; // rdx

  v1 = *a1;
  LOBYTE(a1) = *((_BYTE *)a1 + 8);
  return _acrt_stdio_end_temporary_buffering_nolock(a1, v1);
}
// 14005D0C4: using guessed type __int64 __fastcall _acrt_stdio_end_temporary_buffering_nolock(_QWORD, _QWORD);

//----- (000000014002B064) ----------------------------------------------------
void __fastcall sub_14002B064(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (000000014002B06C) ----------------------------------------------------
void __fastcall sub_14002B06C(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014002B074) ----------------------------------------------------
void __fastcall sub_14002B074(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014002B07C) ----------------------------------------------------
void __fastcall sub_14002B07C(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (000000014002B084) ----------------------------------------------------
void __fastcall sub_14002B084(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014002B17C) ----------------------------------------------------
void __fastcall sub_14002B17C(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (000000014002B274) ----------------------------------------------------
void __fastcall sub_14002B274(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014002B36C) ----------------------------------------------------
void __fastcall sub_14002B36C(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014002B464) ----------------------------------------------------
void __fastcall sub_14002B464(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014002B46C) ----------------------------------------------------
void __fastcall sub_14002B46C(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (000000014002B474) ----------------------------------------------------
void __fastcall sub_14002B474(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (000000014002B56C) ----------------------------------------------------
void __fastcall sub_14002B56C(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (000000014002BAF0) ----------------------------------------------------
__int64 sub_14002BAF0()
{
  return 4i64;
}

//----- (000000014002BB30) ----------------------------------------------------
__int64 sub_14002BB30()
{
  return 4i64;
}

//----- (000000014002BB70) ----------------------------------------------------
__int64 sub_14002BB70()
{
  return 4i64;
}

//----- (000000014002BBB0) ----------------------------------------------------
__int64 sub_14002BBB0()
{
  return 4i64;
}

//----- (000000014002C430) ----------------------------------------------------
const char *sub_14002C430()
{
  return "(null)";
}

//----- (000000014002C438) ----------------------------------------------------
const char *sub_14002C438()
{
  return "(null)";
}

//----- (000000014002C440) ----------------------------------------------------
const char *sub_14002C440()
{
  return "(null)";
}

//----- (000000014002C448) ----------------------------------------------------
const char *sub_14002C448()
{
  return "(null)";
}

//----- (000000014002C450) ----------------------------------------------------
const char *sub_14002C450()
{
  return "(null)";
}

//----- (000000014002C458) ----------------------------------------------------
const char *sub_14002C458()
{
  return "(null)";
}

//----- (000000014002C460) ----------------------------------------------------
const char *sub_14002C460()
{
  return "(null)";
}

//----- (000000014002C468) ----------------------------------------------------
const char *sub_14002C468()
{
  return "(null)";
}

//----- (000000014002C470) ----------------------------------------------------
const char *sub_14002C470()
{
  return "(null)";
}

//----- (000000014002C478) ----------------------------------------------------
const char *sub_14002C478()
{
  return "(null)";
}

//----- (000000014002C480) ----------------------------------------------------
const char *sub_14002C480()
{
  return "(null)";
}

//----- (000000014002C488) ----------------------------------------------------
const char *sub_14002C488()
{
  return "(null)";
}

//----- (000000014002DAA4) ----------------------------------------------------
__int64 __fastcall sub_14002DAA4(__int64 a1)
{
  int v3; // eax
  _WORD *v4; // rax
  int *v5; // r14
  int *v6; // rsi
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char v15; // al
  __int64 v16; // rcx
  __int64 v17; // rdx
  int v18; // eax
  int v19; // eax
  __int16 v20; // cx

  if ( *(_QWORD *)(a1 + 1128) && *(_QWORD *)(a1 + 24) )
  {
    while ( 1 )
    {
      v3 = ++*(_DWORD *)(a1 + 1144);
      if ( v3 == 3 || v3 == 2 && *(_DWORD *)(a1 + 1148) == 1 )
        return *(unsigned int *)(a1 + 40);
      v4 = *(_WORD **)(a1 + 1152);
      v5 = (int *)(a1 + 52);
      v6 = (int *)(a1 + 56);
      *(_DWORD *)(a1 + 1148) = 0;
      *(_DWORD *)(a1 + 3560) = -1;
      *(_DWORD *)(a1 + 3564) = -1;
      *(_DWORD *)(a1 + 52) = 0;
      *(_DWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 24) = v4;
      *(_DWORD *)(a1 + 80) = 0;
      *(_DWORD *)(a1 + 44) = 0;
      LOWORD(v4) = *v4;
      *(_WORD *)(a1 + 66) = (_WORD)v4;
      if ( (_WORD)v4 )
      {
        do
        {
          *(_QWORD *)(a1 + 24) += 2i64;
          if ( *(int *)(a1 + 40) < 0 )
            goto LABEL_56;
          if ( (unsigned __int16)(*(_WORD *)(a1 + 66) - 32) > 0x5Au )
            v7 = 0;
          else
            v7 = byte_14007E800[*(unsigned __int16 *)(a1 + 66) - 32] & 0xF;
          *(_DWORD *)(a1 + 44) = byte_14007E800[*(_DWORD *)(a1 + 44) + 8 * v7 + v7] >> 4;
          if ( !(unsigned __int8)unknown_libname_638(a1) )
            return 0xFFFFFFFFi64;
          v8 = *(_DWORD *)(a1 + 44);
          if ( v8 == 8 )
          {
            *errno() = 22;
            invalid_parameter_noinfo();
            return 0xFFFFFFFFi64;
          }
          if ( !v8 )
          {
            v15 = __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::stream_output_adapter<wchar_t>,__crt_stdio_output::positional_parameter_base<wchar_t,__crt_stdio_output::stream_output_adapter<wchar_t>>>::state_case_normal(a1);
            goto LABEL_53;
          }
          v9 = v8 - 1;
          if ( v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              v11 = v10 - 1;
              if ( v11 )
              {
                v12 = v11 - 1;
                if ( v12 )
                {
                  v13 = v12 - 1;
                  if ( v13 )
                  {
                    v14 = v13 - 1;
                    if ( v14 )
                    {
                      if ( v14 != 1 )
                        return 0xFFFFFFFFi64;
                      v15 = sub_140032214(a1);
                    }
                    else
                    {
                      v15 = sub_140030804(a1);
                    }
                    goto LABEL_53;
                  }
                  v16 = a1;
                  if ( *(_WORD *)(a1 + 66) != 42 )
                  {
                    v17 = a1 + 56;
LABEL_26:
                    v15 = unknown_libname_514(v16, v17);
                    goto LABEL_53;
                  }
                  if ( !sub_140039554(a1) )
                    return 0xFFFFFFFFi64;
                  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
                  {
                    if ( *v6 < 0 )
                      *v6 = -1;
                    goto LABEL_40;
                  }
                }
                else
                {
                  *v6 = 0;
                }
              }
              else
              {
                v16 = a1;
                if ( *(_WORD *)(a1 + 66) != 42 )
                {
                  v17 = a1 + 52;
                  goto LABEL_26;
                }
                if ( !sub_1400390AC(a1) )
                  return 0xFFFFFFFFi64;
                if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
                {
                  v18 = *v5;
                  if ( *v5 < 0 )
                  {
                    *(_DWORD *)(a1 + 48) |= 4u;
                    *v5 = -v18;
                  }
LABEL_40:
                  v15 = 1;
LABEL_53:
                  if ( !v15 )
                    return 0xFFFFFFFFi64;
                }
              }
            }
            else
            {
              v19 = *(unsigned __int16 *)(a1 + 66);
              switch ( v19 )
              {
                case ' ':
                  *(_DWORD *)(a1 + 48) |= 2u;
                  break;
                case '#':
                  *(_DWORD *)(a1 + 48) |= 0x20u;
                  break;
                case '+':
                  *(_DWORD *)(a1 + 48) |= 1u;
                  break;
                case '-':
                  *(_DWORD *)(a1 + 48) |= 4u;
                  break;
                case '0':
                  *(_DWORD *)(a1 + 48) |= 8u;
                  break;
              }
            }
          }
          else
          {
            *v5 = 0;
            *(_BYTE *)(a1 + 64) = 0;
            *(_DWORD *)(a1 + 48) = 0;
            *v6 = -1;
            *(_DWORD *)(a1 + 60) = 0;
            *(_BYTE *)(a1 + 84) = 0;
          }
          v20 = **(_WORD **)(a1 + 24);
          *(_WORD *)(a1 + 66) = v20;
        }
        while ( v20 );
      }
      *(_QWORD *)(a1 + 24) += 2i64;
LABEL_56:
      if ( !(unsigned __int8)unknown_libname_646(a1) )
        return 0xFFFFFFFFi64;
    }
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 14002C828: using guessed type __int64 __fastcall unknown_libname_514(_QWORD, _QWORD);
// 14002EFC8: using guessed type __int64 __fastcall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::stream_output_adapter<wchar_t>,__crt_stdio_output::positional_parameter_base<wchar_t,__crt_stdio_output::stream_output_adapter<wchar_t>>>::state_case_normal(_QWORD);
// 140039B8C: using guessed type __int64 __fastcall unknown_libname_638(_QWORD);
// 140039F84: using guessed type __int64 __fastcall unknown_libname_646(_QWORD);
// 14007E800: using guessed type unsigned __int8 byte_14007E800[92];

//----- (000000014002E258) ----------------------------------------------------
__int64 __fastcall sub_14002E258(__int64 a1)
{
  int v3; // eax
  _WORD *v4; // rax
  int *v5; // r14
  int *v6; // rsi
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char v15; // al
  __int64 v16; // rcx
  __int64 v17; // rdx
  int v18; // eax
  int v19; // eax
  __int16 v20; // cx

  if ( *(_QWORD *)(a1 + 1128) && *(_QWORD *)(a1 + 24) )
  {
    while ( 1 )
    {
      v3 = ++*(_DWORD *)(a1 + 1144);
      if ( v3 == 3 || v3 == 2 && *(_DWORD *)(a1 + 1148) == 1 )
        return *(unsigned int *)(a1 + 40);
      v4 = *(_WORD **)(a1 + 1152);
      v5 = (int *)(a1 + 52);
      v6 = (int *)(a1 + 56);
      *(_DWORD *)(a1 + 1148) = 0;
      *(_DWORD *)(a1 + 3560) = -1;
      *(_DWORD *)(a1 + 3564) = -1;
      *(_DWORD *)(a1 + 52) = 0;
      *(_DWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 24) = v4;
      *(_DWORD *)(a1 + 80) = 0;
      *(_DWORD *)(a1 + 44) = 0;
      LOWORD(v4) = *v4;
      *(_WORD *)(a1 + 66) = (_WORD)v4;
      if ( (_WORD)v4 )
      {
        do
        {
          *(_QWORD *)(a1 + 24) += 2i64;
          if ( *(int *)(a1 + 40) < 0 )
            goto LABEL_56;
          if ( (unsigned __int16)(*(_WORD *)(a1 + 66) - 32) > 0x5Au )
            v7 = 0;
          else
            v7 = byte_14007E800[*(unsigned __int16 *)(a1 + 66) - 32] & 0xF;
          *(_DWORD *)(a1 + 44) = byte_14007E800[*(_DWORD *)(a1 + 44) + 8 * v7 + v7] >> 4;
          if ( !(unsigned __int8)unknown_libname_639(a1) )
            return 0xFFFFFFFFi64;
          v8 = *(_DWORD *)(a1 + 44);
          if ( v8 == 8 )
          {
            *errno() = 22;
            invalid_parameter_noinfo();
            return 0xFFFFFFFFi64;
          }
          if ( !v8 )
          {
            v15 = __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::positional_parameter_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_normal(a1);
            goto LABEL_53;
          }
          v9 = v8 - 1;
          if ( v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              v11 = v10 - 1;
              if ( v11 )
              {
                v12 = v11 - 1;
                if ( v12 )
                {
                  v13 = v12 - 1;
                  if ( v13 )
                  {
                    v14 = v13 - 1;
                    if ( v14 )
                    {
                      if ( v14 != 1 )
                        return 0xFFFFFFFFi64;
                      v15 = sub_140032A8C(a1);
                    }
                    else
                    {
                      v15 = sub_140030CF0(a1);
                    }
                    goto LABEL_53;
                  }
                  v16 = a1;
                  if ( *(_WORD *)(a1 + 66) != 42 )
                  {
                    v17 = a1 + 56;
LABEL_26:
                    v15 = unknown_libname_517(v16, v17);
                    goto LABEL_53;
                  }
                  if ( !sub_14003966C(a1) )
                    return 0xFFFFFFFFi64;
                  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
                  {
                    if ( *v6 < 0 )
                      *v6 = -1;
                    goto LABEL_40;
                  }
                }
                else
                {
                  *v6 = 0;
                }
              }
              else
              {
                v16 = a1;
                if ( *(_WORD *)(a1 + 66) != 42 )
                {
                  v17 = a1 + 52;
                  goto LABEL_26;
                }
                if ( !sub_1400391C4(a1) )
                  return 0xFFFFFFFFi64;
                if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
                {
                  v18 = *v5;
                  if ( *v5 < 0 )
                  {
                    *(_DWORD *)(a1 + 48) |= 4u;
                    *v5 = -v18;
                  }
LABEL_40:
                  v15 = 1;
LABEL_53:
                  if ( !v15 )
                    return 0xFFFFFFFFi64;
                }
              }
            }
            else
            {
              v19 = *(unsigned __int16 *)(a1 + 66);
              switch ( v19 )
              {
                case ' ':
                  *(_DWORD *)(a1 + 48) |= 2u;
                  break;
                case '#':
                  *(_DWORD *)(a1 + 48) |= 0x20u;
                  break;
                case '+':
                  *(_DWORD *)(a1 + 48) |= 1u;
                  break;
                case '-':
                  *(_DWORD *)(a1 + 48) |= 4u;
                  break;
                case '0':
                  *(_DWORD *)(a1 + 48) |= 8u;
                  break;
              }
            }
          }
          else
          {
            *v5 = 0;
            *(_BYTE *)(a1 + 64) = 0;
            *(_DWORD *)(a1 + 48) = 0;
            *v6 = -1;
            *(_DWORD *)(a1 + 60) = 0;
            *(_BYTE *)(a1 + 84) = 0;
          }
          v20 = **(_WORD **)(a1 + 24);
          *(_WORD *)(a1 + 66) = v20;
        }
        while ( v20 );
      }
      *(_QWORD *)(a1 + 24) += 2i64;
LABEL_56:
      if ( !(unsigned __int8)unknown_libname_647(a1) )
        return 0xFFFFFFFFi64;
    }
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 14002C9A8: using guessed type __int64 __fastcall unknown_libname_517(_QWORD, _QWORD);
// 14002F0F4: using guessed type __int64 __fastcall __crt_stdio_output::output_processor<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>,__crt_stdio_output::positional_parameter_base<wchar_t,__crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_normal(_QWORD);
// 140039C9C: using guessed type __int64 __fastcall unknown_libname_639(_QWORD);
// 14003A010: using guessed type __int64 __fastcall unknown_libname_647(_QWORD);
// 14007E800: using guessed type unsigned __int8 byte_14007E800[92];

//----- (000000014002E788) ----------------------------------------------------
__int64 __fastcall sub_14002E788(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014002E81C) ----------------------------------------------------
char sub_14002E81C()
{
  return 1;
}

//----- (000000014002E820) ----------------------------------------------------
char sub_14002E820()
{
  return 1;
}

//----- (000000014002E824) ----------------------------------------------------
char sub_14002E824()
{
  return 1;
}

//----- (000000014002E828) ----------------------------------------------------
char sub_14002E828()
{
  return 1;
}

//----- (000000014002EC74) ----------------------------------------------------
char __fastcall sub_14002EC74(__int64 a1)
{
  if ( (unsigned __int8)unknown_libname_553(a1, 0i64) )
  {
    if ( ((*(_DWORD *)(*(_QWORD *)(a1 + 1128) + 20i64) & 0x1000) == 0 || *(_QWORD *)(*(_QWORD *)(a1 + 1128) + 8i64))
      && (unsigned int)unknown_libname_857((unsigned int)*(char *)(a1 + 65), *(_QWORD *)(a1 + 1128)) == -1 )
    {
      *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
    }
    return 1;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
}
// 14002F5F4: using guessed type __int64 __fastcall unknown_libname_553(_QWORD, _QWORD);
// 14005CE20: using guessed type __int64 __fastcall unknown_libname_857(_QWORD, _QWORD);

//----- (000000014002ED7C) ----------------------------------------------------
char __fastcall sub_14002ED7C(__int64 a1)
{
  if ( (unsigned __int8)unknown_libname_555(a1, 0i64) )
  {
    if ( ((*(_DWORD *)(*(_QWORD *)(a1 + 1128) + 20i64) & 0x1000) == 0 || *(_QWORD *)(*(_QWORD *)(a1 + 1128) + 8i64))
      && (unsigned int)unknown_libname_857((unsigned int)*(char *)(a1 + 65), *(_QWORD *)(a1 + 1128)) == -1 )
    {
      *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
    }
    return 1;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
}
// 14002F71C: using guessed type __int64 __fastcall unknown_libname_555(_QWORD, _QWORD);
// 14005CE20: using guessed type __int64 __fastcall unknown_libname_857(_QWORD, _QWORD);

//----- (000000014002EDEC) ----------------------------------------------------
char __fastcall sub_14002EDEC(__int64 a1)
{
  __int64 v2; // rcx
  char v3; // r8

  if ( (unsigned __int8)unknown_libname_556(a1, 0i64) )
  {
    v2 = *(_QWORD *)(a1 + 1128);
    v3 = *(_BYTE *)(a1 + 65);
    if ( *(_QWORD *)(v2 + 16) == *(_QWORD *)(v2 + 8) )
    {
      if ( *(_BYTE *)(v2 + 24) )
        ++*(_DWORD *)(a1 + 40);
      else
        *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
      ++*(_QWORD *)(v2 + 16);
      *(_BYTE *)(**(_QWORD **)(a1 + 1128))++ = v3;
    }
    return 1;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
}
// 14002F7B0: using guessed type __int64 __fastcall unknown_libname_556(_QWORD, _QWORD);

//----- (000000014002EEFC) ----------------------------------------------------
char __fastcall sub_14002EEFC(__int64 a1)
{
  __int64 v2; // rcx
  char v3; // r8

  if ( (unsigned __int8)unknown_libname_558(a1, 0i64) )
  {
    v2 = *(_QWORD *)(a1 + 1128);
    v3 = *(_BYTE *)(a1 + 65);
    if ( *(_QWORD *)(v2 + 16) == *(_QWORD *)(v2 + 8) )
    {
      if ( *(_BYTE *)(v2 + 24) )
        ++*(_DWORD *)(a1 + 40);
      else
        *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
      ++*(_QWORD *)(v2 + 16);
      *(_BYTE *)(**(_QWORD **)(a1 + 1128))++ = v3;
    }
    return 1;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
}
// 14002F8E0: using guessed type __int64 __fastcall unknown_libname_558(_QWORD, _QWORD);

//----- (000000014002F1BC) ----------------------------------------------------
char __fastcall sub_14002F1BC(__int64 a1)
{
  char result; // al

  result = unknown_libname_553(a1, 0i64);
  if ( result )
  {
    if ( ((*(_DWORD *)(*(_QWORD *)(a1 + 1128) + 20i64) & 0x1000) == 0 || *(_QWORD *)(*(_QWORD *)(a1 + 1128) + 8i64))
      && (unsigned int)unknown_libname_857((unsigned int)*(char *)(a1 + 65), *(_QWORD *)(a1 + 1128)) == -1 )
    {
      *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
    }
    return 1;
  }
  return result;
}
// 14002F5F4: using guessed type __int64 __fastcall unknown_libname_553(_QWORD, _QWORD);
// 14005CE20: using guessed type __int64 __fastcall unknown_libname_857(_QWORD, _QWORD);

//----- (000000014002F218) ----------------------------------------------------
char __fastcall sub_14002F218(__int64 a1)
{
  char result; // al

  result = unknown_libname_554(a1, 0i64);
  if ( result )
  {
    if ( ((*(_DWORD *)(*(_QWORD *)(a1 + 1128) + 20i64) & 0x1000) == 0 || *(_QWORD *)(*(_QWORD *)(a1 + 1128) + 8i64))
      && (unsigned int)unknown_libname_857((unsigned int)*(char *)(a1 + 65), *(_QWORD *)(a1 + 1128)) == -1 )
    {
      *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
    }
    return 1;
  }
  return result;
}
// 14002F688: using guessed type __int64 __fastcall unknown_libname_554(_QWORD, _QWORD);
// 14005CE20: using guessed type __int64 __fastcall unknown_libname_857(_QWORD, _QWORD);

//----- (000000014002F274) ----------------------------------------------------
char __fastcall sub_14002F274(__int64 a1)
{
  char result; // al

  result = unknown_libname_555(a1, 0i64);
  if ( result )
  {
    if ( ((*(_DWORD *)(*(_QWORD *)(a1 + 1128) + 20i64) & 0x1000) == 0 || *(_QWORD *)(*(_QWORD *)(a1 + 1128) + 8i64))
      && (unsigned int)unknown_libname_857((unsigned int)*(char *)(a1 + 65), *(_QWORD *)(a1 + 1128)) == -1 )
    {
      *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
    }
    return 1;
  }
  return result;
}
// 14002F71C: using guessed type __int64 __fastcall unknown_libname_555(_QWORD, _QWORD);
// 14005CE20: using guessed type __int64 __fastcall unknown_libname_857(_QWORD, _QWORD);

//----- (000000014002F2D0) ----------------------------------------------------
char __fastcall sub_14002F2D0(__int64 a1)
{
  char result; // al
  __int64 v3; // rcx
  char v4; // r8

  result = unknown_libname_556(a1, 0i64);
  if ( result )
  {
    v3 = *(_QWORD *)(a1 + 1128);
    v4 = *(_BYTE *)(a1 + 65);
    if ( *(_QWORD *)(v3 + 16) == *(_QWORD *)(v3 + 8) )
    {
      if ( *(_BYTE *)(v3 + 24) )
        ++*(_DWORD *)(a1 + 40);
      else
        *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
      ++*(_QWORD *)(v3 + 16);
      *(_BYTE *)(**(_QWORD **)(a1 + 1128))++ = v4;
    }
    return 1;
  }
  return result;
}
// 14002F7B0: using guessed type __int64 __fastcall unknown_libname_556(_QWORD, _QWORD);

//----- (000000014002F330) ----------------------------------------------------
char __fastcall sub_14002F330(__int64 a1)
{
  char result; // al
  __int64 v3; // rcx
  char v4; // r8

  result = unknown_libname_557(a1, 0i64);
  if ( result )
  {
    v3 = *(_QWORD *)(a1 + 1128);
    v4 = *(_BYTE *)(a1 + 65);
    if ( *(_QWORD *)(v3 + 16) == *(_QWORD *)(v3 + 8) )
    {
      if ( *(_BYTE *)(v3 + 24) )
        ++*(_DWORD *)(a1 + 40);
      else
        *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
      ++*(_QWORD *)(v3 + 16);
      *(_BYTE *)(**(_QWORD **)(a1 + 1128))++ = v4;
    }
    return 1;
  }
  return result;
}
// 14002F848: using guessed type __int64 __fastcall unknown_libname_557(_QWORD, _QWORD);

//----- (000000014002F390) ----------------------------------------------------
char __fastcall sub_14002F390(__int64 a1)
{
  char result; // al
  __int64 v3; // rcx
  char v4; // r8

  result = unknown_libname_558(a1, 0i64);
  if ( result )
  {
    v3 = *(_QWORD *)(a1 + 1128);
    v4 = *(_BYTE *)(a1 + 65);
    if ( *(_QWORD *)(v3 + 16) == *(_QWORD *)(v3 + 8) )
    {
      if ( *(_BYTE *)(v3 + 24) )
        ++*(_DWORD *)(a1 + 40);
      else
        *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
      ++*(_QWORD *)(v3 + 16);
      *(_BYTE *)(**(_QWORD **)(a1 + 1128))++ = v4;
    }
    return 1;
  }
  return result;
}
// 14002F8E0: using guessed type __int64 __fastcall unknown_libname_558(_QWORD, _QWORD);

//----- (000000014002F978) ----------------------------------------------------
char __fastcall sub_14002F978(__int64 a1)
{
  *(_BYTE *)(a1 + 84) = 1;
  return 1;
}

//----- (000000014002F980) ----------------------------------------------------
char __fastcall sub_14002F980(__int64 a1)
{
  *(_BYTE *)(a1 + 84) = 1;
  return 1;
}

//----- (000000014002F988) ----------------------------------------------------
char __fastcall sub_14002F988(__int64 a1)
{
  *(_BYTE *)(a1 + 84) = 1;
  return 1;
}

//----- (000000014002F990) ----------------------------------------------------
char __fastcall sub_14002F990(__int64 a1)
{
  *(_BYTE *)(a1 + 84) = 1;
  return 1;
}

//----- (000000014002F998) ----------------------------------------------------
char __fastcall sub_14002F998(__int64 a1)
{
  *(_BYTE *)(a1 + 84) = 1;
  return 1;
}

//----- (000000014002F9A0) ----------------------------------------------------
char __fastcall sub_14002F9A0(__int64 a1)
{
  *(_BYTE *)(a1 + 84) = 1;
  return 1;
}

//----- (000000014002FAF8) ----------------------------------------------------
char __fastcall sub_14002FAF8(__int64 a1)
{
  char result; // al

  if ( *(_BYTE *)(a1 + 65) != 42 )
    return unknown_libname_508(a1, a1 + 56);
  result = sub_14003932C(a1);
  if ( result )
  {
    if ( (*(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1) && *(int *)(a1 + 56) < 0 )
      *(_DWORD *)(a1 + 56) = -1;
    return 1;
  }
  return result;
}
// 14002C514: using guessed type __int64 __fastcall unknown_libname_508(_QWORD, _QWORD);

//----- (000000014002FBA4) ----------------------------------------------------
char __fastcall sub_14002FBA4(__int64 a1)
{
  char result; // al

  if ( *(_BYTE *)(a1 + 65) != 42 )
    return unknown_libname_511(a1, a1 + 56);
  result = sub_140039440(a1);
  if ( result )
  {
    if ( (*(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1) && *(int *)(a1 + 56) < 0 )
      *(_DWORD *)(a1 + 56) = -1;
    return 1;
  }
  return result;
}
// 14002C6A0: using guessed type __int64 __fastcall unknown_libname_511(_QWORD, _QWORD);

//----- (000000014002FC50) ----------------------------------------------------
char __fastcall sub_14002FC50(__int64 a1)
{
  char result; // al

  if ( *(_WORD *)(a1 + 66) != 42 )
    return unknown_libname_514(a1, a1 + 56);
  result = sub_140039554(a1);
  if ( result )
  {
    if ( (*(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1) && *(int *)(a1 + 56) < 0 )
      *(_DWORD *)(a1 + 56) = -1;
    return 1;
  }
  return result;
}
// 14002C828: using guessed type __int64 __fastcall unknown_libname_514(_QWORD, _QWORD);

//----- (000000014002FCFC) ----------------------------------------------------
char __fastcall sub_14002FCFC(__int64 a1)
{
  char result; // al

  if ( *(_WORD *)(a1 + 66) != 42 )
    return unknown_libname_517(a1, a1 + 56);
  result = sub_14003966C(a1);
  if ( result )
  {
    if ( (*(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1) && *(int *)(a1 + 56) < 0 )
      *(_DWORD *)(a1 + 56) = -1;
    return 1;
  }
  return result;
}
// 14002C9A8: using guessed type __int64 __fastcall unknown_libname_517(_QWORD, _QWORD);

//----- (000000014002FD78) ----------------------------------------------------
char __fastcall sub_14002FD78(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // al
  char result; // al
  bool v6; // zf
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  char *v9; // rdx
  char v10; // al
  unsigned __int8 v11; // al
  __int64 v12; // rdx

  v4 = *(_BYTE *)(a1 + 65);
  if ( v4 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140031038(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( v4 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v4 )
  {
    case 'I':
      v9 = *(char **)(a1 + 24);
      v10 = *v9;
      if ( *v9 == 51 && v9[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, (char)v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_BYTE **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_BYTE **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v4 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (000000014002FEF4) ----------------------------------------------------
char __fastcall sub_14002FEF4(__int64 a1)
{
  char v1; // al
  char result; // al
  bool v3; // zf
  _BYTE *v4; // rax
  _BYTE *v5; // rax
  char *v6; // rdx
  char v7; // al
  unsigned __int8 v8; // al
  __int64 v9; // rdx

  v1 = *(_BYTE *)(a1 + 65);
  if ( v1 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_1400312B4(a1);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v1 )
  {
    case 'I':
      v6 = *(char **)(a1 + 24);
      v7 = *v6;
      if ( *v6 == 51 && v6[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else if ( v7 == 54 && v6[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else
      {
        v8 = v7 - 88;
        if ( v8 <= 0x20u )
        {
          v9 = 0x120821001i64;
          if ( _bittest64(&v9, (char)v8) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v5 = *(_BYTE **)(a1 + 24);
      if ( *v5 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v5 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v4 = *(_BYTE **)(a1 + 24);
      if ( *v4 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v4 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v3 = v1 == 122;
  result = 1;
  if ( v3 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140030070) ----------------------------------------------------
char __fastcall sub_140030070(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // al
  char result; // al
  bool v6; // zf
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  char *v9; // rdx
  char v10; // al
  unsigned __int8 v11; // al
  __int64 v12; // rdx

  v4 = *(_BYTE *)(a1 + 65);
  if ( v4 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140031544(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( v4 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v4 )
  {
    case 'I':
      v9 = *(char **)(a1 + 24);
      v10 = *v9;
      if ( *v9 == 51 && v9[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, (char)v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_BYTE **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_BYTE **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v4 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (00000001400301EC) ----------------------------------------------------
char __fastcall sub_1400301EC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // al
  char result; // al
  bool v6; // zf
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  char *v9; // rdx
  char v10; // al
  unsigned __int8 v11; // al
  __int64 v12; // rdx

  v4 = *(_BYTE *)(a1 + 65);
  if ( v4 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_1400317C0(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( v4 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v4 )
  {
    case 'I':
      v9 = *(char **)(a1 + 24);
      v10 = *v9;
      if ( *v9 == 51 && v9[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, (char)v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_BYTE **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_BYTE **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v4 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140030368) ----------------------------------------------------
char __fastcall sub_140030368(__int64 a1)
{
  char v1; // al
  char result; // al
  bool v3; // zf
  _BYTE *v4; // rax
  _BYTE *v5; // rax
  char *v6; // rdx
  char v7; // al
  unsigned __int8 v8; // al
  __int64 v9; // rdx

  v1 = *(_BYTE *)(a1 + 65);
  if ( v1 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140031A3C(a1);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v1 )
  {
    case 'I':
      v6 = *(char **)(a1 + 24);
      v7 = *v6;
      if ( *v6 == 51 && v6[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else if ( v7 == 54 && v6[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else
      {
        v8 = v7 - 88;
        if ( v8 <= 0x20u )
        {
          v9 = 0x120821001i64;
          if ( _bittest64(&v9, (char)v8) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v5 = *(_BYTE **)(a1 + 24);
      if ( *v5 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v5 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v4 = *(_BYTE **)(a1 + 24);
      if ( *v4 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v4 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v3 = v1 == 122;
  result = 1;
  if ( v3 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (00000001400304E4) ----------------------------------------------------
char __fastcall sub_1400304E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // al
  char result; // al
  bool v6; // zf
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  char *v9; // rdx
  char v10; // al
  unsigned __int8 v11; // al
  __int64 v12; // rdx

  v4 = *(_BYTE *)(a1 + 65);
  if ( v4 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140031CCC(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( v4 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v4 )
  {
    case 'I':
      v9 = *(char **)(a1 + 24);
      v10 = *v9;
      if ( *v9 == 51 && v9[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, (char)v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_BYTE **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_BYTE **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v4 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140030660) ----------------------------------------------------
char __fastcall sub_140030660(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char result; // al
  int v5; // eax
  bool v6; // zf
  _WORD *v7; // rax
  _WORD *v8; // rax
  __int16 *v9; // rdx
  __int16 v10; // ax
  unsigned __int16 v11; // ax
  __int64 v12; // rdx

  if ( *(_WORD *)(a1 + 66) == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140031F48(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( *(_WORD *)(a1 + 66) == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  v5 = *(unsigned __int16 *)(a1 + 66);
  switch ( v5 )
  {
    case 'I':
      v9 = *(__int16 **)(a1 + 24);
      v10 = *v9;
      if ( *(_DWORD *)v9 == 3276851 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_WORD **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_WORD **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v5 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140030804) ----------------------------------------------------
char __fastcall sub_140030804(__int64 a1)
{
  char result; // al
  int v2; // eax
  bool v3; // zf
  _WORD *v4; // rax
  _WORD *v5; // rax
  __int16 *v6; // rdx
  __int16 v7; // ax
  unsigned __int16 v8; // ax
  __int64 v9; // rdx

  if ( *(_WORD *)(a1 + 66) == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140032214(a1);
    }
    return 1;
  }
  if ( *(_WORD *)(a1 + 66) == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  v2 = *(unsigned __int16 *)(a1 + 66);
  switch ( v2 )
  {
    case 'I':
      v6 = *(__int16 **)(a1 + 24);
      v7 = *v6;
      if ( *(_DWORD *)v6 == 3276851 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else if ( v7 == 54 && v6[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else
      {
        v8 = v7 - 88;
        if ( v8 <= 0x20u )
        {
          v9 = 0x120821001i64;
          if ( _bittest64(&v9, v8) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v5 = *(_WORD **)(a1 + 24);
      if ( *v5 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v5 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v4 = *(_WORD **)(a1 + 24);
      if ( *v4 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v4 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v3 = v2 == 122;
  result = 1;
  if ( v3 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (00000001400309A8) ----------------------------------------------------
char __fastcall sub_1400309A8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char result; // al
  int v5; // eax
  bool v6; // zf
  _WORD *v7; // rax
  _WORD *v8; // rax
  __int16 *v9; // rdx
  __int16 v10; // ax
  unsigned __int16 v11; // ax
  __int64 v12; // rdx

  if ( *(_WORD *)(a1 + 66) == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_1400324F4(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( *(_WORD *)(a1 + 66) == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  v5 = *(unsigned __int16 *)(a1 + 66);
  switch ( v5 )
  {
    case 'I':
      v9 = *(__int16 **)(a1 + 24);
      v10 = *v9;
      if ( *(_DWORD *)v9 == 3276851 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_WORD **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_WORD **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v5 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140030B4C) ----------------------------------------------------
char __fastcall sub_140030B4C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char result; // al
  int v5; // eax
  bool v6; // zf
  _WORD *v7; // rax
  _WORD *v8; // rax
  __int16 *v9; // rdx
  __int16 v10; // ax
  unsigned __int16 v11; // ax
  __int64 v12; // rdx

  if ( *(_WORD *)(a1 + 66) == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_1400327C0(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( *(_WORD *)(a1 + 66) == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  v5 = *(unsigned __int16 *)(a1 + 66);
  switch ( v5 )
  {
    case 'I':
      v9 = *(__int16 **)(a1 + 24);
      v10 = *v9;
      if ( *(_DWORD *)v9 == 3276851 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_WORD **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_WORD **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v5 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140030CF0) ----------------------------------------------------
char __fastcall sub_140030CF0(__int64 a1)
{
  char result; // al
  int v2; // eax
  bool v3; // zf
  _WORD *v4; // rax
  _WORD *v5; // rax
  __int16 *v6; // rdx
  __int16 v7; // ax
  unsigned __int16 v8; // ax
  __int64 v9; // rdx

  if ( *(_WORD *)(a1 + 66) == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140032A8C(a1);
    }
    return 1;
  }
  if ( *(_WORD *)(a1 + 66) == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  v2 = *(unsigned __int16 *)(a1 + 66);
  switch ( v2 )
  {
    case 'I':
      v6 = *(__int16 **)(a1 + 24);
      v7 = *v6;
      if ( *(_DWORD *)v6 == 3276851 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else if ( v7 == 54 && v6[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else
      {
        v8 = v7 - 88;
        if ( v8 <= 0x20u )
        {
          v9 = 0x120821001i64;
          if ( _bittest64(&v9, v8) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v5 = *(_WORD **)(a1 + 24);
      if ( *v5 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v5 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v4 = *(_WORD **)(a1 + 24);
      if ( *v4 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v4 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v3 = v2 == 122;
  result = 1;
  if ( v3 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140030E94) ----------------------------------------------------
char __fastcall sub_140030E94(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char result; // al
  int v5; // eax
  bool v6; // zf
  _WORD *v7; // rax
  _WORD *v8; // rax
  __int16 *v9; // rdx
  __int16 v10; // ax
  unsigned __int16 v11; // ax
  __int64 v12; // rdx

  if ( *(_WORD *)(a1 + 66) == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_140032D6C(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( *(_WORD *)(a1 + 66) == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  v5 = *(unsigned __int16 *)(a1 + 66);
  switch ( v5 )
  {
    case 'I':
      v9 = *(__int16 **)(a1 + 24);
      v10 = *v9;
      if ( *(_DWORD *)v9 == 3276851 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else if ( v10 == 54 && v9[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v9 + 2;
      }
      else
      {
        v11 = v10 - 88;
        if ( v11 <= 0x20u )
        {
          v12 = 0x120821001i64;
          if ( _bittest64(&v12, v11) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v8 = *(_WORD **)(a1 + 24);
      if ( *v8 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v8 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v7 = *(_WORD **)(a1 + 24);
      if ( *v7 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v7 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v6 = v5 == 122;
  result = 1;
  if ( v6 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (0000000140031038) ----------------------------------------------------
char __fastcall sub_140031038(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  char v13; // cl
  bool v14; // r8
  bool v15; // al
  unsigned int v16; // esi
  __int64 v17; // rdx
  int v18; // ecx
  __int64 v19; // rdx
  __int16 v20; // [rsp+50h] [rbp+8h] BYREF
  char v21; // [rsp+52h] [rbp+Ah]

  v4 = *(char *)(a1 + 65);
  v5 = a1;
  if ( v4 > 100 )
  {
    if ( v4 <= 103 )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_595();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140036014(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_603();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_587(a1, 0i64);
      goto LABEL_35;
    }
    if ( v4 <= 68 )
      return 0;
    if ( v4 > 71 )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_571();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_579();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v20 = 0;
    v12 = 0i64;
    v21 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_46;
    if ( (v11 & 0x40) != 0 )
    {
      LOBYTE(v20) = 45;
    }
    else if ( (v11 & 1) != 0 )
    {
      LOBYTE(v20) = 43;
    }
    else
    {
      if ( (v11 & 2) == 0 )
        goto LABEL_46;
      LOBYTE(v20) = 32;
    }
    v12 = 1i64;
LABEL_46:
    v13 = *(_BYTE *)(v5 + 65);
    v14 = ((v13 - 88) & 0xDF) == 0 && (v11 & 0x20) != 0;
    if ( v14 || ((v13 - 65) & 0xDF) == 0 )
    {
      *((_BYTE *)&v20 + v12++) = 48;
      v15 = v13 == 88 || v13 == 65;
      *((_BYTE *)&v20 + v12) = v15 ? 88 : 120;
      LODWORD(v12) = v12 + 1;
    }
    v16 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
    if ( (v11 & 0xC) == 0 )
    {
      LOBYTE(v11) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v11,
        v16,
        v5 + 40);
    }
    __crt_stdio_output::stream_output_adapter<char>::write_string(
      v5 + 1128,
      (unsigned int)&v20,
      v12,
      v5 + 40,
      *(_QWORD *)(v5 + 16));
    v18 = *(_DWORD *)(v5 + 48);
    if ( (v18 & 8) != 0 && (v18 & 4) == 0 )
    {
      LOBYTE(v17) = 48;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v17,
        v16,
        v5 + 40);
    }
    unknown_libname_650(v5, 0i64);
    if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
    {
      LOBYTE(v19) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v19,
        v16,
        v5 + 40);
    }
  }
  return 1;
}
// 140031265: variable 'v17' is possibly undefined
// 140031290: variable 'v19' is possibly undefined
// 140029EB4: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 14003348C: using guessed type __int64 unknown_libname_571(void);
// 140033B04: using guessed type __int64 unknown_libname_579(void);
// 14003565C: using guessed type __int64 __fastcall unknown_libname_587(_QWORD, _QWORD);
// 140037524: using guessed type __int64 unknown_libname_595(void);
// 1400382B4: using guessed type __int64 unknown_libname_603(void);
// 14003A548: using guessed type __int64 __fastcall unknown_libname_650(_QWORD, _QWORD);
// 14003AFEC: using guessed type __int64 __fastcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (00000001400312B4) ----------------------------------------------------
char __fastcall sub_1400312B4(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rbx
  char v3; // al
  unsigned int v4; // edx
  char v5; // r8
  int v6; // ecx
  __int64 v8; // rdx
  __int64 v9; // rdi
  char v10; // cl
  bool v11; // r8
  bool v12; // al
  unsigned int v13; // esi
  __int64 v14; // rdx
  int v15; // ecx
  __int64 v16; // rdx
  __int16 v17; // [rsp+50h] [rbp+8h] BYREF
  char v18; // [rsp+52h] [rbp+Ah]

  v1 = *(char *)(a1 + 65);
  v2 = a1;
  if ( v1 > 100 )
  {
    if ( v1 <= 103 )
      goto LABEL_34;
    if ( v1 != 105 )
    {
      switch ( v1 )
      {
        case 'n':
          v3 = sub_140037600(a1);
          goto LABEL_35;
        case 'o':
          v6 = *(_DWORD *)(a1 + 48);
          if ( (v6 & 0x20) != 0 )
            *(_DWORD *)(v2 + 48) = v6 | 0x80;
          v4 = 8;
          a1 = v2;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v5 = 1;
          v4 = 16;
LABEL_33:
          v3 = sub_1400361B4(a1, v4, v5);
          goto LABEL_35;
        case 's':
LABEL_23:
          v3 = sub_140038344(a1);
          goto LABEL_35;
      }
      if ( v1 != 117 )
      {
        if ( v1 != 120 )
          return 0;
        v4 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v4 = 10;
LABEL_32:
      v5 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v1 == 100 )
    goto LABEL_30;
  if ( v1 != 65 )
  {
    if ( v1 == 67 )
    {
LABEL_12:
      v3 = sub_140035710(a1, 0i64);
      goto LABEL_35;
    }
    if ( v1 <= 68 )
      return 0;
    if ( v1 > 71 )
    {
      if ( v1 != 83 )
      {
        if ( v1 != 88 )
        {
          if ( v1 == 90 )
          {
            v3 = sub_14003350C(a1);
            goto LABEL_35;
          }
          if ( v1 != 97 )
          {
            if ( v1 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v3 = sub_140033D20(a1);
LABEL_35:
  if ( !v3 )
    return 0;
  if ( (*(_DWORD *)(v2 + 1148) != 2 || *(_DWORD *)(v2 + 1144) != 1) && !*(_BYTE *)(v2 + 64) )
  {
    v8 = *(unsigned int *)(v2 + 48);
    v17 = 0;
    v9 = 0i64;
    v18 = 0;
    if ( (v8 & 0x10) == 0 )
      goto LABEL_48;
    if ( (v8 & 0x40) != 0 )
    {
      LOBYTE(v17) = 45;
    }
    else if ( (v8 & 1) != 0 )
    {
      LOBYTE(v17) = 43;
    }
    else
    {
      if ( (v8 & 2) == 0 )
        goto LABEL_48;
      LOBYTE(v17) = 32;
    }
    v9 = 1i64;
LABEL_48:
    v10 = *(_BYTE *)(v2 + 65);
    v11 = ((v10 - 88) & 0xDF) == 0 && (v8 & 0x20) != 0;
    if ( v11 || ((v10 - 65) & 0xDF) == 0 )
    {
      *((_BYTE *)&v17 + v9++) = 48;
      v12 = v10 == 88 || v10 == 65;
      *((_BYTE *)&v17 + v9) = v12 ? 88 : 120;
      LODWORD(v9) = v9 + 1;
    }
    v13 = *(_DWORD *)(v2 + 52) - *(_DWORD *)(v2 + 80) - v9;
    if ( (v8 & 0xC) == 0 )
    {
      LOBYTE(v8) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v2 + 1128,
        v8,
        v13,
        v2 + 40);
    }
    __crt_stdio_output::stream_output_adapter<char>::write_string(
      v2 + 1128,
      (unsigned int)&v17,
      v9,
      v2 + 40,
      *(_QWORD *)(v2 + 16));
    v15 = *(_DWORD *)(v2 + 48);
    if ( (v15 & 8) != 0 && (v15 & 4) == 0 )
    {
      LOBYTE(v14) = 48;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v2 + 1128,
        v14,
        v13,
        v2 + 40);
    }
    unknown_libname_651(v2, 0i64);
    if ( *(int *)(v2 + 40) >= 0 && (*(_DWORD *)(v2 + 48) & 4) != 0 )
    {
      LOBYTE(v16) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v2 + 1128,
        v16,
        v13,
        v2 + 40);
    }
  }
  return 1;
}
// 1400314F7: variable 'v14' is possibly undefined
// 140031522: variable 'v16' is possibly undefined
// 140029EB4: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 14003A620: using guessed type __int64 __fastcall unknown_libname_651(_QWORD, _QWORD);
// 14003AFEC: using guessed type __int64 __fastcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140031544) ----------------------------------------------------
char __fastcall sub_140031544(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  char v13; // cl
  bool v14; // r8
  bool v15; // al
  unsigned int v16; // esi
  __int64 v17; // rdx
  int v18; // ecx
  __int64 v19; // rdx
  __int16 v20; // [rsp+50h] [rbp+8h] BYREF
  char v21; // [rsp+52h] [rbp+Ah]

  v4 = *(char *)(a1 + 65);
  v5 = a1;
  if ( v4 > 100 )
  {
    if ( v4 <= 103 )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_596();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_1400363B8(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_604();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_588(a1, 0i64);
      goto LABEL_35;
    }
    if ( v4 <= 68 )
      return 0;
    if ( v4 > 71 )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_572();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_580();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v20 = 0;
    v12 = 0i64;
    v21 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_46;
    if ( (v11 & 0x40) != 0 )
    {
      LOBYTE(v20) = 45;
    }
    else if ( (v11 & 1) != 0 )
    {
      LOBYTE(v20) = 43;
    }
    else
    {
      if ( (v11 & 2) == 0 )
        goto LABEL_46;
      LOBYTE(v20) = 32;
    }
    v12 = 1i64;
LABEL_46:
    v13 = *(_BYTE *)(v5 + 65);
    v14 = ((v13 - 88) & 0xDF) == 0 && (v11 & 0x20) != 0;
    if ( v14 || ((v13 - 65) & 0xDF) == 0 )
    {
      *((_BYTE *)&v20 + v12++) = 48;
      v15 = v13 == 88 || v13 == 65;
      *((_BYTE *)&v20 + v12) = v15 ? 88 : 120;
      LODWORD(v12) = v12 + 1;
    }
    v16 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
    if ( (v11 & 0xC) == 0 )
    {
      LOBYTE(v11) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v11,
        v16,
        v5 + 40);
    }
    __crt_stdio_output::stream_output_adapter<char>::write_string(
      v5 + 1128,
      (unsigned int)&v20,
      v12,
      v5 + 40,
      *(_QWORD *)(v5 + 16));
    v18 = *(_DWORD *)(v5 + 48);
    if ( (v18 & 8) != 0 && (v18 & 4) == 0 )
    {
      LOBYTE(v17) = 48;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v17,
        v16,
        v5 + 40);
    }
    unknown_libname_652(v5, 0i64);
    if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
    {
      LOBYTE(v19) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(
        v5 + 1128,
        v19,
        v16,
        v5 + 40);
    }
  }
  return 1;
}
// 140031771: variable 'v17' is possibly undefined
// 14003179C: variable 'v19' is possibly undefined
// 140029EB4: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400335A8: using guessed type __int64 unknown_libname_572(void);
// 140033F6C: using guessed type __int64 unknown_libname_580(void);
// 140035808: using guessed type __int64 __fastcall unknown_libname_588(_QWORD, _QWORD);
// 140037704: using guessed type __int64 unknown_libname_596(void);
// 1400383EC: using guessed type __int64 unknown_libname_604(void);
// 14003A6F8: using guessed type __int64 __fastcall unknown_libname_652(_QWORD, _QWORD);
// 14003AFEC: using guessed type __int64 __fastcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (00000001400317C0) ----------------------------------------------------
char __fastcall sub_1400317C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  char v13; // cl
  bool v14; // r8
  bool v15; // al
  unsigned int v16; // esi
  __int64 v17; // rdx
  int v18; // ecx
  __int64 v19; // rdx
  __int16 v20; // [rsp+50h] [rbp+8h] BYREF
  char v21; // [rsp+52h] [rbp+Ah]

  v4 = *(char *)(a1 + 65);
  v5 = a1;
  if ( v4 > 100 )
  {
    if ( v4 <= 103 )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_597();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140036558(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_605();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_589(a1, 0i64);
      goto LABEL_35;
    }
    if ( v4 <= 68 )
      return 0;
    if ( v4 > 71 )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_573();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_581();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v20 = 0;
    v12 = 0i64;
    v21 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_46;
    if ( (v11 & 0x40) != 0 )
    {
      LOBYTE(v20) = 45;
    }
    else if ( (v11 & 1) != 0 )
    {
      LOBYTE(v20) = 43;
    }
    else
    {
      if ( (v11 & 2) == 0 )
        goto LABEL_46;
      LOBYTE(v20) = 32;
    }
    v12 = 1i64;
LABEL_46:
    v13 = *(_BYTE *)(v5 + 65);
    v14 = ((v13 - 88) & 0xDF) == 0 && (v11 & 0x20) != 0;
    if ( v14 || ((v13 - 65) & 0xDF) == 0 )
    {
      *((_BYTE *)&v20 + v12++) = 48;
      v15 = v13 == 88 || v13 == 65;
      *((_BYTE *)&v20 + v12) = v15 ? 88 : 120;
      LODWORD(v12) = v12 + 1;
    }
    v16 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
    if ( (v11 & 0xC) == 0 )
    {
      LOBYTE(v11) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v11,
        v16,
        v5 + 40);
    }
    __crt_stdio_output::string_output_adapter<char>::write_string(
      v5 + 1128,
      (unsigned int)&v20,
      v12,
      v5 + 40,
      *(_QWORD *)(v5 + 16));
    v18 = *(_DWORD *)(v5 + 48);
    if ( (v18 & 8) != 0 && (v18 & 4) == 0 )
    {
      LOBYTE(v17) = 48;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v17,
        v16,
        v5 + 40);
    }
    unknown_libname_653(v5, 0i64);
    if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
    {
      LOBYTE(v19) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v19,
        v16,
        v5 + 40);
    }
  }
  return 1;
}
// 1400319ED: variable 'v17' is possibly undefined
// 140031A18: variable 'v19' is possibly undefined
// 140029FC8: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140033628: using guessed type __int64 unknown_libname_573(void);
// 140034188: using guessed type __int64 unknown_libname_581(void);
// 1400358BC: using guessed type __int64 __fastcall unknown_libname_589(_QWORD, _QWORD);
// 1400377E0: using guessed type __int64 unknown_libname_597(void);
// 14003847C: using guessed type __int64 unknown_libname_605(void);
// 14003A7D0: using guessed type __int64 __fastcall unknown_libname_653(_QWORD, _QWORD);
// 14003B1F0: using guessed type __int64 __fastcall __crt_stdio_output::string_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140031A3C) ----------------------------------------------------
char __fastcall sub_140031A3C(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rbx
  char v3; // al
  unsigned int v4; // edx
  char v5; // r8
  int v6; // ecx
  __int64 v8; // rdx
  __int64 v9; // rdi
  char v10; // cl
  bool v11; // r8
  bool v12; // al
  unsigned int v13; // esi
  __int64 v14; // rdx
  int v15; // ecx
  __int64 v16; // rdx
  __int16 v17; // [rsp+50h] [rbp+8h] BYREF
  char v18; // [rsp+52h] [rbp+Ah]

  v1 = *(char *)(a1 + 65);
  v2 = a1;
  if ( v1 > 100 )
  {
    if ( v1 <= 103 )
      goto LABEL_34;
    if ( v1 != 105 )
    {
      switch ( v1 )
      {
        case 'n':
          v3 = sub_1400378BC(a1);
          goto LABEL_35;
        case 'o':
          v6 = *(_DWORD *)(a1 + 48);
          if ( (v6 & 0x20) != 0 )
            *(_DWORD *)(v2 + 48) = v6 | 0x80;
          v4 = 8;
          a1 = v2;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v5 = 1;
          v4 = 16;
LABEL_33:
          v3 = sub_1400366F8(a1, v4, v5);
          goto LABEL_35;
        case 's':
LABEL_23:
          v3 = sub_14003850C(a1);
          goto LABEL_35;
      }
      if ( v1 != 117 )
      {
        if ( v1 != 120 )
          return 0;
        v4 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v4 = 10;
LABEL_32:
      v5 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v1 == 100 )
    goto LABEL_30;
  if ( v1 != 65 )
  {
    if ( v1 == 67 )
    {
LABEL_12:
      v3 = sub_140035970(a1, 0i64);
      goto LABEL_35;
    }
    if ( v1 <= 68 )
      return 0;
    if ( v1 > 71 )
    {
      if ( v1 != 83 )
      {
        if ( v1 != 88 )
        {
          if ( v1 == 90 )
          {
            v3 = sub_1400336A8(a1);
            goto LABEL_35;
          }
          if ( v1 != 97 )
          {
            if ( v1 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v3 = sub_1400343A4(a1);
LABEL_35:
  if ( !v3 )
    return 0;
  if ( (*(_DWORD *)(v2 + 1148) != 2 || *(_DWORD *)(v2 + 1144) != 1) && !*(_BYTE *)(v2 + 64) )
  {
    v8 = *(unsigned int *)(v2 + 48);
    v17 = 0;
    v9 = 0i64;
    v18 = 0;
    if ( (v8 & 0x10) == 0 )
      goto LABEL_48;
    if ( (v8 & 0x40) != 0 )
    {
      LOBYTE(v17) = 45;
    }
    else if ( (v8 & 1) != 0 )
    {
      LOBYTE(v17) = 43;
    }
    else
    {
      if ( (v8 & 2) == 0 )
        goto LABEL_48;
      LOBYTE(v17) = 32;
    }
    v9 = 1i64;
LABEL_48:
    v10 = *(_BYTE *)(v2 + 65);
    v11 = ((v10 - 88) & 0xDF) == 0 && (v8 & 0x20) != 0;
    if ( v11 || ((v10 - 65) & 0xDF) == 0 )
    {
      *((_BYTE *)&v17 + v9++) = 48;
      v12 = v10 == 88 || v10 == 65;
      *((_BYTE *)&v17 + v9) = v12 ? 88 : 120;
      LODWORD(v9) = v9 + 1;
    }
    v13 = *(_DWORD *)(v2 + 52) - *(_DWORD *)(v2 + 80) - v9;
    if ( (v8 & 0xC) == 0 )
    {
      LOBYTE(v8) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v2 + 1128,
        v8,
        v13,
        v2 + 40);
    }
    __crt_stdio_output::string_output_adapter<char>::write_string(
      v2 + 1128,
      (unsigned int)&v17,
      v9,
      v2 + 40,
      *(_QWORD *)(v2 + 16));
    v15 = *(_DWORD *)(v2 + 48);
    if ( (v15 & 8) != 0 && (v15 & 4) == 0 )
    {
      LOBYTE(v14) = 48;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v2 + 1128,
        v14,
        v13,
        v2 + 40);
    }
    unknown_libname_654(v2, 0i64);
    if ( *(int *)(v2 + 40) >= 0 && (*(_DWORD *)(v2 + 48) & 4) != 0 )
    {
      LOBYTE(v16) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v2 + 1128,
        v16,
        v13,
        v2 + 40);
    }
  }
  return 1;
}
// 140031C7F: variable 'v14' is possibly undefined
// 140031CAA: variable 'v16' is possibly undefined
// 140029FC8: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 14003A8A8: using guessed type __int64 __fastcall unknown_libname_654(_QWORD, _QWORD);
// 14003B1F0: using guessed type __int64 __fastcall __crt_stdio_output::string_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140031CCC) ----------------------------------------------------
char __fastcall sub_140031CCC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  char v13; // cl
  bool v14; // r8
  bool v15; // al
  unsigned int v16; // esi
  __int64 v17; // rdx
  int v18; // ecx
  __int64 v19; // rdx
  __int16 v20; // [rsp+50h] [rbp+8h] BYREF
  char v21; // [rsp+52h] [rbp+Ah]

  v4 = *(char *)(a1 + 65);
  v5 = a1;
  if ( v4 > 100 )
  {
    if ( v4 <= 103 )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_598();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_1400368FC(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_606();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_590(a1, 0i64);
      goto LABEL_35;
    }
    if ( v4 <= 68 )
      return 0;
    if ( v4 > 71 )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_574();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_582();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v20 = 0;
    v12 = 0i64;
    v21 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_46;
    if ( (v11 & 0x40) != 0 )
    {
      LOBYTE(v20) = 45;
    }
    else if ( (v11 & 1) != 0 )
    {
      LOBYTE(v20) = 43;
    }
    else
    {
      if ( (v11 & 2) == 0 )
        goto LABEL_46;
      LOBYTE(v20) = 32;
    }
    v12 = 1i64;
LABEL_46:
    v13 = *(_BYTE *)(v5 + 65);
    v14 = ((v13 - 88) & 0xDF) == 0 && (v11 & 0x20) != 0;
    if ( v14 || ((v13 - 65) & 0xDF) == 0 )
    {
      *((_BYTE *)&v20 + v12++) = 48;
      v15 = v13 == 88 || v13 == 65;
      *((_BYTE *)&v20 + v12) = v15 ? 88 : 120;
      LODWORD(v12) = v12 + 1;
    }
    v16 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
    if ( (v11 & 0xC) == 0 )
    {
      LOBYTE(v11) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v11,
        v16,
        v5 + 40);
    }
    __crt_stdio_output::string_output_adapter<char>::write_string(
      v5 + 1128,
      (unsigned int)&v20,
      v12,
      v5 + 40,
      *(_QWORD *)(v5 + 16));
    v18 = *(_DWORD *)(v5 + 48);
    if ( (v18 & 8) != 0 && (v18 & 4) == 0 )
    {
      LOBYTE(v17) = 48;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v17,
        v16,
        v5 + 40);
    }
    unknown_libname_655(v5, 0i64);
    if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
    {
      LOBYTE(v19) = 32;
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        v5 + 1128,
        v19,
        v16,
        v5 + 40);
    }
  }
  return 1;
}
// 140031EF9: variable 'v17' is possibly undefined
// 140031F24: variable 'v19' is possibly undefined
// 140029FC8: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140033744: using guessed type __int64 unknown_libname_574(void);
// 1400345F0: using guessed type __int64 unknown_libname_582(void);
// 140035A68: using guessed type __int64 __fastcall unknown_libname_590(_QWORD, _QWORD);
// 1400379C0: using guessed type __int64 unknown_libname_598(void);
// 1400385B4: using guessed type __int64 unknown_libname_606(void);
// 14003A980: using guessed type __int64 __fastcall unknown_libname_655(_QWORD, _QWORD);
// 14003B1F0: using guessed type __int64 __fastcall __crt_stdio_output::string_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140031F48) ----------------------------------------------------
char __fastcall sub_140031F48(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  __int16 v13; // ax
  __int16 v14; // cx
  bool v15; // r8
  bool v16; // al
  unsigned int v17; // esi
  __int64 v18; // rdx
  int v19; // ecx
  __int64 v20; // rdx
  int v21; // [rsp+30h] [rbp-38h] BYREF
  __int16 v22; // [rsp+34h] [rbp-34h]

  v4 = *(unsigned __int16 *)(a1 + 66);
  v5 = a1;
  if ( v4 > 0x64 )
  {
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x67u )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_599();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140036A9C(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_607();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_591(a1, 0i64);
      goto LABEL_35;
    }
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x44u )
      return 0;
    if ( *(unsigned __int16 *)(a1 + 66) > 0x47u )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_575();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_583();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v21 = 0;
    v12 = 0i64;
    v22 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_47;
    if ( (v11 & 0x40) != 0 )
    {
      v13 = 45;
    }
    else
    {
      if ( (v11 & 1) == 0 )
      {
        if ( (v11 & 2) == 0 )
          goto LABEL_47;
        LOWORD(v21) = 32;
LABEL_46:
        v12 = 1i64;
LABEL_47:
        v14 = *(_WORD *)(v5 + 66);
        v15 = ((v14 - 88) & 0xFFDF) == 0 && (v11 & 0x20) != 0;
        if ( v15 || ((v14 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v21 + v12++) = 48;
          v16 = v14 == 88 || v14 == 65;
          *((_WORD *)&v21 + v12) = v16 ? 88 : 120;
          LODWORD(v12) = v12 + 1;
        }
        v17 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
        if ( (v11 & 0xC) == 0 )
        {
          LOBYTE(v11) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v11,
            v17,
            v5 + 40);
        }
        __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(
          v5 + 1128,
          (unsigned int)&v21,
          v12,
          v5 + 40,
          *(_QWORD *)(v5 + 16));
        v19 = *(_DWORD *)(v5 + 48);
        if ( (v19 & 8) != 0 && (v19 & 4) == 0 )
        {
          LOBYTE(v18) = 48;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v18,
            v17,
            v5 + 40);
        }
        unknown_libname_656(v5, 0i64);
        if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
        {
          LOBYTE(v20) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v20,
            v17,
            v5 + 40);
        }
        return 1;
      }
      v13 = 43;
    }
    LOWORD(v21) = v13;
    goto LABEL_46;
  }
  return 1;
}
// 1400321B2: variable 'v18' is possibly undefined
// 1400321DE: variable 'v20' is possibly undefined
// 140029F38: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400337C4: using guessed type __int64 unknown_libname_575(void);
// 14003480C: using guessed type __int64 unknown_libname_583(void);
// 140035B1C: using guessed type __int64 __fastcall unknown_libname_591(_QWORD, _QWORD);
// 140037A9C: using guessed type __int64 unknown_libname_599(void);
// 140038644: using guessed type __int64 unknown_libname_607(void);
// 14003AA58: using guessed type __int64 __fastcall unknown_libname_656(_QWORD, _QWORD);
// 14003B0E4: using guessed type __int64 __fastcall __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140032214) ----------------------------------------------------
char __fastcall sub_140032214(__int64 a1)
{
  unsigned int v1; // eax
  __int64 v2; // rbx
  char v3; // al
  unsigned int v4; // edx
  char v5; // r8
  int v6; // ecx
  __int64 v8; // rdx
  __int64 v9; // rdi
  __int16 v10; // ax
  __int16 v11; // cx
  bool v12; // r8
  bool v13; // al
  unsigned int v14; // esi
  __int64 v15; // rdx
  int v16; // ecx
  __int64 v17; // rdx
  int v18; // [rsp+30h] [rbp-38h] BYREF
  __int16 v19; // [rsp+34h] [rbp-34h]

  v1 = *(unsigned __int16 *)(a1 + 66);
  v2 = a1;
  if ( v1 > 0x64 )
  {
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x67u )
      goto LABEL_34;
    if ( v1 != 105 )
    {
      switch ( v1 )
      {
        case 'n':
          v3 = sub_140037B78(a1);
          goto LABEL_35;
        case 'o':
          v6 = *(_DWORD *)(a1 + 48);
          if ( (v6 & 0x20) != 0 )
            *(_DWORD *)(v2 + 48) = v6 | 0x80;
          v4 = 8;
          a1 = v2;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v5 = 1;
          v4 = 16;
LABEL_33:
          v3 = sub_140036C3C(a1, v4, v5);
          goto LABEL_35;
        case 's':
LABEL_23:
          v3 = sub_14003870C(a1);
          goto LABEL_35;
      }
      if ( v1 != 117 )
      {
        if ( v1 != 120 )
          return 0;
        v4 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v4 = 10;
LABEL_32:
      v5 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v1 == 100 )
    goto LABEL_30;
  if ( v1 != 65 )
  {
    if ( v1 == 67 )
    {
LABEL_12:
      v3 = sub_140035BC4(a1);
      goto LABEL_35;
    }
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x44u )
      return 0;
    if ( *(unsigned __int16 *)(a1 + 66) > 0x47u )
    {
      if ( v1 != 83 )
      {
        if ( v1 != 88 )
        {
          if ( v1 == 90 )
          {
            v3 = sub_140033844(a1);
            goto LABEL_35;
          }
          if ( v1 != 97 )
          {
            if ( v1 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v3 = sub_140034A50(a1);
LABEL_35:
  if ( !v3 )
    return 0;
  if ( (*(_DWORD *)(v2 + 1148) != 2 || *(_DWORD *)(v2 + 1144) != 1) && !*(_BYTE *)(v2 + 64) )
  {
    v8 = *(unsigned int *)(v2 + 48);
    v18 = 0;
    v9 = 0i64;
    v19 = 0;
    if ( (v8 & 0x10) == 0 )
      goto LABEL_49;
    if ( (v8 & 0x40) != 0 )
    {
      v10 = 45;
    }
    else
    {
      if ( (v8 & 1) == 0 )
      {
        if ( (v8 & 2) == 0 )
          goto LABEL_49;
        LOWORD(v18) = 32;
LABEL_48:
        v9 = 1i64;
LABEL_49:
        v11 = *(_WORD *)(v2 + 66);
        v12 = ((v11 - 88) & 0xFFDF) == 0 && (v8 & 0x20) != 0;
        if ( v12 || ((v11 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v18 + v9++) = 48;
          v13 = v11 == 88 || v11 == 65;
          *((_WORD *)&v18 + v9) = v13 ? 88 : 120;
          LODWORD(v9) = v9 + 1;
        }
        v14 = *(_DWORD *)(v2 + 52) - *(_DWORD *)(v2 + 80) - v9;
        if ( (v8 & 0xC) == 0 )
        {
          LOBYTE(v8) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v2 + 1128,
            v8,
            v14,
            v2 + 40);
        }
        __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(
          v2 + 1128,
          (unsigned int)&v18,
          v9,
          v2 + 40,
          *(_QWORD *)(v2 + 16));
        v16 = *(_DWORD *)(v2 + 48);
        if ( (v16 & 8) != 0 && (v16 & 4) == 0 )
        {
          LOBYTE(v15) = 48;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v2 + 1128,
            v15,
            v14,
            v2 + 40);
        }
        unknown_libname_657(v2, 0i64);
        if ( *(int *)(v2 + 40) >= 0 && (*(_DWORD *)(v2 + 48) & 4) != 0 )
        {
          LOBYTE(v17) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v2 + 1128,
            v17,
            v14,
            v2 + 40);
        }
        return 1;
      }
      v10 = 43;
    }
    LOWORD(v18) = v10;
    goto LABEL_48;
  }
  return 1;
}
// 140032494: variable 'v15' is possibly undefined
// 1400324C0: variable 'v17' is possibly undefined
// 140029F38: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 14003AB44: using guessed type __int64 __fastcall unknown_libname_657(_QWORD, _QWORD);
// 14003B0E4: using guessed type __int64 __fastcall __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (00000001400324F4) ----------------------------------------------------
char __fastcall sub_1400324F4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  __int16 v13; // ax
  __int16 v14; // cx
  bool v15; // r8
  bool v16; // al
  unsigned int v17; // esi
  __int64 v18; // rdx
  int v19; // ecx
  __int64 v20; // rdx
  int v21; // [rsp+30h] [rbp-38h] BYREF
  __int16 v22; // [rsp+34h] [rbp-34h]

  v4 = *(unsigned __int16 *)(a1 + 66);
  v5 = a1;
  if ( v4 > 0x64 )
  {
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x67u )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_600();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140036E40(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_608();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_592(a1, 0i64);
      goto LABEL_35;
    }
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x44u )
      return 0;
    if ( *(unsigned __int16 *)(a1 + 66) > 0x47u )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_576();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_584();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v21 = 0;
    v12 = 0i64;
    v22 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_47;
    if ( (v11 & 0x40) != 0 )
    {
      v13 = 45;
    }
    else
    {
      if ( (v11 & 1) == 0 )
      {
        if ( (v11 & 2) == 0 )
          goto LABEL_47;
        LOWORD(v21) = 32;
LABEL_46:
        v12 = 1i64;
LABEL_47:
        v14 = *(_WORD *)(v5 + 66);
        v15 = ((v14 - 88) & 0xFFDF) == 0 && (v11 & 0x20) != 0;
        if ( v15 || ((v14 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v21 + v12++) = 48;
          v16 = v14 == 88 || v14 == 65;
          *((_WORD *)&v21 + v12) = v16 ? 88 : 120;
          LODWORD(v12) = v12 + 1;
        }
        v17 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
        if ( (v11 & 0xC) == 0 )
        {
          LOBYTE(v11) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v11,
            v17,
            v5 + 40);
        }
        __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(
          v5 + 1128,
          (unsigned int)&v21,
          v12,
          v5 + 40,
          *(_QWORD *)(v5 + 16));
        v19 = *(_DWORD *)(v5 + 48);
        if ( (v19 & 8) != 0 && (v19 & 4) == 0 )
        {
          LOBYTE(v18) = 48;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v18,
            v17,
            v5 + 40);
        }
        unknown_libname_658(v5, 0i64);
        if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
        {
          LOBYTE(v20) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v20,
            v17,
            v5 + 40);
        }
        return 1;
      }
      v13 = 43;
    }
    LOWORD(v21) = v13;
    goto LABEL_46;
  }
  return 1;
}
// 14003275E: variable 'v18' is possibly undefined
// 14003278A: variable 'v20' is possibly undefined
// 140029F38: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::stream_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400338E4: using guessed type __int64 unknown_libname_576(void);
// 140034CC0: using guessed type __int64 unknown_libname_584(void);
// 140035C90: using guessed type __int64 __fastcall unknown_libname_592(_QWORD, _QWORD);
// 140037C7C: using guessed type __int64 unknown_libname_600(void);
// 1400387EC: using guessed type __int64 unknown_libname_608(void);
// 14003AC30: using guessed type __int64 __fastcall unknown_libname_658(_QWORD, _QWORD);
// 14003B0E4: using guessed type __int64 __fastcall __crt_stdio_output::stream_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (00000001400327C0) ----------------------------------------------------
char __fastcall sub_1400327C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  __int16 v13; // ax
  __int16 v14; // cx
  bool v15; // r8
  bool v16; // al
  unsigned int v17; // esi
  __int64 v18; // rdx
  int v19; // ecx
  __int64 v20; // rdx
  int v21; // [rsp+30h] [rbp-38h] BYREF
  __int16 v22; // [rsp+34h] [rbp-34h]

  v4 = *(unsigned __int16 *)(a1 + 66);
  v5 = a1;
  if ( v4 > 0x64 )
  {
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x67u )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_601();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140036FE0(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_609();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_593(a1, 0i64);
      goto LABEL_35;
    }
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x44u )
      return 0;
    if ( *(unsigned __int16 *)(a1 + 66) > 0x47u )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_577();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_585();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v21 = 0;
    v12 = 0i64;
    v22 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_47;
    if ( (v11 & 0x40) != 0 )
    {
      v13 = 45;
    }
    else
    {
      if ( (v11 & 1) == 0 )
      {
        if ( (v11 & 2) == 0 )
          goto LABEL_47;
        LOWORD(v21) = 32;
LABEL_46:
        v12 = 1i64;
LABEL_47:
        v14 = *(_WORD *)(v5 + 66);
        v15 = ((v14 - 88) & 0xFFDF) == 0 && (v11 & 0x20) != 0;
        if ( v15 || ((v14 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v21 + v12++) = 48;
          v16 = v14 == 88 || v14 == 65;
          *((_WORD *)&v21 + v12) = v16 ? 88 : 120;
          LODWORD(v12) = v12 + 1;
        }
        v17 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
        if ( (v11 & 0xC) == 0 )
        {
          LOBYTE(v11) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v11,
            v17,
            v5 + 40);
        }
        __crt_stdio_output::string_output_adapter<wchar_t>::write_string(
          v5 + 1128,
          (unsigned int)&v21,
          v12,
          v5 + 40,
          *(_QWORD *)(v5 + 16));
        v19 = *(_DWORD *)(v5 + 48);
        if ( (v19 & 8) != 0 && (v19 & 4) == 0 )
        {
          LOBYTE(v18) = 48;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v18,
            v17,
            v5 + 40);
        }
        unknown_libname_659(v5, 0i64);
        if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
        {
          LOBYTE(v20) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v20,
            v17,
            v5 + 40);
        }
        return 1;
      }
      v13 = 43;
    }
    LOWORD(v21) = v13;
    goto LABEL_46;
  }
  return 1;
}
// 140032A2A: variable 'v18' is possibly undefined
// 140032A56: variable 'v20' is possibly undefined
// 14002A024: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140033964: using guessed type __int64 unknown_libname_577(void);
// 140034F04: using guessed type __int64 unknown_libname_585(void);
// 140035D38: using guessed type __int64 __fastcall unknown_libname_593(_QWORD, _QWORD);
// 140037D58: using guessed type __int64 unknown_libname_601(void);
// 1400388B4: using guessed type __int64 unknown_libname_609(void);
// 14003AD1C: using guessed type __int64 __fastcall unknown_libname_659(_QWORD, _QWORD);
// 14003B2AC: using guessed type __int64 __fastcall __crt_stdio_output::string_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140032A8C) ----------------------------------------------------
char __fastcall sub_140032A8C(__int64 a1)
{
  unsigned int v1; // eax
  __int64 v2; // rbx
  char v3; // al
  unsigned int v4; // edx
  char v5; // r8
  int v6; // ecx
  __int64 v8; // rdx
  __int64 v9; // rdi
  __int16 v10; // ax
  __int16 v11; // cx
  bool v12; // r8
  bool v13; // al
  unsigned int v14; // esi
  __int64 v15; // rdx
  int v16; // ecx
  __int64 v17; // rdx
  int v18; // [rsp+30h] [rbp-38h] BYREF
  __int16 v19; // [rsp+34h] [rbp-34h]

  v1 = *(unsigned __int16 *)(a1 + 66);
  v2 = a1;
  if ( v1 > 0x64 )
  {
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x67u )
      goto LABEL_34;
    if ( v1 != 105 )
    {
      switch ( v1 )
      {
        case 'n':
          v3 = sub_140037E34(a1);
          goto LABEL_35;
        case 'o':
          v6 = *(_DWORD *)(a1 + 48);
          if ( (v6 & 0x20) != 0 )
            *(_DWORD *)(v2 + 48) = v6 | 0x80;
          v4 = 8;
          a1 = v2;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v5 = 1;
          v4 = 16;
LABEL_33:
          v3 = sub_140037180(a1, v4, v5);
          goto LABEL_35;
        case 's':
LABEL_23:
          v3 = sub_14003897C(a1);
          goto LABEL_35;
      }
      if ( v1 != 117 )
      {
        if ( v1 != 120 )
          return 0;
        v4 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v4 = 10;
LABEL_32:
      v5 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v1 == 100 )
    goto LABEL_30;
  if ( v1 != 65 )
  {
    if ( v1 == 67 )
    {
LABEL_12:
      v3 = sub_140035DE0(a1);
      goto LABEL_35;
    }
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x44u )
      return 0;
    if ( *(unsigned __int16 *)(a1 + 66) > 0x47u )
    {
      if ( v1 != 83 )
      {
        if ( v1 != 88 )
        {
          if ( v1 == 90 )
          {
            v3 = sub_1400339E4(a1);
            goto LABEL_35;
          }
          if ( v1 != 97 )
          {
            if ( v1 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v3 = sub_140035148(a1);
LABEL_35:
  if ( !v3 )
    return 0;
  if ( (*(_DWORD *)(v2 + 1148) != 2 || *(_DWORD *)(v2 + 1144) != 1) && !*(_BYTE *)(v2 + 64) )
  {
    v8 = *(unsigned int *)(v2 + 48);
    v18 = 0;
    v9 = 0i64;
    v19 = 0;
    if ( (v8 & 0x10) == 0 )
      goto LABEL_49;
    if ( (v8 & 0x40) != 0 )
    {
      v10 = 45;
    }
    else
    {
      if ( (v8 & 1) == 0 )
      {
        if ( (v8 & 2) == 0 )
          goto LABEL_49;
        LOWORD(v18) = 32;
LABEL_48:
        v9 = 1i64;
LABEL_49:
        v11 = *(_WORD *)(v2 + 66);
        v12 = ((v11 - 88) & 0xFFDF) == 0 && (v8 & 0x20) != 0;
        if ( v12 || ((v11 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v18 + v9++) = 48;
          v13 = v11 == 88 || v11 == 65;
          *((_WORD *)&v18 + v9) = v13 ? 88 : 120;
          LODWORD(v9) = v9 + 1;
        }
        v14 = *(_DWORD *)(v2 + 52) - *(_DWORD *)(v2 + 80) - v9;
        if ( (v8 & 0xC) == 0 )
        {
          LOBYTE(v8) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v2 + 1128,
            v8,
            v14,
            v2 + 40);
        }
        __crt_stdio_output::string_output_adapter<wchar_t>::write_string(
          v2 + 1128,
          (unsigned int)&v18,
          v9,
          v2 + 40,
          *(_QWORD *)(v2 + 16));
        v16 = *(_DWORD *)(v2 + 48);
        if ( (v16 & 8) != 0 && (v16 & 4) == 0 )
        {
          LOBYTE(v15) = 48;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v2 + 1128,
            v15,
            v14,
            v2 + 40);
        }
        unknown_libname_660(v2, 0i64);
        if ( *(int *)(v2 + 40) >= 0 && (*(_DWORD *)(v2 + 48) & 4) != 0 )
        {
          LOBYTE(v17) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v2 + 1128,
            v17,
            v14,
            v2 + 40);
        }
        return 1;
      }
      v10 = 43;
    }
    LOWORD(v18) = v10;
    goto LABEL_48;
  }
  return 1;
}
// 140032D0C: variable 'v15' is possibly undefined
// 140032D38: variable 'v17' is possibly undefined
// 14002A024: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 14003AE0C: using guessed type __int64 __fastcall unknown_libname_660(_QWORD, _QWORD);
// 14003B2AC: using guessed type __int64 __fastcall __crt_stdio_output::string_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140032D6C) ----------------------------------------------------
char __fastcall sub_140032D6C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // eax
  __int64 v5; // rbx
  char v6; // al
  unsigned int v7; // edx
  char v8; // r8
  int v9; // ecx
  __int64 v11; // rdx
  __int64 v12; // rdi
  __int16 v13; // ax
  __int16 v14; // cx
  bool v15; // r8
  bool v16; // al
  unsigned int v17; // esi
  __int64 v18; // rdx
  int v19; // ecx
  __int64 v20; // rdx
  int v21; // [rsp+30h] [rbp-38h] BYREF
  __int16 v22; // [rsp+34h] [rbp-34h]

  v4 = *(unsigned __int16 *)(a1 + 66);
  v5 = a1;
  if ( v4 > 0x64 )
  {
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x67u )
      goto LABEL_34;
    if ( v4 != 105 )
    {
      switch ( v4 )
      {
        case 'n':
          v6 = unknown_libname_602();
          goto LABEL_35;
        case 'o':
          v9 = *(_DWORD *)(a1 + 48);
          if ( (v9 & 0x20) != 0 )
            *(_DWORD *)(v5 + 48) = v9 | 0x80;
          v7 = 8;
          a1 = v5;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v8 = 1;
          v7 = 16;
LABEL_33:
          v6 = sub_140037384(a1, v7, v8, a4);
          goto LABEL_35;
        case 's':
LABEL_23:
          v6 = unknown_libname_610();
          goto LABEL_35;
      }
      if ( v4 != 117 )
      {
        if ( v4 != 120 )
          return 0;
        v7 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v7 = 10;
LABEL_32:
      v8 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v4 == 100 )
    goto LABEL_30;
  if ( v4 != 65 )
  {
    if ( v4 == 67 )
    {
LABEL_12:
      v6 = unknown_libname_594(a1, 0i64);
      goto LABEL_35;
    }
    if ( *(unsigned __int16 *)(a1 + 66) <= 0x44u )
      return 0;
    if ( *(unsigned __int16 *)(a1 + 66) > 0x47u )
    {
      if ( v4 != 83 )
      {
        if ( v4 != 88 )
        {
          if ( v4 == 90 )
          {
            v6 = unknown_libname_578();
            goto LABEL_35;
          }
          if ( v4 != 97 )
          {
            if ( v4 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v6 = unknown_libname_586();
LABEL_35:
  if ( !v6 )
    return 0;
  if ( !*(_BYTE *)(v5 + 64) )
  {
    v11 = *(unsigned int *)(v5 + 48);
    v21 = 0;
    v12 = 0i64;
    v22 = 0;
    if ( (v11 & 0x10) == 0 )
      goto LABEL_47;
    if ( (v11 & 0x40) != 0 )
    {
      v13 = 45;
    }
    else
    {
      if ( (v11 & 1) == 0 )
      {
        if ( (v11 & 2) == 0 )
          goto LABEL_47;
        LOWORD(v21) = 32;
LABEL_46:
        v12 = 1i64;
LABEL_47:
        v14 = *(_WORD *)(v5 + 66);
        v15 = ((v14 - 88) & 0xFFDF) == 0 && (v11 & 0x20) != 0;
        if ( v15 || ((v14 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v21 + v12++) = 48;
          v16 = v14 == 88 || v14 == 65;
          *((_WORD *)&v21 + v12) = v16 ? 88 : 120;
          LODWORD(v12) = v12 + 1;
        }
        v17 = *(_DWORD *)(v5 + 52) - *(_DWORD *)(v5 + 80) - v12;
        if ( (v11 & 0xC) == 0 )
        {
          LOBYTE(v11) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v11,
            v17,
            v5 + 40);
        }
        __crt_stdio_output::string_output_adapter<wchar_t>::write_string(
          v5 + 1128,
          (unsigned int)&v21,
          v12,
          v5 + 40,
          *(_QWORD *)(v5 + 16));
        v19 = *(_DWORD *)(v5 + 48);
        if ( (v19 & 8) != 0 && (v19 & 4) == 0 )
        {
          LOBYTE(v18) = 48;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v18,
            v17,
            v5 + 40);
        }
        unknown_libname_661(v5, 0i64);
        if ( *(int *)(v5 + 40) >= 0 && (*(_DWORD *)(v5 + 48) & 4) != 0 )
        {
          LOBYTE(v20) = 32;
          __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
            v5 + 1128,
            v20,
            v17,
            v5 + 40);
        }
        return 1;
      }
      v13 = 43;
    }
    LOWORD(v21) = v13;
    goto LABEL_46;
  }
  return 1;
}
// 140032FD6: variable 'v18' is possibly undefined
// 140033002: variable 'v20' is possibly undefined
// 14002A024: using guessed type __int64 __fastcall __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140033A84: using guessed type __int64 unknown_libname_578(void);
// 1400353B8: using guessed type __int64 unknown_libname_586(void);
// 140035EAC: using guessed type __int64 __fastcall unknown_libname_594(_QWORD, _QWORD);
// 140037F38: using guessed type __int64 unknown_libname_602(void);
// 140038A5C: using guessed type __int64 unknown_libname_610(void);
// 14003AEFC: using guessed type __int64 __fastcall unknown_libname_661(_QWORD, _QWORD);
// 14003B2AC: using guessed type __int64 __fastcall __crt_stdio_output::string_output_adapter<wchar_t>::write_string(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140033068) ----------------------------------------------------
char __fastcall sub_140033068(__int64 a1)
{
  char result; // al
  int v3; // eax

  if ( *(_BYTE *)(a1 + 65) != 42 )
    return unknown_libname_508(a1, a1 + 52);
  result = sub_140038E84(a1);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v3 = *(_DWORD *)(a1 + 52);
      if ( v3 < 0 )
      {
        *(_DWORD *)(a1 + 48) |= 4u;
        *(_DWORD *)(a1 + 52) = -v3;
      }
    }
    return 1;
  }
  return result;
}
// 14002C514: using guessed type __int64 __fastcall unknown_libname_508(_QWORD, _QWORD);

//----- (00000001400330B8) ----------------------------------------------------
char __fastcall sub_1400330B8(__int64 a1)
{
  int v2; // edx

  if ( *(_BYTE *)(a1 + 65) != 42 )
    return unknown_libname_509(a1, a1 + 52);
  *(_QWORD *)(a1 + 32) += 8i64;
  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  *(_DWORD *)(a1 + 52) = v2;
  if ( v2 < 0 )
  {
    *(_DWORD *)(a1 + 48) |= 4u;
    *(_DWORD *)(a1 + 52) = -v2;
  }
  return 1;
}
// 14002C598: using guessed type __int64 __fastcall unknown_libname_509(_QWORD, _QWORD);

//----- (0000000140033118) ----------------------------------------------------
char __fastcall sub_140033118(__int64 a1)
{
  char result; // al
  int v3; // eax

  if ( *(_BYTE *)(a1 + 65) != 42 )
    return unknown_libname_511(a1, a1 + 52);
  result = sub_140038F98(a1);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v3 = *(_DWORD *)(a1 + 52);
      if ( v3 < 0 )
      {
        *(_DWORD *)(a1 + 48) |= 4u;
        *(_DWORD *)(a1 + 52) = -v3;
      }
    }
    return 1;
  }
  return result;
}
// 14002C6A0: using guessed type __int64 __fastcall unknown_libname_511(_QWORD, _QWORD);

//----- (0000000140033168) ----------------------------------------------------
char __fastcall sub_140033168(__int64 a1)
{
  int v2; // edx

  if ( *(_BYTE *)(a1 + 65) != 42 )
    return unknown_libname_512(a1, a1 + 52);
  *(_QWORD *)(a1 + 32) += 8i64;
  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  *(_DWORD *)(a1 + 52) = v2;
  if ( v2 < 0 )
  {
    *(_DWORD *)(a1 + 48) |= 4u;
    *(_DWORD *)(a1 + 52) = -v2;
  }
  return 1;
}
// 14002C724: using guessed type __int64 __fastcall unknown_libname_512(_QWORD, _QWORD);

//----- (00000001400331C8) ----------------------------------------------------
char __fastcall sub_1400331C8(__int64 a1)
{
  char result; // al
  int v3; // eax

  if ( *(_WORD *)(a1 + 66) != 42 )
    return unknown_libname_514(a1, a1 + 52);
  result = sub_1400390AC(a1);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v3 = *(_DWORD *)(a1 + 52);
      if ( v3 < 0 )
      {
        *(_DWORD *)(a1 + 48) |= 4u;
        *(_DWORD *)(a1 + 52) = -v3;
      }
    }
    return 1;
  }
  return result;
}
// 14002C828: using guessed type __int64 __fastcall unknown_libname_514(_QWORD, _QWORD);

//----- (000000014003327C) ----------------------------------------------------
char __fastcall sub_14003327C(__int64 a1)
{
  char result; // al
  int v3; // eax

  if ( *(_WORD *)(a1 + 66) != 42 )
    return unknown_libname_517(a1, a1 + 52);
  result = sub_1400391C4(a1);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v3 = *(_DWORD *)(a1 + 52);
      if ( v3 < 0 )
      {
        *(_DWORD *)(a1 + 48) |= 4u;
        *(_DWORD *)(a1 + 52) = -v3;
      }
    }
    return 1;
  }
  return result;
}
// 14002C9A8: using guessed type __int64 __fastcall unknown_libname_517(_QWORD, _QWORD);

//----- (0000000140033300) ----------------------------------------------------
__int64 sub_140033300()
{
  return 9i64;
}

//----- (0000000140033308) ----------------------------------------------------
__int64 sub_140033308()
{
  return 9i64;
}

//----- (0000000140033310) ----------------------------------------------------
__int64 sub_140033310()
{
  return 9i64;
}

//----- (0000000140033318) ----------------------------------------------------
__int64 sub_140033318()
{
  return 9i64;
}

//----- (0000000140033320) ----------------------------------------------------
__int64 sub_140033320()
{
  return 8i64;
}

//----- (0000000140033328) ----------------------------------------------------
__int64 sub_140033328()
{
  return 8i64;
}

//----- (0000000140033330) ----------------------------------------------------
__int64 sub_140033330()
{
  return 8i64;
}

//----- (0000000140033338) ----------------------------------------------------
__int64 sub_140033338()
{
  return 8i64;
}

//----- (0000000140033340) ----------------------------------------------------
void *sub_140033340()
{
  return &unk_14007E800;
}

//----- (0000000140033348) ----------------------------------------------------
void *sub_140033348()
{
  return &unk_14007E800;
}

//----- (0000000140033350) ----------------------------------------------------
void *sub_140033350()
{
  return &unk_14007E800;
}

//----- (0000000140033358) ----------------------------------------------------
void *sub_140033358()
{
  return &unk_14007E800;
}

//----- (0000000140033360) ----------------------------------------------------
void *sub_140033360()
{
  return &unk_14007E7A0;
}

//----- (0000000140033368) ----------------------------------------------------
void *sub_140033368()
{
  return &unk_14007E7A0;
}

//----- (0000000140033370) ----------------------------------------------------
void *sub_140033370()
{
  return &unk_14007E7A0;
}

//----- (0000000140033378) ----------------------------------------------------
void *sub_140033378()
{
  return &unk_14007E7A0;
}

//----- (00000001400333CC) ----------------------------------------------------
char __fastcall sub_1400333CC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_140036014(a1, 0x10u, 1, a4);
}

//----- (00000001400333DC) ----------------------------------------------------
char __fastcall sub_1400333DC(__int64 a1)
{
  return sub_1400361B4(a1, 0x10u, 1);
}

//----- (00000001400333EC) ----------------------------------------------------
char __fastcall sub_1400333EC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_1400363B8(a1, 0x10u, 1, a4);
}

//----- (00000001400333FC) ----------------------------------------------------
char __fastcall sub_1400333FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_140036558(a1, 0x10u, 1, a4);
}

//----- (000000014003340C) ----------------------------------------------------
char __fastcall sub_14003340C(__int64 a1)
{
  return sub_1400366F8(a1, 0x10u, 1);
}

//----- (000000014003341C) ----------------------------------------------------
char __fastcall sub_14003341C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_1400368FC(a1, 0x10u, 1, a4);
}

//----- (000000014003342C) ----------------------------------------------------
char __fastcall sub_14003342C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_140036A9C(a1, 0x10u, 1, a4);
}

//----- (000000014003343C) ----------------------------------------------------
char __fastcall sub_14003343C(__int64 a1)
{
  return sub_140036C3C(a1, 0x10u, 1);
}

//----- (000000014003344C) ----------------------------------------------------
char __fastcall sub_14003344C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_140036E40(a1, 0x10u, 1, a4);
}

//----- (000000014003345C) ----------------------------------------------------
char __fastcall sub_14003345C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_140036FE0(a1, 0x10u, 1, a4);
}

//----- (000000014003346C) ----------------------------------------------------
char __fastcall sub_14003346C(__int64 a1)
{
  return sub_140037180(a1, 0x10u, 1);
}

//----- (000000014003347C) ----------------------------------------------------
char __fastcall sub_14003347C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_140037384(a1, 0x10u, 1, a4);
}

//----- (000000014003350C) ----------------------------------------------------
char __fastcall sub_14003350C(__int64 a1)
{
  char result; // al
  __int64 v3; // rdx
  unsigned __int16 *v4; // rdi
  __int64 v5; // rsi
  bool v6; // zf
  unsigned int v7; // eax
  unsigned __int16 *v8; // [rsp+38h] [rbp+10h] BYREF

  v8 = 0i64;
  result = unknown_libname_309(a1, &v8);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) == 1 && *(_DWORD *)(a1 + 1148) != 1 )
      return 1;
    v4 = v8;
    if ( v8 && (v5 = *((_QWORD *)v8 + 1)) != 0 )
    {
      LOBYTE(v3) = *(_BYTE *)(a1 + 65);
      v6 = (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<char>(
                              *(_QWORD *)a1,
                              v3,
                              *(unsigned int *)(a1 + 60)) == 0;
      *(_QWORD *)(a1 + 72) = v5;
      v7 = *v4;
      if ( !v6 )
      {
        *(_DWORD *)(a1 + 80) = v7 >> 1;
        *(_BYTE *)(a1 + 84) = 1;
        return 1;
      }
      *(_DWORD *)(a1 + 80) = v7;
    }
    else
    {
      *(_DWORD *)(a1 + 80) = 6;
      *(_QWORD *)(a1 + 72) = "(null)";
    }
    *(_BYTE *)(a1 + 84) = 0;
    return 1;
  }
  return result;
}
// 140033560: variable 'v3' is possibly undefined
// 140027724: using guessed type __int64 __fastcall unknown_libname_309(_QWORD, _QWORD);
// 140028DA8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<char>(_QWORD, _QWORD, _QWORD);

//----- (00000001400336A8) ----------------------------------------------------
char __fastcall sub_1400336A8(__int64 a1)
{
  char result; // al
  __int64 v3; // rdx
  unsigned __int16 *v4; // rdi
  __int64 v5; // rsi
  bool v6; // zf
  unsigned int v7; // eax
  unsigned __int16 *v8; // [rsp+38h] [rbp+10h] BYREF

  v8 = 0i64;
  result = unknown_libname_313(a1, &v8);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) == 1 && *(_DWORD *)(a1 + 1148) != 1 )
      return 1;
    v4 = v8;
    if ( v8 && (v5 = *((_QWORD *)v8 + 1)) != 0 )
    {
      LOBYTE(v3) = *(_BYTE *)(a1 + 65);
      v6 = (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<char>(
                              *(_QWORD *)a1,
                              v3,
                              *(unsigned int *)(a1 + 60)) == 0;
      *(_QWORD *)(a1 + 72) = v5;
      v7 = *v4;
      if ( !v6 )
      {
        *(_DWORD *)(a1 + 80) = v7 >> 1;
        *(_BYTE *)(a1 + 84) = 1;
        return 1;
      }
      *(_DWORD *)(a1 + 80) = v7;
    }
    else
    {
      *(_DWORD *)(a1 + 80) = 6;
      *(_QWORD *)(a1 + 72) = "(null)";
    }
    *(_BYTE *)(a1 + 84) = 0;
    return 1;
  }
  return result;
}
// 1400336FC: variable 'v3' is possibly undefined
// 140027824: using guessed type __int64 __fastcall unknown_libname_313(_QWORD, _QWORD);
// 140028DA8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<char>(_QWORD, _QWORD, _QWORD);

//----- (0000000140033844) ----------------------------------------------------
char __fastcall sub_140033844(__int64 a1)
{
  char result; // al
  unsigned __int16 *v3; // rdi
  __int64 v4; // rsi
  bool v5; // zf
  unsigned int v6; // eax
  unsigned __int16 *v7; // [rsp+38h] [rbp+10h] BYREF

  v7 = 0i64;
  result = unknown_libname_317(a1, &v7);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) == 1 && *(_DWORD *)(a1 + 1148) != 1 )
      return 1;
    v3 = v7;
    if ( v7 && (v4 = *((_QWORD *)v7 + 1)) != 0 )
    {
      v5 = (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<wchar_t>(
                              *(_QWORD *)a1,
                              *(unsigned __int16 *)(a1 + 66),
                              *(unsigned int *)(a1 + 60)) == 0;
      *(_QWORD *)(a1 + 72) = v4;
      v6 = *v3;
      if ( !v5 )
      {
        *(_DWORD *)(a1 + 80) = v6 >> 1;
        *(_BYTE *)(a1 + 84) = 1;
        return 1;
      }
      *(_DWORD *)(a1 + 80) = v6;
    }
    else
    {
      *(_DWORD *)(a1 + 80) = 6;
      *(_QWORD *)(a1 + 72) = "(null)";
    }
    *(_BYTE *)(a1 + 84) = 0;
    return 1;
  }
  return result;
}
// 140027924: using guessed type __int64 __fastcall unknown_libname_317(_QWORD, _QWORD);
// 140028DD8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<wchar_t>(_QWORD, _QWORD, _QWORD);

//----- (00000001400339E4) ----------------------------------------------------
char __fastcall sub_1400339E4(__int64 a1)
{
  char result; // al
  unsigned __int16 *v3; // rdi
  __int64 v4; // rsi
  bool v5; // zf
  unsigned int v6; // eax
  unsigned __int16 *v7; // [rsp+38h] [rbp+10h] BYREF

  v7 = 0i64;
  result = unknown_libname_321(a1, &v7);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) == 1 && *(_DWORD *)(a1 + 1148) != 1 )
      return 1;
    v3 = v7;
    if ( v7 && (v4 = *((_QWORD *)v7 + 1)) != 0 )
    {
      v5 = (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<wchar_t>(
                              *(_QWORD *)a1,
                              *(unsigned __int16 *)(a1 + 66),
                              *(unsigned int *)(a1 + 60)) == 0;
      *(_QWORD *)(a1 + 72) = v4;
      v6 = *v3;
      if ( !v5 )
      {
        *(_DWORD *)(a1 + 80) = v6 >> 1;
        *(_BYTE *)(a1 + 84) = 1;
        return 1;
      }
      *(_DWORD *)(a1 + 80) = v6;
    }
    else
    {
      *(_DWORD *)(a1 + 80) = 6;
      *(_QWORD *)(a1 + 72) = "(null)";
    }
    *(_BYTE *)(a1 + 84) = 0;
    return 1;
  }
  return result;
}
// 140027A24: using guessed type __int64 __fastcall unknown_libname_321(_QWORD, _QWORD);
// 140028DD8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<wchar_t>(_QWORD, _QWORD, _QWORD);

//----- (0000000140033D20) ----------------------------------------------------
char __fastcall sub_140033D20(__int64 a1)
{
  int v3; // eax
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // rcx
  char *v9; // r9
  char *v10; // rdx
  struct __crt_locale_pointers *v11; // r8
  char *v12; // rdx
  char v13; // r8
  char v14; // al
  char *v15; // rdx
  char *v16; // rcx
  char v17; // al
  _BYTE *v18; // rax
  _BYTE *v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  double v22; // [rsp+60h] [rbp+8h] BYREF

  *(_DWORD *)(a1 + 48) |= 0x10u;
  if ( !sub_14003A0AC(a1) )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
  {
    v3 = *(_DWORD *)(a1 + 56);
    if ( v3 >= 0 )
    {
      if ( !v3 && ((*(_BYTE *)(a1 + 65) - 71) & 0xDF) == 0 )
        *(_DWORD *)(a1 + 56) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 56) = ((*(_BYTE *)(a1 + 65) - 65) & 0xDF) != 0 ? 6 : 13;
    }
    v4 = 512i64;
    if ( !(unsigned __int8)__crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(
                             a1 + 88,
                             *(_DWORD *)(a1 + 56) + 349) )
    {
      if ( *(_QWORD *)(a1 + 1120) )
        v5 = *(_QWORD *)(a1 + 1112) >> 1;
      else
        LODWORD(v5) = 512;
      *(_DWORD *)(a1 + 56) = v5 - 349;
    }
    v6 = *(_QWORD *)(a1 + 1120);
    if ( !v6 )
      v6 = a1 + 88;
    *(_QWORD *)(a1 + 72) = v6;
    v22 = 0.0;
    if ( !sub_140027E70(a1, &v22) )
      return 0;
    if ( *(_QWORD *)(a1 + 1120) )
      v7 = *(_QWORD *)(a1 + 1112) >> 1;
    else
      v7 = 512i64;
    v8 = *(_QWORD *)(a1 + 1120);
    if ( v8 )
      v9 = (char *)(v8 + (*(_QWORD *)(a1 + 1112) >> 1));
    else
      v9 = (char *)(a1 + 600);
    if ( v8 )
      v4 = *(_QWORD *)(a1 + 1112) >> 1;
    v10 = *(char **)(a1 + 1120);
    if ( !v8 )
      v10 = (char *)(a1 + 88);
    _acrt_fp_format(
      &v22,
      v10,
      v4,
      v9,
      v7,
      *(char *)(a1 + 65),
      *(_DWORD *)(a1 + 56),
      *(_QWORD *)a1,
      *(struct __crt_locale_pointers **)(a1 + 8));
    if ( (*(_DWORD *)(a1 + 48) & 0x20) != 0 && !*(_DWORD *)(a1 + 56) )
      __crt_stdio_output::force_decimal_point(*(__crt_stdio_output **)(a1 + 72), *(char **)(a1 + 8), v11);
    if ( ((*(_BYTE *)(a1 + 65) - 71) & 0xDF) == 0 && (*(_DWORD *)(a1 + 48) & 0x20) == 0 )
    {
      v12 = *(char **)(a1 + 72);
      v13 = ***(_BYTE ***)(**(_QWORD **)(a1 + 8) + 248i64);
      while ( *v12 && *v12 != v13 )
        ++v12;
      v14 = *v12;
      v15 = v12 + 1;
      if ( v14 )
      {
        while ( *v15 && ((*v15 - 69) & 0xDF) != 0 )
          ++v15;
        v16 = v15;
        do
          --v15;
        while ( *v15 == 48 );
        if ( *v15 == v13 )
          --v15;
        do
        {
          v17 = *v16;
          ++v15;
          ++v16;
          *v15 = v17;
        }
        while ( v17 );
      }
    }
    v18 = *(_BYTE **)(a1 + 72);
    if ( *v18 == 45 )
    {
      *(_DWORD *)(a1 + 48) |= 0x40u;
      *(_QWORD *)(a1 + 72) = ++v18;
    }
    v19 = *(_BYTE **)(a1 + 72);
    LOBYTE(v18) = *v19 - 73;
    if ( (unsigned __int8)v18 <= 0x25u )
    {
      v20 = 0x2100000021i64;
      if ( _bittest64(&v20, (unsigned __int64)v18) )
        *(_BYTE *)(a1 + 65) = 115;
    }
    v21 = -1i64;
    do
      ++v21;
    while ( v19[v21] );
    *(_DWORD *)(a1 + 80) = v21;
  }
  return 1;
}
// 140033E98: variable 'v11' is possibly undefined
// 140025D14: using guessed type __int64 __fastcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_QWORD, _QWORD);

//----- (00000001400343A4) ----------------------------------------------------
char __fastcall sub_1400343A4(__int64 a1)
{
  int v3; // eax
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // rcx
  char *v9; // r9
  char *v10; // rdx
  struct __crt_locale_pointers *v11; // r8
  char *v12; // rdx
  char v13; // r8
  char v14; // al
  char *v15; // rdx
  char *v16; // rcx
  char v17; // al
  _BYTE *v18; // rax
  _BYTE *v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  double v22; // [rsp+60h] [rbp+8h] BYREF

  *(_DWORD *)(a1 + 48) |= 0x10u;
  if ( !sub_14003A148(a1) )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
  {
    v3 = *(_DWORD *)(a1 + 56);
    if ( v3 >= 0 )
    {
      if ( !v3 && ((*(_BYTE *)(a1 + 65) - 71) & 0xDF) == 0 )
        *(_DWORD *)(a1 + 56) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 56) = ((*(_BYTE *)(a1 + 65) - 65) & 0xDF) != 0 ? 6 : 13;
    }
    v4 = 512i64;
    if ( !(unsigned __int8)__crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(
                             a1 + 88,
                             *(_DWORD *)(a1 + 56) + 349) )
    {
      if ( *(_QWORD *)(a1 + 1120) )
        v5 = *(_QWORD *)(a1 + 1112) >> 1;
      else
        LODWORD(v5) = 512;
      *(_DWORD *)(a1 + 56) = v5 - 349;
    }
    v6 = *(_QWORD *)(a1 + 1120);
    if ( !v6 )
      v6 = a1 + 88;
    *(_QWORD *)(a1 + 72) = v6;
    v22 = 0.0;
    if ( !sub_140027F38(a1, &v22) )
      return 0;
    if ( *(_QWORD *)(a1 + 1120) )
      v7 = *(_QWORD *)(a1 + 1112) >> 1;
    else
      v7 = 512i64;
    v8 = *(_QWORD *)(a1 + 1120);
    if ( v8 )
      v9 = (char *)(v8 + (*(_QWORD *)(a1 + 1112) >> 1));
    else
      v9 = (char *)(a1 + 600);
    if ( v8 )
      v4 = *(_QWORD *)(a1 + 1112) >> 1;
    v10 = *(char **)(a1 + 1120);
    if ( !v8 )
      v10 = (char *)(a1 + 88);
    _acrt_fp_format(
      &v22,
      v10,
      v4,
      v9,
      v7,
      *(char *)(a1 + 65),
      *(_DWORD *)(a1 + 56),
      *(_QWORD *)a1,
      *(struct __crt_locale_pointers **)(a1 + 8));
    if ( (*(_DWORD *)(a1 + 48) & 0x20) != 0 && !*(_DWORD *)(a1 + 56) )
      __crt_stdio_output::force_decimal_point(*(__crt_stdio_output **)(a1 + 72), *(char **)(a1 + 8), v11);
    if ( ((*(_BYTE *)(a1 + 65) - 71) & 0xDF) == 0 && (*(_DWORD *)(a1 + 48) & 0x20) == 0 )
    {
      v12 = *(char **)(a1 + 72);
      v13 = ***(_BYTE ***)(**(_QWORD **)(a1 + 8) + 248i64);
      while ( *v12 && *v12 != v13 )
        ++v12;
      v14 = *v12;
      v15 = v12 + 1;
      if ( v14 )
      {
        while ( *v15 && ((*v15 - 69) & 0xDF) != 0 )
          ++v15;
        v16 = v15;
        do
          --v15;
        while ( *v15 == 48 );
        if ( *v15 == v13 )
          --v15;
        do
        {
          v17 = *v16;
          ++v15;
          ++v16;
          *v15 = v17;
        }
        while ( v17 );
      }
    }
    v18 = *(_BYTE **)(a1 + 72);
    if ( *v18 == 45 )
    {
      *(_DWORD *)(a1 + 48) |= 0x40u;
      *(_QWORD *)(a1 + 72) = ++v18;
    }
    v19 = *(_BYTE **)(a1 + 72);
    LOBYTE(v18) = *v19 - 73;
    if ( (unsigned __int8)v18 <= 0x25u )
    {
      v20 = 0x2100000021i64;
      if ( _bittest64(&v20, (unsigned __int64)v18) )
        *(_BYTE *)(a1 + 65) = 115;
    }
    v21 = -1i64;
    do
      ++v21;
    while ( v19[v21] );
    *(_DWORD *)(a1 + 80) = v21;
  }
  return 1;
}
// 14003451C: variable 'v11' is possibly undefined
// 140025D14: using guessed type __int64 __fastcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_QWORD, _QWORD);

//----- (0000000140034A50) ----------------------------------------------------
char __fastcall sub_140034A50(__int64 a1)
{
  int v3; // eax
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // rcx
  char *v9; // r9
  char *v10; // rdx
  struct __crt_locale_pointers *v11; // r8
  char *v12; // rdx
  char v13; // r8
  char v14; // al
  char *v15; // rdx
  char *v16; // rcx
  char v17; // al
  _BYTE *v18; // rax
  _BYTE *v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  double v22; // [rsp+60h] [rbp+8h] BYREF

  *(_DWORD *)(a1 + 48) |= 0x10u;
  if ( !sub_14003A1E4(a1) )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
  {
    v3 = *(_DWORD *)(a1 + 56);
    if ( v3 >= 0 )
    {
      if ( !v3 && ((*(_WORD *)(a1 + 66) - 71) & 0xFFDF) == 0 )
        *(_DWORD *)(a1 + 56) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 56) = ((*(_WORD *)(a1 + 66) - 65) & 0xFFDF) != 0 ? 6 : 13;
    }
    v4 = 512i64;
    if ( !(unsigned __int8)__crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(
                             a1 + 88,
                             *(_DWORD *)(a1 + 56) + 349) )
    {
      if ( *(_QWORD *)(a1 + 1120) )
        v5 = *(_QWORD *)(a1 + 1112) >> 1;
      else
        LODWORD(v5) = 512;
      *(_DWORD *)(a1 + 56) = v5 - 349;
    }
    v6 = *(_QWORD *)(a1 + 1120);
    if ( !v6 )
      v6 = a1 + 88;
    *(_QWORD *)(a1 + 72) = v6;
    v22 = 0.0;
    if ( !sub_140028000(a1, &v22) )
      return 0;
    if ( *(_QWORD *)(a1 + 1120) )
      v7 = *(_QWORD *)(a1 + 1112) >> 1;
    else
      v7 = 512i64;
    v8 = *(_QWORD *)(a1 + 1120);
    if ( v8 )
      v9 = (char *)(v8 + (*(_QWORD *)(a1 + 1112) >> 1));
    else
      v9 = (char *)(a1 + 600);
    if ( v8 )
      v4 = *(_QWORD *)(a1 + 1112) >> 1;
    v10 = *(char **)(a1 + 1120);
    if ( !v8 )
      v10 = (char *)(a1 + 88);
    _acrt_fp_format(
      &v22,
      v10,
      v4,
      v9,
      v7,
      *(char *)(a1 + 66),
      *(_DWORD *)(a1 + 56),
      *(_QWORD *)a1,
      *(struct __crt_locale_pointers **)(a1 + 8));
    if ( (*(_DWORD *)(a1 + 48) & 0x20) != 0 && !*(_DWORD *)(a1 + 56) )
      __crt_stdio_output::force_decimal_point(*(__crt_stdio_output **)(a1 + 72), *(char **)(a1 + 8), v11);
    if ( ((*(_WORD *)(a1 + 66) - 71) & 0xFFDF) == 0 && (*(_DWORD *)(a1 + 48) & 0x20) == 0 )
    {
      v12 = *(char **)(a1 + 72);
      v13 = ***(_BYTE ***)(**(_QWORD **)(a1 + 8) + 248i64);
      while ( *v12 && *v12 != v13 )
        ++v12;
      v14 = *v12;
      v15 = v12 + 1;
      if ( v14 )
      {
        while ( *v15 && ((*v15 - 69) & 0xDF) != 0 )
          ++v15;
        v16 = v15;
        do
          --v15;
        while ( *v15 == 48 );
        if ( *v15 == v13 )
          --v15;
        do
        {
          v17 = *v16;
          ++v15;
          ++v16;
          *v15 = v17;
        }
        while ( v17 );
      }
    }
    v18 = *(_BYTE **)(a1 + 72);
    if ( *v18 == 45 )
    {
      *(_DWORD *)(a1 + 48) |= 0x40u;
      *(_QWORD *)(a1 + 72) = ++v18;
    }
    v19 = *(_BYTE **)(a1 + 72);
    LOBYTE(v18) = *v19 - 73;
    if ( (unsigned __int8)v18 <= 0x25u )
    {
      v20 = 0x2100000021i64;
      if ( _bittest64(&v20, (unsigned __int64)v18) )
        *(_WORD *)(a1 + 66) = 115;
    }
    v21 = -1i64;
    do
      ++v21;
    while ( v19[v21] );
    *(_DWORD *)(a1 + 80) = v21;
  }
  return 1;
}
// 140034BDF: variable 'v11' is possibly undefined
// 140025D14: using guessed type __int64 __fastcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_QWORD, _QWORD);

//----- (0000000140035148) ----------------------------------------------------
char __fastcall sub_140035148(__int64 a1)
{
  int v3; // eax
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // rcx
  char *v9; // r9
  char *v10; // rdx
  struct __crt_locale_pointers *v11; // r8
  char *v12; // rdx
  char v13; // r8
  char v14; // al
  char *v15; // rdx
  char *v16; // rcx
  char v17; // al
  _BYTE *v18; // rax
  _BYTE *v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  double v22; // [rsp+60h] [rbp+8h] BYREF

  *(_DWORD *)(a1 + 48) |= 0x10u;
  if ( !sub_14003A284(a1) )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
  {
    v3 = *(_DWORD *)(a1 + 56);
    if ( v3 >= 0 )
    {
      if ( !v3 && ((*(_WORD *)(a1 + 66) - 71) & 0xFFDF) == 0 )
        *(_DWORD *)(a1 + 56) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 56) = ((*(_WORD *)(a1 + 66) - 65) & 0xFFDF) != 0 ? 6 : 13;
    }
    v4 = 512i64;
    if ( !(unsigned __int8)__crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(
                             a1 + 88,
                             *(_DWORD *)(a1 + 56) + 349) )
    {
      if ( *(_QWORD *)(a1 + 1120) )
        v5 = *(_QWORD *)(a1 + 1112) >> 1;
      else
        LODWORD(v5) = 512;
      *(_DWORD *)(a1 + 56) = v5 - 349;
    }
    v6 = *(_QWORD *)(a1 + 1120);
    if ( !v6 )
      v6 = a1 + 88;
    *(_QWORD *)(a1 + 72) = v6;
    v22 = 0.0;
    if ( !sub_1400280C8(a1, &v22) )
      return 0;
    if ( *(_QWORD *)(a1 + 1120) )
      v7 = *(_QWORD *)(a1 + 1112) >> 1;
    else
      v7 = 512i64;
    v8 = *(_QWORD *)(a1 + 1120);
    if ( v8 )
      v9 = (char *)(v8 + (*(_QWORD *)(a1 + 1112) >> 1));
    else
      v9 = (char *)(a1 + 600);
    if ( v8 )
      v4 = *(_QWORD *)(a1 + 1112) >> 1;
    v10 = *(char **)(a1 + 1120);
    if ( !v8 )
      v10 = (char *)(a1 + 88);
    _acrt_fp_format(
      &v22,
      v10,
      v4,
      v9,
      v7,
      *(char *)(a1 + 66),
      *(_DWORD *)(a1 + 56),
      *(_QWORD *)a1,
      *(struct __crt_locale_pointers **)(a1 + 8));
    if ( (*(_DWORD *)(a1 + 48) & 0x20) != 0 && !*(_DWORD *)(a1 + 56) )
      __crt_stdio_output::force_decimal_point(*(__crt_stdio_output **)(a1 + 72), *(char **)(a1 + 8), v11);
    if ( ((*(_WORD *)(a1 + 66) - 71) & 0xFFDF) == 0 && (*(_DWORD *)(a1 + 48) & 0x20) == 0 )
    {
      v12 = *(char **)(a1 + 72);
      v13 = ***(_BYTE ***)(**(_QWORD **)(a1 + 8) + 248i64);
      while ( *v12 && *v12 != v13 )
        ++v12;
      v14 = *v12;
      v15 = v12 + 1;
      if ( v14 )
      {
        while ( *v15 && ((*v15 - 69) & 0xDF) != 0 )
          ++v15;
        v16 = v15;
        do
          --v15;
        while ( *v15 == 48 );
        if ( *v15 == v13 )
          --v15;
        do
        {
          v17 = *v16;
          ++v15;
          ++v16;
          *v15 = v17;
        }
        while ( v17 );
      }
    }
    v18 = *(_BYTE **)(a1 + 72);
    if ( *v18 == 45 )
    {
      *(_DWORD *)(a1 + 48) |= 0x40u;
      *(_QWORD *)(a1 + 72) = ++v18;
    }
    v19 = *(_BYTE **)(a1 + 72);
    LOBYTE(v18) = *v19 - 73;
    if ( (unsigned __int8)v18 <= 0x25u )
    {
      v20 = 0x2100000021i64;
      if ( _bittest64(&v20, (unsigned __int64)v18) )
        *(_WORD *)(a1 + 66) = 115;
    }
    v21 = -1i64;
    do
      ++v21;
    while ( v19[v21] );
    *(_DWORD *)(a1 + 80) = v21;
  }
  return 1;
}
// 1400352D7: variable 'v11' is possibly undefined
// 140025D14: using guessed type __int64 __fastcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_QWORD, _QWORD);

//----- (0000000140035710) ----------------------------------------------------
char __fastcall sub_140035710(__int64 a1, __int64 a2)
{
  __int64 v4; // rdi
  rsize_t v5; // r8
  char *v6; // rdx
  _BYTE *v7; // rdx
  __int64 v8; // rax
  wchar_t v9; // [rsp+30h] [rbp+8h] BYREF

  LOBYTE(a2) = *(_BYTE *)(a1 + 65);
  if ( (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<char>(
                          *(_QWORD *)a1,
                          a2,
                          *(unsigned int *)(a1 + 60)) )
  {
    v9 = 0;
    if ( !sub_1400288B0(a1, &v9) )
      return 0;
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v4 = a1 + 88;
      if ( *(_QWORD *)(a1 + 1120) )
        v5 = *(_QWORD *)(a1 + 1112) >> 1;
      else
        v5 = 512i64;
      v6 = *(char **)(a1 + 1120);
      if ( !v6 )
        v6 = (char *)(a1 + 88);
      if ( wctomb_s((int *)(a1 + 80), v6, v5, v9) )
        *(_BYTE *)(a1 + 64) = 1;
      goto LABEL_19;
    }
  }
  else
  {
    v4 = a1 + 88;
    v7 = *(_BYTE **)(a1 + 1120);
    if ( !v7 )
      v7 = (_BYTE *)(a1 + 88);
    if ( !sub_1400267F0(a1, v7) )
      return 0;
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      *(_DWORD *)(a1 + 80) = 1;
LABEL_19:
      v8 = *(_QWORD *)(v4 + 1032);
      if ( !v8 )
        v8 = v4;
      *(_QWORD *)(a1 + 72) = v8;
    }
  }
  return 1;
}
// 140028DA8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<char>(_QWORD, _QWORD, _QWORD);

//----- (0000000140035970) ----------------------------------------------------
char __fastcall sub_140035970(__int64 a1, __int64 a2)
{
  __int64 v4; // rdi
  rsize_t v5; // r8
  char *v6; // rdx
  _BYTE *v7; // rdx
  __int64 v8; // rax
  wchar_t v9; // [rsp+30h] [rbp+8h] BYREF

  LOBYTE(a2) = *(_BYTE *)(a1 + 65);
  if ( (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<char>(
                          *(_QWORD *)a1,
                          a2,
                          *(unsigned int *)(a1 + 60)) )
  {
    v9 = 0;
    if ( !sub_140028974(a1, &v9) )
      return 0;
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v4 = a1 + 88;
      if ( *(_QWORD *)(a1 + 1120) )
        v5 = *(_QWORD *)(a1 + 1112) >> 1;
      else
        v5 = 512i64;
      v6 = *(char **)(a1 + 1120);
      if ( !v6 )
        v6 = (char *)(a1 + 88);
      if ( wctomb_s((int *)(a1 + 80), v6, v5, v9) )
        *(_BYTE *)(a1 + 64) = 1;
      goto LABEL_19;
    }
  }
  else
  {
    v4 = a1 + 88;
    v7 = *(_BYTE **)(a1 + 1120);
    if ( !v7 )
      v7 = (_BYTE *)(a1 + 88);
    if ( !sub_1400268B0(a1, v7) )
      return 0;
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      *(_DWORD *)(a1 + 80) = 1;
LABEL_19:
      v8 = *(_QWORD *)(v4 + 1032);
      if ( !v8 )
        v8 = v4;
      *(_QWORD *)(a1 + 72) = v8;
    }
  }
  return 1;
}
// 140028DA8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<char>(_QWORD, _QWORD, _QWORD);

//----- (0000000140035BC4) ----------------------------------------------------
char __fastcall sub_140035BC4(__int64 a1)
{
  char result; // al
  char is_wide_character; // al
  wchar_t *v4; // rcx
  __crt_locale_pointers *v5; // r9
  __int64 v6; // rax
  wchar_t SrcCh; // [rsp+30h] [rbp+8h] BYREF

  *(_BYTE *)(a1 + 84) = 1;
  SrcCh = 0;
  result = sub_140028A38(a1, &SrcCh);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      is_wide_character = __crt_stdio_output::is_wide_character_specifier<wchar_t>(
                            *(_QWORD *)a1,
                            *(unsigned __int16 *)(a1 + 66),
                            *(unsigned int *)(a1 + 60));
      v4 = *(wchar_t **)(a1 + 1120);
      if ( is_wide_character )
      {
        if ( !v4 )
          v4 = (wchar_t *)(a1 + 88);
        *v4 = SrcCh;
      }
      else
      {
        v5 = *(__crt_locale_pointers **)(a1 + 8);
        HIBYTE(SrcCh) = 0;
        if ( !v4 )
          v4 = (wchar_t *)(a1 + 88);
        if ( mbtowc_l(v4, (const char *)&SrcCh, *((int *)v5->locinfo + 2), v5) < 0 )
          *(_BYTE *)(a1 + 64) = 1;
      }
      v6 = *(_QWORD *)(a1 + 1120);
      *(_DWORD *)(a1 + 80) = 1;
      if ( !v6 )
        v6 = a1 + 88;
      *(_QWORD *)(a1 + 72) = v6;
    }
    return 1;
  }
  return result;
}
// 140028DD8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<wchar_t>(_QWORD, _QWORD, _QWORD);

//----- (0000000140035DE0) ----------------------------------------------------
char __fastcall sub_140035DE0(__int64 a1)
{
  char result; // al
  char is_wide_character; // al
  wchar_t *v4; // rcx
  __crt_locale_pointers *v5; // r9
  __int64 v6; // rax
  wchar_t SrcCh; // [rsp+30h] [rbp+8h] BYREF

  *(_BYTE *)(a1 + 84) = 1;
  SrcCh = 0;
  result = sub_140028B00(a1, &SrcCh);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      is_wide_character = __crt_stdio_output::is_wide_character_specifier<wchar_t>(
                            *(_QWORD *)a1,
                            *(unsigned __int16 *)(a1 + 66),
                            *(unsigned int *)(a1 + 60));
      v4 = *(wchar_t **)(a1 + 1120);
      if ( is_wide_character )
      {
        if ( !v4 )
          v4 = (wchar_t *)(a1 + 88);
        *v4 = SrcCh;
      }
      else
      {
        v5 = *(__crt_locale_pointers **)(a1 + 8);
        HIBYTE(SrcCh) = 0;
        if ( !v4 )
          v4 = (wchar_t *)(a1 + 88);
        if ( mbtowc_l(v4, (const char *)&SrcCh, *((int *)v5->locinfo + 2), v5) < 0 )
          *(_BYTE *)(a1 + 64) = 1;
      }
      v6 = *(_QWORD *)(a1 + 1120);
      *(_DWORD *)(a1 + 80) = 1;
      if ( !v6 )
        v6 = a1 + 88;
      *(_QWORD *)(a1 + 72) = v6;
    }
    return 1;
  }
  return result;
}
// 140028DD8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<wchar_t>(_QWORD, _QWORD, _QWORD);

//----- (0000000140036014) ----------------------------------------------------
char __fastcall sub_140036014(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_407(a1, v14, a2, a4);
  else
    unknown_libname_395(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 140029014: using guessed type __int64 __fastcall unknown_libname_395(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029764: using guessed type __int64 __fastcall unknown_libname_407(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400361B4) ----------------------------------------------------
char __fastcall sub_1400361B4(__int64 a1, unsigned int a2, char a3)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdi
  int v12; // ecx
  int v13; // ecx
  char v14; // al
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // [rsp+40h] [rbp+8h] BYREF

  v5 = *(_DWORD *)(a1 + 60);
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_15;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_15:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  v17 = 0i64;
  switch ( v10 )
  {
    case 1i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140025DC0(a1, &v17);
      else
        v14 = sub_140026128(a1, &v17);
      break;
    case 2i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140026488(a1, &v17);
      else
        v14 = sub_140026998(a1, &v17);
      break;
    case 4i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140026CF8(a1, &v17);
      else
        v14 = sub_140027058(a1, &v17);
      break;
    case 8i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = unknown_libname_336(a1, &v17);
      else
        v14 = unknown_libname_344(a1, &v17);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( !v14 )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
  {
    v16 = v17;
    if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v17 < 0 )
    {
      v16 = -v17;
      *(_DWORD *)(a1 + 48) |= 0x40u;
    }
    if ( *(int *)(a1 + 56) >= 0 )
    {
      *(_DWORD *)(a1 + 48) &= ~8u;
      if ( *(int *)(a1 + 56) > 512 )
        *(_DWORD *)(a1 + 56) = 512;
    }
    else
    {
      *(_DWORD *)(a1 + 56) = 1;
    }
    if ( !v16 )
      *(_DWORD *)(a1 + 48) &= ~0x20u;
    LOBYTE(v15) = a3;
    if ( v10 == 8 )
      unknown_libname_408(a1, v16, a2, v15);
    else
      unknown_libname_396(a1, (unsigned int)v16, a2, v15);
    if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
    {
      *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
      ++*(_DWORD *)(a1 + 80);
    }
  }
  return 1;
}
// 140036360: variable 'v15' is possibly undefined
// 1400281F0: using guessed type __int64 __fastcall unknown_libname_336(_QWORD, _QWORD);
// 140028550: using guessed type __int64 __fastcall unknown_libname_344(_QWORD, _QWORD);
// 1400290B0: using guessed type __int64 __fastcall unknown_libname_396(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029800: using guessed type __int64 __fastcall unknown_libname_408(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400363B8) ----------------------------------------------------
char __fastcall sub_1400363B8(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_409(a1, v14, a2, a4);
  else
    unknown_libname_397(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 14002914C: using guessed type __int64 __fastcall unknown_libname_397(_QWORD, _QWORD, _QWORD, _QWORD);
// 14002989C: using guessed type __int64 __fastcall unknown_libname_409(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140036558) ----------------------------------------------------
char __fastcall sub_140036558(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_410(a1, v14, a2, a4);
  else
    unknown_libname_398(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 1400291E8: using guessed type __int64 __fastcall unknown_libname_398(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029938: using guessed type __int64 __fastcall unknown_libname_410(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400366F8) ----------------------------------------------------
char __fastcall sub_1400366F8(__int64 a1, unsigned int a2, char a3)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdi
  int v12; // ecx
  int v13; // ecx
  char v14; // al
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // [rsp+40h] [rbp+8h] BYREF

  v5 = *(_DWORD *)(a1 + 60);
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_15;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_15:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  v17 = 0i64;
  switch ( v10 )
  {
    case 1i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140025E84(a1, &v17);
      else
        v14 = sub_1400261EC(a1, &v17);
      break;
    case 2i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_14002654C(a1, &v17);
      else
        v14 = sub_140026A5C(a1, &v17);
      break;
    case 4i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140026DBC(a1, &v17);
      else
        v14 = sub_140027118(a1, &v17);
      break;
    case 8i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = unknown_libname_337(a1, &v17);
      else
        v14 = unknown_libname_345(a1, &v17);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( !v14 )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
  {
    v16 = v17;
    if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v17 < 0 )
    {
      v16 = -v17;
      *(_DWORD *)(a1 + 48) |= 0x40u;
    }
    if ( *(int *)(a1 + 56) >= 0 )
    {
      *(_DWORD *)(a1 + 48) &= ~8u;
      if ( *(int *)(a1 + 56) > 512 )
        *(_DWORD *)(a1 + 56) = 512;
    }
    else
    {
      *(_DWORD *)(a1 + 56) = 1;
    }
    if ( !v16 )
      *(_DWORD *)(a1 + 48) &= ~0x20u;
    LOBYTE(v15) = a3;
    if ( v10 == 8 )
      unknown_libname_411(a1, v16, a2, v15);
    else
      unknown_libname_399(a1, (unsigned int)v16, a2, v15);
    if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
    {
      *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
      ++*(_DWORD *)(a1 + 80);
    }
  }
  return 1;
}
// 1400368A4: variable 'v15' is possibly undefined
// 1400282B4: using guessed type __int64 __fastcall unknown_libname_337(_QWORD, _QWORD);
// 140028614: using guessed type __int64 __fastcall unknown_libname_345(_QWORD, _QWORD);
// 140029284: using guessed type __int64 __fastcall unknown_libname_399(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400299D4: using guessed type __int64 __fastcall unknown_libname_411(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400368FC) ----------------------------------------------------
char __fastcall sub_1400368FC(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_412(a1, v14, a2, a4);
  else
    unknown_libname_400(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 140029320: using guessed type __int64 __fastcall unknown_libname_400(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029A70: using guessed type __int64 __fastcall unknown_libname_412(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140036A9C) ----------------------------------------------------
char __fastcall sub_140036A9C(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_413(a1, v14, a2, a4);
  else
    unknown_libname_401(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 1400293BC: using guessed type __int64 __fastcall unknown_libname_401(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029B0C: using guessed type __int64 __fastcall unknown_libname_413(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140036C3C) ----------------------------------------------------
char __fastcall sub_140036C3C(__int64 a1, unsigned int a2, char a3)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdi
  int v12; // ecx
  int v13; // ecx
  char v14; // al
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // [rsp+40h] [rbp+8h] BYREF

  v5 = *(_DWORD *)(a1 + 60);
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_15;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_15:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  v17 = 0i64;
  switch ( v10 )
  {
    case 1i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140025F48(a1, &v17);
      else
        v14 = sub_1400262B0(a1, &v17);
      break;
    case 2i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140026610(a1, &v17);
      else
        v14 = sub_140026B20(a1, &v17);
      break;
    case 4i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140026E80(a1, &v17);
      else
        v14 = sub_1400271D8(a1, &v17);
      break;
    case 8i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = unknown_libname_338(a1, &v17);
      else
        v14 = unknown_libname_346(a1, &v17);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( !v14 )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
  {
    v16 = v17;
    if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v17 < 0 )
    {
      v16 = -v17;
      *(_DWORD *)(a1 + 48) |= 0x40u;
    }
    if ( *(int *)(a1 + 56) >= 0 )
    {
      *(_DWORD *)(a1 + 48) &= ~8u;
      if ( *(int *)(a1 + 56) > 512 )
        *(_DWORD *)(a1 + 56) = 512;
    }
    else
    {
      *(_DWORD *)(a1 + 56) = 1;
    }
    if ( !v16 )
      *(_DWORD *)(a1 + 48) &= ~0x20u;
    LOBYTE(v15) = a3;
    if ( v10 == 8 )
      unknown_libname_414(a1, v16, a2, v15);
    else
      unknown_libname_402(a1, (unsigned int)v16, a2, v15);
    if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
    {
      *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
      ++*(_DWORD *)(a1 + 80);
    }
  }
  return 1;
}
// 140036DE8: variable 'v15' is possibly undefined
// 140028378: using guessed type __int64 __fastcall unknown_libname_338(_QWORD, _QWORD);
// 1400286D8: using guessed type __int64 __fastcall unknown_libname_346(_QWORD, _QWORD);
// 140029458: using guessed type __int64 __fastcall unknown_libname_402(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029BA8: using guessed type __int64 __fastcall unknown_libname_414(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140036E40) ----------------------------------------------------
char __fastcall sub_140036E40(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_415(a1, v14, a2, a4);
  else
    unknown_libname_403(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 1400294F4: using guessed type __int64 __fastcall unknown_libname_403(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029C44: using guessed type __int64 __fastcall unknown_libname_415(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140036FE0) ----------------------------------------------------
char __fastcall sub_140036FE0(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_416(a1, v14, a2, a4);
  else
    unknown_libname_404(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 140029590: using guessed type __int64 __fastcall unknown_libname_404(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029CE0: using guessed type __int64 __fastcall unknown_libname_416(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140037180) ----------------------------------------------------
char __fastcall sub_140037180(__int64 a1, unsigned int a2, char a3)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdi
  int v12; // ecx
  int v13; // ecx
  char v14; // al
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // [rsp+40h] [rbp+8h] BYREF

  v5 = *(_DWORD *)(a1 + 60);
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_15;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_15:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  v17 = 0i64;
  switch ( v10 )
  {
    case 1i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140026010(a1, &v17);
      else
        v14 = sub_140026374(a1, &v17);
      break;
    case 2i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_1400266D8(a1, &v17);
      else
        v14 = sub_140026BE4(a1, &v17);
      break;
    case 4i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = sub_140026F44(a1, &v17);
      else
        v14 = sub_14002729C(a1, &v17);
      break;
    case 8i64:
      if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 )
        v14 = unknown_libname_339(a1, &v17);
      else
        v14 = unknown_libname_347(a1, &v17);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( !v14 )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
  {
    v16 = v17;
    if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v17 < 0 )
    {
      v16 = -v17;
      *(_DWORD *)(a1 + 48) |= 0x40u;
    }
    if ( *(int *)(a1 + 56) >= 0 )
    {
      *(_DWORD *)(a1 + 48) &= ~8u;
      if ( *(int *)(a1 + 56) > 512 )
        *(_DWORD *)(a1 + 56) = 512;
    }
    else
    {
      *(_DWORD *)(a1 + 56) = 1;
    }
    if ( !v16 )
      *(_DWORD *)(a1 + 48) &= ~0x20u;
    LOBYTE(v15) = a3;
    if ( v10 == 8 )
      unknown_libname_417(a1, v16, a2, v15);
    else
      unknown_libname_405(a1, (unsigned int)v16, a2, v15);
    if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
    {
      *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
      ++*(_DWORD *)(a1 + 80);
    }
  }
  return 1;
}
// 14003732C: variable 'v15' is possibly undefined
// 14002843C: using guessed type __int64 __fastcall unknown_libname_339(_QWORD, _QWORD);
// 14002879C: using guessed type __int64 __fastcall unknown_libname_347(_QWORD, _QWORD);
// 14002962C: using guessed type __int64 __fastcall unknown_libname_405(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029D7C: using guessed type __int64 __fastcall unknown_libname_417(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140037384) ----------------------------------------------------
char __fastcall sub_140037384(__int64 a1, unsigned int a2, char a3, __int64 a4)
{
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rdx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rcx
  int v15; // eax
  bool v16; // zf
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  __int64 v21; // rax

  v5 = *(_DWORD *)(a1 + 60);
  LOBYTE(a4) = a3;
  if ( v5 > 5 )
  {
    v12 = v5 - 6;
    if ( !v12 )
      goto LABEL_8;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_8;
    v8 = v13 - 2;
    if ( !v8 )
      goto LABEL_8;
  }
  else
  {
    if ( v5 == 5 )
    {
LABEL_8:
      v10 = 8i64;
      goto LABEL_9;
    }
    if ( !v5 )
      goto LABEL_14;
    v7 = v5 - 1;
    if ( !v7 )
    {
      v10 = 1i64;
      goto LABEL_9;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v10 = 2i64;
      goto LABEL_9;
    }
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_14:
    v10 = 4i64;
    goto LABEL_9;
  }
  if ( v9 == 1 )
    goto LABEL_8;
  v10 = 0i64;
LABEL_9:
  switch ( v10 )
  {
    case 1i64:
      v20 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v20 & 0x10) == 0;
      v21 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int8 *)(v21 - 8);
      else
        v14 = *(char *)(v21 - 8);
      break;
    case 2i64:
      v18 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v18 & 0x10) == 0;
      v19 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned __int16 *)(v19 - 8);
      else
        v14 = *(__int16 *)(v19 - 8);
      break;
    case 4i64:
      v15 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v16 = (v15 & 0x10) == 0;
      v17 = *(_QWORD *)(a1 + 32);
      if ( v16 )
        v14 = *(unsigned int *)(v17 - 8);
      else
        v14 = *(int *)(v17 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v14 < 0 )
  {
    v14 = -v14;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v14 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v10 == 8 )
    unknown_libname_418(a1, v14, a2, a4);
  else
    unknown_libname_406(a1, (unsigned int)v14, a2, a4);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}
// 1400296C8: using guessed type __int64 __fastcall unknown_libname_406(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029E18: using guessed type __int64 __fastcall unknown_libname_418(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140037600) ----------------------------------------------------
char __fastcall sub_140037600(__int64 a1)
{
  __int64 v1; // rbx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  _QWORD *v13; // [rsp+38h] [rbp+10h] BYREF

  v1 = 0i64;
  v13 = 0i64;
  if ( !(unsigned __int8)unknown_libname_324(a1, &v13) )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) == 1 && *(_DWORD *)(a1 + 1148) != 1 )
    return 1;
  if ( !get_printf_count_output() )
  {
LABEL_6:
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 60);
  if ( v4 > 5 )
  {
    v8 = v4 - 6;
    if ( !v8 )
      goto LABEL_21;
    v9 = v8 - 1;
    if ( !v9 )
      goto LABEL_21;
    v6 = v9 - 2;
    if ( !v6 )
      goto LABEL_21;
  }
  else
  {
    if ( v4 == 5 )
    {
LABEL_21:
      v1 = 8i64;
      goto LABEL_22;
    }
    if ( !v4 )
      goto LABEL_15;
    v5 = v4 - 1;
    if ( !v5 )
    {
      v1 = 1i64;
      goto LABEL_22;
    }
    v6 = v5 - 1;
    if ( !v6 )
    {
      v1 = 2i64;
      goto LABEL_22;
    }
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
LABEL_15:
    v1 = 4i64;
    goto LABEL_22;
  }
  if ( v7 == 1 )
    goto LABEL_21;
LABEL_22:
  v10 = v1 - 1;
  if ( v10 )
  {
    v11 = v10 - 1;
    if ( v11 )
    {
      v12 = v11 - 2;
      if ( v12 )
      {
        if ( v12 != 4 )
          goto LABEL_6;
        *v13 = *(int *)(a1 + 40);
      }
      else
      {
        *(_DWORD *)v13 = *(_DWORD *)(a1 + 40);
      }
    }
    else
    {
      *(_WORD *)v13 = *(_WORD *)(a1 + 40);
    }
  }
  else
  {
    *(_BYTE *)v13 = *(_BYTE *)(a1 + 40);
  }
  *(_BYTE *)(a1 + 64) = 1;
  return 1;
}
// 140027B10: using guessed type __int64 __fastcall unknown_libname_324(_QWORD, _QWORD);

//----- (00000001400378BC) ----------------------------------------------------
char __fastcall sub_1400378BC(__int64 a1)
{
  __int64 v1; // rbx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  _QWORD *v13; // [rsp+38h] [rbp+10h] BYREF

  v1 = 0i64;
  v13 = 0i64;
  if ( !(unsigned __int8)unknown_libname_325(a1, &v13) )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) == 1 && *(_DWORD *)(a1 + 1148) != 1 )
    return 1;
  if ( !get_printf_count_output() )
  {
LABEL_6:
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 60);
  if ( v4 > 5 )
  {
    v8 = v4 - 6;
    if ( !v8 )
      goto LABEL_21;
    v9 = v8 - 1;
    if ( !v9 )
      goto LABEL_21;
    v6 = v9 - 2;
    if ( !v6 )
      goto LABEL_21;
  }
  else
  {
    if ( v4 == 5 )
    {
LABEL_21:
      v1 = 8i64;
      goto LABEL_22;
    }
    if ( !v4 )
      goto LABEL_15;
    v5 = v4 - 1;
    if ( !v5 )
    {
      v1 = 1i64;
      goto LABEL_22;
    }
    v6 = v5 - 1;
    if ( !v6 )
    {
      v1 = 2i64;
      goto LABEL_22;
    }
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
LABEL_15:
    v1 = 4i64;
    goto LABEL_22;
  }
  if ( v7 == 1 )
    goto LABEL_21;
LABEL_22:
  v10 = v1 - 1;
  if ( v10 )
  {
    v11 = v10 - 1;
    if ( v11 )
    {
      v12 = v11 - 2;
      if ( v12 )
      {
        if ( v12 != 4 )
          goto LABEL_6;
        *v13 = *(int *)(a1 + 40);
      }
      else
      {
        *(_DWORD *)v13 = *(_DWORD *)(a1 + 40);
      }
    }
    else
    {
      *(_WORD *)v13 = *(_WORD *)(a1 + 40);
    }
  }
  else
  {
    *(_BYTE *)v13 = *(_BYTE *)(a1 + 40);
  }
  *(_BYTE *)(a1 + 64) = 1;
  return 1;
}
// 140027BD4: using guessed type __int64 __fastcall unknown_libname_325(_QWORD, _QWORD);

//----- (0000000140037B78) ----------------------------------------------------
char __fastcall sub_140037B78(__int64 a1)
{
  __int64 v1; // rbx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  _QWORD *v13; // [rsp+38h] [rbp+10h] BYREF

  v1 = 0i64;
  v13 = 0i64;
  if ( !(unsigned __int8)unknown_libname_326(a1, &v13) )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) == 1 && *(_DWORD *)(a1 + 1148) != 1 )
    return 1;
  if ( !get_printf_count_output() )
  {
LABEL_6:
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 60);
  if ( v4 > 5 )
  {
    v8 = v4 - 6;
    if ( !v8 )
      goto LABEL_21;
    v9 = v8 - 1;
    if ( !v9 )
      goto LABEL_21;
    v6 = v9 - 2;
    if ( !v6 )
      goto LABEL_21;
  }
  else
  {
    if ( v4 == 5 )
    {
LABEL_21:
      v1 = 8i64;
      goto LABEL_22;
    }
    if ( !v4 )
      goto LABEL_15;
    v5 = v4 - 1;
    if ( !v5 )
    {
      v1 = 1i64;
      goto LABEL_22;
    }
    v6 = v5 - 1;
    if ( !v6 )
    {
      v1 = 2i64;
      goto LABEL_22;
    }
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
LABEL_15:
    v1 = 4i64;
    goto LABEL_22;
  }
  if ( v7 == 1 )
    goto LABEL_21;
LABEL_22:
  v10 = v1 - 1;
  if ( v10 )
  {
    v11 = v10 - 1;
    if ( v11 )
    {
      v12 = v11 - 2;
      if ( v12 )
      {
        if ( v12 != 4 )
          goto LABEL_6;
        *v13 = *(int *)(a1 + 40);
      }
      else
      {
        *(_DWORD *)v13 = *(_DWORD *)(a1 + 40);
      }
    }
    else
    {
      *(_WORD *)v13 = *(_WORD *)(a1 + 40);
    }
  }
  else
  {
    *(_BYTE *)v13 = *(_BYTE *)(a1 + 40);
  }
  *(_BYTE *)(a1 + 64) = 1;
  return 1;
}
// 140027C98: using guessed type __int64 __fastcall unknown_libname_326(_QWORD, _QWORD);

//----- (0000000140037E34) ----------------------------------------------------
char __fastcall sub_140037E34(__int64 a1)
{
  __int64 v1; // rbx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  _QWORD *v13; // [rsp+38h] [rbp+10h] BYREF

  v1 = 0i64;
  v13 = 0i64;
  if ( !(unsigned __int8)unknown_libname_327(a1, &v13) )
    return 0;
  if ( *(_DWORD *)(a1 + 1144) == 1 && *(_DWORD *)(a1 + 1148) != 1 )
    return 1;
  if ( !get_printf_count_output() )
  {
LABEL_6:
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 60);
  if ( v4 > 5 )
  {
    v8 = v4 - 6;
    if ( !v8 )
      goto LABEL_21;
    v9 = v8 - 1;
    if ( !v9 )
      goto LABEL_21;
    v6 = v9 - 2;
    if ( !v6 )
      goto LABEL_21;
  }
  else
  {
    if ( v4 == 5 )
    {
LABEL_21:
      v1 = 8i64;
      goto LABEL_22;
    }
    if ( !v4 )
      goto LABEL_15;
    v5 = v4 - 1;
    if ( !v5 )
    {
      v1 = 1i64;
      goto LABEL_22;
    }
    v6 = v5 - 1;
    if ( !v6 )
    {
      v1 = 2i64;
      goto LABEL_22;
    }
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
LABEL_15:
    v1 = 4i64;
    goto LABEL_22;
  }
  if ( v7 == 1 )
    goto LABEL_21;
LABEL_22:
  v10 = v1 - 1;
  if ( v10 )
  {
    v11 = v10 - 1;
    if ( v11 )
    {
      v12 = v11 - 2;
      if ( v12 )
      {
        if ( v12 != 4 )
          goto LABEL_6;
        *v13 = *(int *)(a1 + 40);
      }
      else
      {
        *(_DWORD *)v13 = *(_DWORD *)(a1 + 40);
      }
    }
    else
    {
      *(_WORD *)v13 = *(_WORD *)(a1 + 40);
    }
  }
  else
  {
    *(_BYTE *)v13 = *(_BYTE *)(a1 + 40);
  }
  *(_BYTE *)(a1 + 64) = 1;
  return 1;
}
// 140027D5C: using guessed type __int64 __fastcall unknown_libname_327(_QWORD, _QWORD);

//----- (0000000140038194) ----------------------------------------------------
char __fastcall sub_140038194(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_140036014(a1, 0x10u, 1, a4);
}

//----- (00000001400381AC) ----------------------------------------------------
char __fastcall sub_1400381AC(__int64 a1)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_1400361B4(a1, 0x10u, 1);
}

//----- (00000001400381C4) ----------------------------------------------------
char __fastcall sub_1400381C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_1400363B8(a1, 0x10u, 1, a4);
}

//----- (00000001400381DC) ----------------------------------------------------
char __fastcall sub_1400381DC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_140036558(a1, 0x10u, 1, a4);
}

//----- (00000001400381F4) ----------------------------------------------------
char __fastcall sub_1400381F4(__int64 a1)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_1400366F8(a1, 0x10u, 1);
}

//----- (000000014003820C) ----------------------------------------------------
char __fastcall sub_14003820C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_1400368FC(a1, 0x10u, 1, a4);
}

//----- (0000000140038224) ----------------------------------------------------
char __fastcall sub_140038224(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_140036A9C(a1, 0x10u, 1, a4);
}

//----- (000000014003823C) ----------------------------------------------------
char __fastcall sub_14003823C(__int64 a1)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_140036C3C(a1, 0x10u, 1);
}

//----- (0000000140038254) ----------------------------------------------------
char __fastcall sub_140038254(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_140036E40(a1, 0x10u, 1, a4);
}

//----- (000000014003826C) ----------------------------------------------------
char __fastcall sub_14003826C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_140036FE0(a1, 0x10u, 1, a4);
}

//----- (0000000140038284) ----------------------------------------------------
char __fastcall sub_140038284(__int64 a1)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_140037180(a1, 0x10u, 1);
}

//----- (000000014003829C) ----------------------------------------------------
char __fastcall sub_14003829C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)(a1 + 60) = 11;
  *(_DWORD *)(a1 + 56) = 16;
  return sub_140037384(a1, 0x10u, 1, a4);
}

//----- (0000000140038344) ----------------------------------------------------
char __fastcall sub_140038344(__int64 a1)
{
  const char **v1; // rdi
  char result; // al
  __int64 v4; // rdx
  int v5; // esi
  const wchar_t *v6; // rcx
  int v7; // eax

  v1 = (const char **)(a1 + 72);
  result = unknown_libname_300(a1, a1 + 72);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v5 = *(_DWORD *)(a1 + 56);
      if ( v5 == -1 )
        v5 = 0x7FFFFFFF;
      LOBYTE(v4) = *(_BYTE *)(a1 + 65);
      if ( (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<char>(
                              *(_QWORD *)a1,
                              v4,
                              *(unsigned int *)(a1 + 60)) )
      {
        if ( !*v1 )
          *v1 = (const char *)L"(null)";
        v6 = (const wchar_t *)*v1;
        *(_BYTE *)(a1 + 84) = 1;
        v7 = wcsnlen(v6, v5);
      }
      else
      {
        if ( !*v1 )
          *v1 = "(null)";
        v7 = strnlen(*v1, v5);
      }
      *(_DWORD *)(a1 + 80) = v7;
    }
    return 1;
  }
  return result;
}
// 140038390: variable 'v4' is possibly undefined
// 1400273B0: using guessed type __int64 __fastcall unknown_libname_300(_QWORD, _QWORD);
// 140028DA8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<char>(_QWORD, _QWORD, _QWORD);
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003850C) ----------------------------------------------------
char __fastcall sub_14003850C(__int64 a1)
{
  const char **v1; // rdi
  char result; // al
  __int64 v4; // rdx
  int v5; // esi
  const wchar_t *v6; // rcx
  int v7; // eax

  v1 = (const char **)(a1 + 72);
  result = unknown_libname_301(a1, a1 + 72);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v5 = *(_DWORD *)(a1 + 56);
      if ( v5 == -1 )
        v5 = 0x7FFFFFFF;
      LOBYTE(v4) = *(_BYTE *)(a1 + 65);
      if ( (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<char>(
                              *(_QWORD *)a1,
                              v4,
                              *(unsigned int *)(a1 + 60)) )
      {
        if ( !*v1 )
          *v1 = (const char *)L"(null)";
        v6 = (const wchar_t *)*v1;
        *(_BYTE *)(a1 + 84) = 1;
        v7 = wcsnlen(v6, v5);
      }
      else
      {
        if ( !*v1 )
          *v1 = "(null)";
        v7 = strnlen(*v1, v5);
      }
      *(_DWORD *)(a1 + 80) = v7;
    }
    return 1;
  }
  return result;
}
// 140038558: variable 'v4' is possibly undefined
// 140027474: using guessed type __int64 __fastcall unknown_libname_301(_QWORD, _QWORD);
// 140028DA8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<char>(_QWORD, _QWORD, _QWORD);
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003870C) ----------------------------------------------------
char __fastcall sub_14003870C(__int64 a1)
{
  const wchar_t **v1; // rdi
  char result; // al
  int v4; // esi
  const wchar_t *v5; // rcx
  const wchar_t *v6; // r8
  int i; // r9d

  v1 = (const wchar_t **)(a1 + 72);
  result = unknown_libname_302(a1, a1 + 72);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v4 = *(_DWORD *)(a1 + 56);
      if ( v4 == -1 )
        v4 = 0x7FFFFFFF;
      if ( (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<wchar_t>(
                              *(_QWORD *)a1,
                              *(unsigned __int16 *)(a1 + 66),
                              *(unsigned int *)(a1 + 60)) )
      {
        if ( !*v1 )
          *v1 = L"(null)";
        v5 = *v1;
        *(_BYTE *)(a1 + 84) = 1;
        *(_DWORD *)(a1 + 80) = wcsnlen(v5, v4);
      }
      else
      {
        if ( !*v1 )
          *v1 = (const wchar_t *)"(null)";
        v6 = *v1;
        for ( i = 0; i < v4; ++i )
        {
          if ( !*(_BYTE *)v6 )
            break;
          if ( *(__int16 *)(***(_QWORD ***)(a1 + 8) + 2i64 * *(unsigned __int8 *)v6) < 0 )
            v6 = (const wchar_t *)((char *)v6 + 1);
          v6 = (const wchar_t *)((char *)v6 + 1);
        }
        *(_DWORD *)(a1 + 80) = i;
      }
    }
    return 1;
  }
  return result;
}
// 140027538: using guessed type __int64 __fastcall unknown_libname_302(_QWORD, _QWORD);
// 140028DD8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<wchar_t>(_QWORD, _QWORD, _QWORD);
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003897C) ----------------------------------------------------
char __fastcall sub_14003897C(__int64 a1)
{
  const wchar_t **v1; // rdi
  char result; // al
  int v4; // esi
  const wchar_t *v5; // rcx
  const wchar_t *v6; // r8
  int i; // r9d

  v1 = (const wchar_t **)(a1 + 72);
  result = unknown_libname_303(a1, a1 + 72);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1144) != 1 || *(_DWORD *)(a1 + 1148) == 1 )
    {
      v4 = *(_DWORD *)(a1 + 56);
      if ( v4 == -1 )
        v4 = 0x7FFFFFFF;
      if ( (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<wchar_t>(
                              *(_QWORD *)a1,
                              *(unsigned __int16 *)(a1 + 66),
                              *(unsigned int *)(a1 + 60)) )
      {
        if ( !*v1 )
          *v1 = L"(null)";
        v5 = *v1;
        *(_BYTE *)(a1 + 84) = 1;
        *(_DWORD *)(a1 + 80) = wcsnlen(v5, v4);
      }
      else
      {
        if ( !*v1 )
          *v1 = (const wchar_t *)"(null)";
        v6 = *v1;
        for ( i = 0; i < v4; ++i )
        {
          if ( !*(_BYTE *)v6 )
            break;
          if ( *(__int16 *)(***(_QWORD ***)(a1 + 8) + 2i64 * *(unsigned __int8 *)v6) < 0 )
            v6 = (const wchar_t *)((char *)v6 + 1);
          v6 = (const wchar_t *)((char *)v6 + 1);
        }
        *(_DWORD *)(a1 + 80) = i;
      }
    }
    return 1;
  }
  return result;
}
// 1400275FC: using guessed type __int64 __fastcall unknown_libname_303(_QWORD, _QWORD);
// 140028DD8: using guessed type __int64 __fastcall __crt_stdio_output::is_wide_character_specifier<wchar_t>(_QWORD, _QWORD, _QWORD);
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (0000000140038E84) ----------------------------------------------------
char __fastcall sub_140038E84(__int64 a1)
{
  const char *v2; // rcx
  char v3; // di
  int v4; // eax
  int v5; // r9d
  bool v6; // zf
  int v7; // edx
  char *v8; // rax
  int v9; // eax
  int v10; // r8d
  __int64 v11; // rdx
  char *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(const char **)(a1 + 24);
    v3 = 0;
    EndPtr = 0i64;
    v4 = strtol(v2, &EndPtr, 10);
    v6 = *(_DWORD *)(a1 + 1144) == 1;
    v7 = v4 - 1;
    v8 = EndPtr;
    *(_QWORD *)(a1 + 24) = EndPtr + 1;
    if ( !v6 )
    {
      *(_DWORD *)(a1 + 52) = **(_DWORD **)(a1 + 24i64 * v7 + 1168);
      return 1;
    }
    if ( v7 < 0 || *v8 != 36 || v7 >= 100 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v9 = *(_DWORD *)(a1 + 3560);
    v10 = *(_DWORD *)(a1 + 60);
    LOBYTE(v5) = *(_BYTE *)(a1 + 65);
    if ( v7 > v9 )
      v9 = v7;
    *(_DWORD *)(a1 + 3560) = v9;
    v11 = a1 + 8 * (v7 + 2i64 * v7 + 145);
    if ( *(_DWORD *)v11 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v11, 1, v5, v10) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v3;
      }
    }
    else
    {
      *(_DWORD *)v11 = 1;
      *(_BYTE *)(v11 + 4) = v5;
      *(_DWORD *)(v11 + 16) = v10;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 140038F47: variable 'v5' is possibly undefined
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140038F98) ----------------------------------------------------
char __fastcall sub_140038F98(__int64 a1)
{
  const char *v2; // rcx
  char v3; // di
  int v4; // eax
  int v5; // r9d
  bool v6; // zf
  int v7; // edx
  char *v8; // rax
  int v9; // eax
  int v10; // r8d
  __int64 v11; // rdx
  char *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(const char **)(a1 + 24);
    v3 = 0;
    EndPtr = 0i64;
    v4 = strtol(v2, &EndPtr, 10);
    v6 = *(_DWORD *)(a1 + 1144) == 1;
    v7 = v4 - 1;
    v8 = EndPtr;
    *(_QWORD *)(a1 + 24) = EndPtr + 1;
    if ( !v6 )
    {
      *(_DWORD *)(a1 + 52) = **(_DWORD **)(a1 + 24i64 * v7 + 1168);
      return 1;
    }
    if ( v7 < 0 || *v8 != 36 || v7 >= 100 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v9 = *(_DWORD *)(a1 + 3560);
    v10 = *(_DWORD *)(a1 + 60);
    LOBYTE(v5) = *(_BYTE *)(a1 + 65);
    if ( v7 > v9 )
      v9 = v7;
    *(_DWORD *)(a1 + 3560) = v9;
    v11 = a1 + 8 * (v7 + 2i64 * v7 + 145);
    if ( *(_DWORD *)v11 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v11, 1, v5, v10) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v3;
      }
    }
    else
    {
      *(_DWORD *)v11 = 1;
      *(_BYTE *)(v11 + 4) = v5;
      *(_DWORD *)(v11 + 16) = v10;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14003905B: variable 'v5' is possibly undefined
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400390AC) ----------------------------------------------------
char __fastcall sub_1400390AC(__int64 a1)
{
  const wchar_t *v2; // rcx
  char v3; // di
  int v4; // eax
  bool v5; // zf
  int v6; // edx
  wchar_t *v7; // rax
  int v8; // eax
  int v9; // r8d
  int v10; // r9d
  __int64 v11; // rdx
  wchar_t *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(const wchar_t **)(a1 + 24);
    v3 = 0;
    EndPtr = 0i64;
    v4 = wcstol(v2, &EndPtr, 10);
    v5 = *(_DWORD *)(a1 + 1144) == 1;
    v6 = v4 - 1;
    v7 = EndPtr;
    *(_QWORD *)(a1 + 24) = EndPtr + 1;
    if ( !v5 )
    {
      *(_DWORD *)(a1 + 52) = **(_DWORD **)(a1 + 24i64 * v6 + 1168);
      return 1;
    }
    if ( v6 < 0 || *v7 != 36 || v6 >= 100 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v8 = *(_DWORD *)(a1 + 3560);
    v9 = *(_DWORD *)(a1 + 60);
    v10 = *(unsigned __int16 *)(a1 + 66);
    if ( v6 > v8 )
      v8 = v6;
    *(_DWORD *)(a1 + 3560) = v8;
    v11 = a1 + 8 * (v6 + 2i64 * v6 + 145);
    if ( *(_DWORD *)v11 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v11, 1, v10, v9) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v3;
      }
    }
    else
    {
      *(_DWORD *)v11 = 1;
      *(_WORD *)(v11 + 4) = v10;
      *(_DWORD *)(v11 + 16) = v9;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400391C4) ----------------------------------------------------
char __fastcall sub_1400391C4(__int64 a1)
{
  const wchar_t *v2; // rcx
  char v3; // di
  int v4; // eax
  bool v5; // zf
  int v6; // edx
  wchar_t *v7; // rax
  int v8; // eax
  int v9; // r8d
  int v10; // r9d
  __int64 v11; // rdx
  wchar_t *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(const wchar_t **)(a1 + 24);
    v3 = 0;
    EndPtr = 0i64;
    v4 = wcstol(v2, &EndPtr, 10);
    v5 = *(_DWORD *)(a1 + 1144) == 1;
    v6 = v4 - 1;
    v7 = EndPtr;
    *(_QWORD *)(a1 + 24) = EndPtr + 1;
    if ( !v5 )
    {
      *(_DWORD *)(a1 + 52) = **(_DWORD **)(a1 + 24i64 * v6 + 1168);
      return 1;
    }
    if ( v6 < 0 || *v7 != 36 || v6 >= 100 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v8 = *(_DWORD *)(a1 + 3560);
    v9 = *(_DWORD *)(a1 + 60);
    v10 = *(unsigned __int16 *)(a1 + 66);
    if ( v6 > v8 )
      v8 = v6;
    *(_DWORD *)(a1 + 3560) = v8;
    v11 = a1 + 8 * (v6 + 2i64 * v6 + 145);
    if ( *(_DWORD *)v11 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v11, 1, v10, v9) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v3;
      }
    }
    else
    {
      *(_DWORD *)v11 = 1;
      *(_WORD *)(v11 + 4) = v10;
      *(_DWORD *)(v11 + 16) = v9;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003932C) ----------------------------------------------------
char __fastcall sub_14003932C(__int64 a1)
{
  const char *v2; // rcx
  char v3; // di
  int v4; // eax
  int v5; // r9d
  bool v6; // zf
  int v7; // edx
  char *v8; // rax
  int v9; // eax
  int v10; // r8d
  __int64 v11; // rdx
  char *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(const char **)(a1 + 24);
    v3 = 0;
    EndPtr = 0i64;
    v4 = strtol(v2, &EndPtr, 10);
    v6 = *(_DWORD *)(a1 + 1144) == 1;
    v7 = v4 - 1;
    v8 = EndPtr;
    *(_QWORD *)(a1 + 24) = EndPtr + 1;
    if ( !v6 )
    {
      *(_DWORD *)(a1 + 56) = **(_DWORD **)(a1 + 24i64 * v7 + 1168);
      return 1;
    }
    if ( v7 < 0 || *v8 != 36 || v7 >= 100 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v9 = *(_DWORD *)(a1 + 3560);
    v10 = *(_DWORD *)(a1 + 60);
    LOBYTE(v5) = *(_BYTE *)(a1 + 65);
    if ( v7 > v9 )
      v9 = v7;
    *(_DWORD *)(a1 + 3560) = v9;
    v11 = a1 + 8 * (v7 + 2i64 * v7 + 145);
    if ( *(_DWORD *)v11 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v11, 1, v5, v10) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v3;
      }
    }
    else
    {
      *(_DWORD *)v11 = 1;
      *(_BYTE *)(v11 + 4) = v5;
      *(_DWORD *)(v11 + 16) = v10;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 1400393EF: variable 'v5' is possibly undefined
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140039440) ----------------------------------------------------
char __fastcall sub_140039440(__int64 a1)
{
  const char *v2; // rcx
  char v3; // di
  int v4; // eax
  int v5; // r9d
  bool v6; // zf
  int v7; // edx
  char *v8; // rax
  int v9; // eax
  int v10; // r8d
  __int64 v11; // rdx
  char *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(const char **)(a1 + 24);
    v3 = 0;
    EndPtr = 0i64;
    v4 = strtol(v2, &EndPtr, 10);
    v6 = *(_DWORD *)(a1 + 1144) == 1;
    v7 = v4 - 1;
    v8 = EndPtr;
    *(_QWORD *)(a1 + 24) = EndPtr + 1;
    if ( !v6 )
    {
      *(_DWORD *)(a1 + 56) = **(_DWORD **)(a1 + 24i64 * v7 + 1168);
      return 1;
    }
    if ( v7 < 0 || *v8 != 36 || v7 >= 100 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v9 = *(_DWORD *)(a1 + 3560);
    v10 = *(_DWORD *)(a1 + 60);
    LOBYTE(v5) = *(_BYTE *)(a1 + 65);
    if ( v7 > v9 )
      v9 = v7;
    *(_DWORD *)(a1 + 3560) = v9;
    v11 = a1 + 8 * (v7 + 2i64 * v7 + 145);
    if ( *(_DWORD *)v11 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v11, 1, v5, v10) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v3;
      }
    }
    else
    {
      *(_DWORD *)v11 = 1;
      *(_BYTE *)(v11 + 4) = v5;
      *(_DWORD *)(v11 + 16) = v10;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 140039503: variable 'v5' is possibly undefined
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140039554) ----------------------------------------------------
char __fastcall sub_140039554(__int64 a1)
{
  const wchar_t *v2; // rcx
  char v3; // di
  int v4; // eax
  bool v5; // zf
  int v6; // edx
  wchar_t *v7; // rax
  int v8; // eax
  int v9; // r8d
  int v10; // r9d
  __int64 v11; // rdx
  wchar_t *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(const wchar_t **)(a1 + 24);
    v3 = 0;
    EndPtr = 0i64;
    v4 = wcstol(v2, &EndPtr, 10);
    v5 = *(_DWORD *)(a1 + 1144) == 1;
    v6 = v4 - 1;
    v7 = EndPtr;
    *(_QWORD *)(a1 + 24) = EndPtr + 1;
    if ( !v5 )
    {
      *(_DWORD *)(a1 + 56) = **(_DWORD **)(a1 + 24i64 * v6 + 1168);
      return 1;
    }
    if ( v6 < 0 || *v7 != 36 || v6 >= 100 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v8 = *(_DWORD *)(a1 + 3560);
    v9 = *(_DWORD *)(a1 + 60);
    v10 = *(unsigned __int16 *)(a1 + 66);
    if ( v6 > v8 )
      v8 = v6;
    *(_DWORD *)(a1 + 3560) = v8;
    v11 = a1 + 8 * (v6 + 2i64 * v6 + 145);
    if ( *(_DWORD *)v11 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v11, 1, v10, v9) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v3;
      }
    }
    else
    {
      *(_DWORD *)v11 = 1;
      *(_WORD *)(v11 + 4) = v10;
      *(_DWORD *)(v11 + 16) = v9;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003966C) ----------------------------------------------------
char __fastcall sub_14003966C(__int64 a1)
{
  const wchar_t *v2; // rcx
  char v3; // di
  int v4; // eax
  bool v5; // zf
  int v6; // edx
  wchar_t *v7; // rax
  int v8; // eax
  int v9; // r8d
  int v10; // r9d
  __int64 v11; // rdx
  wchar_t *EndPtr; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 1148) != 1 )
  {
    v2 = *(const wchar_t **)(a1 + 24);
    v3 = 0;
    EndPtr = 0i64;
    v4 = wcstol(v2, &EndPtr, 10);
    v5 = *(_DWORD *)(a1 + 1144) == 1;
    v6 = v4 - 1;
    v7 = EndPtr;
    *(_QWORD *)(a1 + 24) = EndPtr + 1;
    if ( !v5 )
    {
      *(_DWORD *)(a1 + 56) = **(_DWORD **)(a1 + 24i64 * v6 + 1168);
      return 1;
    }
    if ( v6 < 0 || *v7 != 36 || v6 >= 100 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v8 = *(_DWORD *)(a1 + 3560);
    v9 = *(_DWORD *)(a1 + 60);
    v10 = *(unsigned __int16 *)(a1 + 66);
    if ( v6 > v8 )
      v8 = v6;
    *(_DWORD *)(a1 + 3560) = v8;
    v11 = a1 + 8 * (v6 + 2i64 * v6 + 145);
    if ( *(_DWORD *)v11 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v11, 1, v10, v9) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v3;
      }
    }
    else
    {
      *(_DWORD *)v11 = 1;
      *(_WORD *)(v11 + 4) = v10;
      *(_DWORD *)(v11 + 16) = v9;
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) += 8i64;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140039884) ----------------------------------------------------
char __fastcall sub_140039884(int a1, __int64 a2, int a3, char a4, int a5)
{
  if ( !*(_DWORD *)a2 )
  {
    *(_DWORD *)a2 = a3;
    *(_BYTE *)(a2 + 4) = a4;
    *(_DWORD *)(a2 + 16) = a5;
    return 1;
  }
  if ( (unsigned __int8)unknown_libname_503(a1, a2, a3, a4, a5) )
    return 1;
  *errno() = 22;
  invalid_parameter_noinfo();
  return 0;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400398C4) ----------------------------------------------------
char __fastcall sub_1400398C4(int a1, __int64 a2, int a3, char a4, int a5)
{
  if ( !*(_DWORD *)a2 )
  {
    *(_DWORD *)a2 = a3;
    *(_BYTE *)(a2 + 4) = a4;
    *(_DWORD *)(a2 + 16) = a5;
    return 1;
  }
  if ( (unsigned __int8)unknown_libname_504(a1, a2, a3, a4, a5) )
    return 1;
  *errno() = 22;
  invalid_parameter_noinfo();
  return 0;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140039904) ----------------------------------------------------
char __fastcall sub_140039904(int a1, __int64 a2, int a3, __int16 a4, int a5)
{
  if ( !*(_DWORD *)a2 )
  {
    *(_DWORD *)a2 = a3;
    *(_WORD *)(a2 + 4) = a4;
    *(_DWORD *)(a2 + 16) = a5;
    return 1;
  }
  if ( (unsigned __int8)unknown_libname_505(a1, a2, a3, a4, a5) )
    return 1;
  *errno() = 22;
  invalid_parameter_noinfo();
  return 0;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140039944) ----------------------------------------------------
char __fastcall sub_140039944(int a1, __int64 a2, int a3, __int16 a4, int a5)
{
  if ( !*(_DWORD *)a2 )
  {
    *(_DWORD *)a2 = a3;
    *(_WORD *)(a2 + 4) = a4;
    *(_DWORD *)(a2 + 16) = a5;
    return 1;
  }
  if ( (unsigned __int8)unknown_libname_506(a1, a2, a3, a4, a5) )
    return 1;
  *errno() = 22;
  invalid_parameter_noinfo();
  return 0;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140039DAC) ----------------------------------------------------
char sub_140039DAC()
{
  return 1;
}

//----- (0000000140039DB0) ----------------------------------------------------
char sub_140039DB0()
{
  return 1;
}

//----- (0000000140039DB4) ----------------------------------------------------
char sub_140039DB4()
{
  return 1;
}

//----- (0000000140039DB8) ----------------------------------------------------
char sub_140039DB8()
{
  return 1;
}

//----- (000000014003A09C) ----------------------------------------------------
char sub_14003A09C()
{
  return 1;
}

//----- (000000014003A0A0) ----------------------------------------------------
char sub_14003A0A0()
{
  return 1;
}

//----- (000000014003A0A4) ----------------------------------------------------
char sub_14003A0A4()
{
  return 1;
}

//----- (000000014003A0A8) ----------------------------------------------------
char sub_14003A0A8()
{
  return 1;
}

//----- (000000014003A0AC) ----------------------------------------------------
char __fastcall sub_14003A0AC(__int64 a1)
{
  __int64 v1; // rax
  int v3; // r8d
  char v4; // r9
  char v5; // bl
  __int64 v6; // rdx

  if ( *(_DWORD *)(a1 + 1148) == 2 && *(_DWORD *)(a1 + 1144) == 1 )
  {
    v1 = *(int *)(a1 + 3564);
    if ( (unsigned int)v1 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v3 = *(_DWORD *)(a1 + 60);
    v4 = *(_BYTE *)(a1 + 65);
    v5 = 0;
    v6 = a1 + 8 * (v1 + 2 * v1 + 145);
    if ( *(_DWORD *)v6 )
    {
      if ( !(unsigned __int8)unknown_libname_503(a1, v6, 4, v4, v3) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v5;
      }
    }
    else
    {
      *(_DWORD *)v6 = 4;
      *(_BYTE *)(v6 + 4) = v4;
      *(_DWORD *)(v6 + 16) = v3;
    }
    return 1;
  }
  return 1;
}
// 14002BC30: using guessed type __int64 __fastcall unknown_libname_503(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003A148) ----------------------------------------------------
char __fastcall sub_14003A148(__int64 a1)
{
  __int64 v1; // rax
  int v3; // r8d
  char v4; // r9
  char v5; // bl
  __int64 v6; // rdx

  if ( *(_DWORD *)(a1 + 1148) == 2 && *(_DWORD *)(a1 + 1144) == 1 )
  {
    v1 = *(int *)(a1 + 3564);
    if ( (unsigned int)v1 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v3 = *(_DWORD *)(a1 + 60);
    v4 = *(_BYTE *)(a1 + 65);
    v5 = 0;
    v6 = a1 + 8 * (v1 + 2 * v1 + 145);
    if ( *(_DWORD *)v6 )
    {
      if ( !(unsigned __int8)unknown_libname_504(a1, v6, 4, v4, v3) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v5;
      }
    }
    else
    {
      *(_DWORD *)v6 = 4;
      *(_BYTE *)(v6 + 4) = v4;
      *(_DWORD *)(v6 + 16) = v3;
    }
    return 1;
  }
  return 1;
}
// 14002BE20: using guessed type __int64 __fastcall unknown_libname_504(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003A1E4) ----------------------------------------------------
char __fastcall sub_14003A1E4(__int64 a1)
{
  __int64 v1; // rax
  int v3; // r8d
  int v4; // r9d
  char v5; // bl
  __int64 v6; // rdx

  if ( *(_DWORD *)(a1 + 1148) == 2 && *(_DWORD *)(a1 + 1144) == 1 )
  {
    v1 = *(int *)(a1 + 3564);
    if ( (unsigned int)v1 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v3 = *(_DWORD *)(a1 + 60);
    v4 = *(unsigned __int16 *)(a1 + 66);
    v5 = 0;
    v6 = a1 + 8 * (v1 + 2 * v1 + 145);
    if ( *(_DWORD *)v6 )
    {
      if ( !(unsigned __int8)unknown_libname_505(a1, v6, 4, v4, v3) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v5;
      }
    }
    else
    {
      *(_DWORD *)v6 = 4;
      *(_WORD *)(v6 + 4) = v4;
      *(_DWORD *)(v6 + 16) = v3;
    }
    return 1;
  }
  return 1;
}
// 14002C010: using guessed type __int64 __fastcall unknown_libname_505(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003A284) ----------------------------------------------------
char __fastcall sub_14003A284(__int64 a1)
{
  __int64 v1; // rax
  int v3; // r8d
  int v4; // r9d
  char v5; // bl
  __int64 v6; // rdx

  if ( *(_DWORD *)(a1 + 1148) == 2 && *(_DWORD *)(a1 + 1144) == 1 )
  {
    v1 = *(int *)(a1 + 3564);
    if ( (unsigned int)v1 > 0x63 )
    {
      *errno() = 22;
      invalid_parameter_noinfo();
      return 0;
    }
    v3 = *(_DWORD *)(a1 + 60);
    v4 = *(unsigned __int16 *)(a1 + 66);
    v5 = 0;
    v6 = a1 + 8 * (v1 + 2 * v1 + 145);
    if ( *(_DWORD *)v6 )
    {
      if ( !(unsigned __int8)unknown_libname_506(a1, v6, 4, v4, v3) )
      {
        *errno() = 22;
        invalid_parameter_noinfo();
        return v5;
      }
    }
    else
    {
      *(_DWORD *)v6 = 4;
      *(_WORD *)(v6 + 4) = v4;
      *(_DWORD *)(v6 + 16) = v3;
    }
    return 1;
  }
  return 1;
}
// 14002C218: using guessed type __int64 __fastcall unknown_libname_506(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014003A324) ----------------------------------------------------
char sub_14003A324()
{
  return 1;
}

//----- (000000014003A328) ----------------------------------------------------
char sub_14003A328()
{
  return 1;
}

//----- (000000014003A32C) ----------------------------------------------------
char sub_14003A32C()
{
  return 1;
}

//----- (000000014003A330) ----------------------------------------------------
char sub_14003A330()
{
  return 1;
}

//----- (000000014003A3C0) ----------------------------------------------------
char sub_14003A3C0()
{
  return 1;
}

//----- (000000014003A3C4) ----------------------------------------------------
const wchar_t *sub_14003A3C4()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A3CC) ----------------------------------------------------
const wchar_t *sub_14003A3CC()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A3D4) ----------------------------------------------------
const wchar_t *sub_14003A3D4()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A3DC) ----------------------------------------------------
const wchar_t *sub_14003A3DC()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A3E4) ----------------------------------------------------
const wchar_t *sub_14003A3E4()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A3EC) ----------------------------------------------------
const wchar_t *sub_14003A3EC()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A3F4) ----------------------------------------------------
const wchar_t *sub_14003A3F4()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A3FC) ----------------------------------------------------
const wchar_t *sub_14003A3FC()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A404) ----------------------------------------------------
const wchar_t *sub_14003A404()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A40C) ----------------------------------------------------
const wchar_t *sub_14003A40C()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A414) ----------------------------------------------------
const wchar_t *sub_14003A414()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003A41C) ----------------------------------------------------
const wchar_t *sub_14003A41C()
{
  return L"(null)";
}
// 14007E868: using guessed type wchar_t aNull_1[7];

//----- (000000014003B384) ----------------------------------------------------
__int64 __fastcall sub_14003B384(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v11 = a4;
  v13 = a3;
  v10 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             &a5,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140024AB4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003B410) ----------------------------------------------------
__int64 __fastcall sub_14003B410(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v11 = a4;
  v13 = a3;
  v10 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             &a5,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 1400249B4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003B49C) ----------------------------------------------------
__int64 __fastcall sub_14003B49C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v11 = a4;
  v13 = a3;
  v10 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             &a5,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140024A34: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003B528) ----------------------------------------------------
__int64 __fastcall sub_14003B528(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v11 = a4;
  v13 = a3;
  v10 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             &a5,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140024A74: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003B5B4) ----------------------------------------------------
__int64 __fastcall sub_14003B5B4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v11 = a4;
  v13 = a3;
  v10 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             &a5,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140024AF4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003B640) ----------------------------------------------------
__int64 __fastcall sub_14003B640(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v11 = a4;
  v13 = a3;
  v10 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             &a5,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 1400249F4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003C374) ----------------------------------------------------
__int64 __fastcall sub_14003C374(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014003C864) ----------------------------------------------------
__int64 __fastcall sub_14003C864(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014003D760) ----------------------------------------------------
__int64 __fastcall sub_14003D760(int a1)
{
  return (unsigned int)(a1 + 32);
}

//----- (000000014003D8A4) ----------------------------------------------------
__int64 __fastcall sub_14003D8A4(int a1)
{
  return (unsigned int)(a1 - 32);
}

//----- (000000014003DE1C) ----------------------------------------------------
__int64 __fastcall sub_14003DE1C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014003F450) ----------------------------------------------------
__int64 __fastcall sub_14003F450(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_664(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(a4);
}
// 14003DF54: using guessed type __int64 __fastcall unknown_libname_664(_QWORD, _QWORD, _QWORD);
// 14003F450: using guessed type char var_18[24];

//----- (000000014003F48C) ----------------------------------------------------
__int64 __fastcall sub_14003F48C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_665(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14003DF68: using guessed type __int64 __fastcall unknown_libname_665(_QWORD, _QWORD, _QWORD);
// 14003F48C: using guessed type char var_18[24];

//----- (000000014003F4C8) ----------------------------------------------------
__int64 __fastcall sub_14003F4C8(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_664(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<char>>(a4);
}
// 14003DF54: using guessed type __int64 __fastcall unknown_libname_664(_QWORD, _QWORD, _QWORD);
// 14003F4C8: using guessed type char var_18[24];

//----- (000000014003F504) ----------------------------------------------------
__int64 __fastcall sub_14003F504(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_665(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14003DF68: using guessed type __int64 __fastcall unknown_libname_665(_QWORD, _QWORD, _QWORD);
// 14003F504: using guessed type char var_18[24];

//----- (000000014003F840) ----------------------------------------------------
char __fastcall sub_14003F840(_QWORD *a1, __int64 a2)
{
  *a1 = a2;
  return 1;
}

//----- (000000014003F848) ----------------------------------------------------
char __fastcall sub_14003F848(_QWORD *a1, __int64 a2)
{
  *a1 = a2;
  return 1;
}

//----- (000000014003F850) ----------------------------------------------------
__int64 __fastcall sub_14003F850(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014003F854) ----------------------------------------------------
__int64 __fastcall sub_14003F854(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014003FA94) ----------------------------------------------------
__int64 __fastcall sub_14003FA94(__int64 a1)
{
  char v2[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_664(v2, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<char>>(0i64);
}
// 14003DF54: using guessed type __int64 __fastcall unknown_libname_664(_QWORD, _QWORD, _QWORD);
// 14003FA94: using guessed type char var_18[24];

//----- (000000014003FBE8) ----------------------------------------------------
__int64 __fastcall sub_14003FBE8(__int64 a1, struct __crt_locale_pointers *a2)
{
  char v4[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_665(v4, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a2);
}
// 14003DF68: using guessed type __int64 __fastcall unknown_libname_665(_QWORD, _QWORD, _QWORD);
// 14003FBE8: using guessed type char var_18[24];

//----- (000000014003FC1C) ----------------------------------------------------
__int64 __fastcall sub_14003FC1C(__int64 a1, struct __crt_locale_pointers *a2)
{
  char v4[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_665(v4, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<wchar_t>>(a2);
}
// 14003DF68: using guessed type __int64 __fastcall unknown_libname_665(_QWORD, _QWORD, _QWORD);
// 14003FC1C: using guessed type char var_18[24];

//----- (000000014003FC7C) ----------------------------------------------------
__int64 __fastcall sub_14003FC7C(__int64 a1, struct __crt_locale_pointers *a2)
{
  char v4[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_665(v4, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<wchar_t>>(a2);
}
// 14003DF68: using guessed type __int64 __fastcall unknown_libname_665(_QWORD, _QWORD, _QWORD);
// 14003FC7C: using guessed type char var_18[24];

//----- (000000014003FCDC) ----------------------------------------------------
__int64 __fastcall sub_14003FCDC(__int64 a1, struct __crt_locale_pointers *a2)
{
  char v4[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_665(v4, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a2);
}
// 14003DF68: using guessed type __int64 __fastcall unknown_libname_665(_QWORD, _QWORD, _QWORD);
// 14003FCDC: using guessed type char var_18[24];

//----- (000000014003FD10) ----------------------------------------------------
__int64 __fastcall sub_14003FD10(__int64 a1)
{
  char v2[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_664(v2, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(0i64);
}
// 14003DF54: using guessed type __int64 __fastcall unknown_libname_664(_QWORD, _QWORD, _QWORD);
// 14003FD10: using guessed type char var_18[24];

//----- (000000014003FD3C) ----------------------------------------------------
__int64 __fastcall sub_14003FD3C(__int64 a1)
{
  char v2[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_664(v2, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(0i64);
}
// 14003DF54: using guessed type __int64 __fastcall unknown_libname_664(_QWORD, _QWORD, _QWORD);
// 14003FD3C: using guessed type char var_18[24];

//----- (000000014003FD68) ----------------------------------------------------
__int64 __fastcall sub_14003FD68(__int64 a1)
{
  char v2[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_664(v2, a1, 0i64);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<char>>(0i64);
}
// 14003DF54: using guessed type __int64 __fastcall unknown_libname_664(_QWORD, _QWORD, _QWORD);
// 14003FD68: using guessed type char var_18[24];

//----- (00000001400400F0) ----------------------------------------------------
__int64 __fastcall sub_1400400F0(char **a1)
{
  return openfile(*a1);
}

//----- (0000000140040104) ----------------------------------------------------
__int64 __fastcall sub_140040104(wchar_t **a1)
{
  return wopenfile(*a1);
}

//----- (0000000140040118) ----------------------------------------------------
void __fastcall sub_140040118(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (0000000140040128) ----------------------------------------------------
__int64 __fastcall sub_140040128(wchar_t *a1)
{
  return common_fsopen<wchar_t>(a1);
}

//----- (0000000140040624) ----------------------------------------------------
void __fastcall sub_140040624(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (00000001400408C0) ----------------------------------------------------
__int64 __fastcall sub_1400408C0(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140040B88) ----------------------------------------------------
__int64 __fastcall sub_140040B88(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<unsigned __int64>::operator()<_lambda_5d4c3fee44080f75d5d9762853974fe0_,_lambda_532e024f4337e6fc7ad266c2bef9f4ed_ &,_lambda_c87bdc10097eb2402edb8ba9bdf0697b_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140040B48: using guessed type __int64 __fastcall __crt_seh_guarded_call<unsigned __int64>::operator()<_lambda_5d4c3fee44080f75d5d9762853974fe0_,_lambda_532e024f4337e6fc7ad266c2bef9f4ed_ &,_lambda_c87bdc10097eb2402edb8ba9bdf0697b_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140040C44) ----------------------------------------------------
void __fastcall sub_140040C44(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (0000000140040C4C) ----------------------------------------------------
void __fastcall sub_140040C4C(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (00000001400411B8) ----------------------------------------------------
int __fastcall sub_1400411B8(FILE **a1)
{
  return j__fgetc_nolock(*a1);
}

//----- (00000001400411C0) ----------------------------------------------------
wint_t __fastcall sub_1400411C0(FILE **a1)
{
  return j__fgetwc_nolock(*a1);
}

//----- (00000001400411D8) ----------------------------------------------------
void __fastcall sub_1400411D8(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140041260) ----------------------------------------------------
__int64 __fastcall sub_140041260(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140041220: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140041288) ----------------------------------------------------
__int64 __fastcall sub_140041288(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 1400411E0: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400413D0) ----------------------------------------------------
__int64 __fastcall sub_1400413D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v6[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v13 = a4;
  v12 = a3;
  v11 = a2;
  v10 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v13;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v10;
    v9[3] = (__int64)&v12;
    v9[4] = (__int64)&a5;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             v6,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140041220: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400413D0: using guessed type char var_40[8];

//----- (0000000140041458) ----------------------------------------------------
__int64 __fastcall sub_140041458(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v6[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v13 = a4;
  v12 = a3;
  v11 = a2;
  v10 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v13;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v10;
    v9[3] = (__int64)&v12;
    v9[4] = (__int64)&a5;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             v6,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 1400411E0: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 140041458: using guessed type char var_40[8];

//----- (0000000140049E3C) ----------------------------------------------------
unsigned __int64 __fastcall sub_140049E3C(const wchar_t **a1, wchar_t ***a2, int *a3)
{
  return wcstoui64_0(*a1, *a2, *a3);
}

//----- (0000000140049E4C) ----------------------------------------------------
unsigned __int64 __fastcall sub_140049E4C(const char **a1, char ***a2, int *a3)
{
  return strtoui64_0(*a1, *a2, *a3);
}

//----- (0000000140049E68) ----------------------------------------------------
int __fastcall sub_140049E68(int *a1, FILE **a2)
{
  return ungetc_nolock(*a1, *a2);
}

//----- (000000014004A7F8) ----------------------------------------------------
void __fastcall sub_14004A7F8(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014004ABF0) ----------------------------------------------------
void __fastcall sub_14004ABF0(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (000000014004ABF8) ----------------------------------------------------
void __fastcall sub_14004ABF8(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (000000014004AC78) ----------------------------------------------------
void __fastcall sub_14004AC78(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014004DD64) ----------------------------------------------------
__int64 __fastcall sub_14004DD64(__int64 a1)
{
  return a1;
}

//----- (000000014004E2A0) ----------------------------------------------------
__int64 __fastcall sub_14004E2A0(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (000000014004E2A4) ----------------------------------------------------
__int64 __fastcall sub_14004E2A4(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (000000014004E2B8) ----------------------------------------------------
__int64 __fastcall sub_14004E2B8(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014004E664) ----------------------------------------------------
char __fastcall sub_14004E664(__int64 a1)
{
  return *(_BYTE *)(a1 + 8);
}

//----- (000000014004E6F0) ----------------------------------------------------
__int64 __fastcall sub_14004E6F0(__int64 a1)
{
  return *(unsigned int *)(a1 + 20);
}

//----- (000000014004E6F4) ----------------------------------------------------
__int64 __fastcall sub_14004E6F4(__int64 a1)
{
  return *(unsigned int *)(a1 + 20);
}

//----- (000000014004E830) ----------------------------------------------------
char __fastcall sub_14004E830(__int64 a1)
{
  return *(_BYTE *)(a1 + 24);
}

//----- (000000014004E83C) ----------------------------------------------------
char __fastcall sub_14004E83C(__int64 a1)
{
  return *(_BYTE *)(a1 + 25);
}

//----- (000000014004E88C) ----------------------------------------------------
__int64 __fastcall sub_14004E88C(__int64 a1)
{
  return *(unsigned int *)(a1 + 48);
}

//----- (000000014004E890) ----------------------------------------------------
__int64 __fastcall sub_14004E890(__int64 a1)
{
  return *(unsigned int *)(a1 + 48);
}

//----- (0000000140050258) ----------------------------------------------------
char sub_140050258()
{
  return 1;
}

//----- (000000014005025C) ----------------------------------------------------
char sub_14005025C()
{
  return 1;
}

//----- (00000001400513E4) ----------------------------------------------------
char sub_1400513E4()
{
  return 1;
}

//----- (0000000140051B1C) ----------------------------------------------------
char __fastcall sub_140051B1C(__int64 a1)
{
  return *(_BYTE *)(a1 + 26);
}

//----- (0000000140051B20) ----------------------------------------------------
char __fastcall sub_140051B20(__int64 a1)
{
  return *(_BYTE *)(a1 + 28);
}

//----- (0000000140052478) ----------------------------------------------------
__int64 __fastcall sub_140052478(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v10 = a4;
  v13 = a3;
  v11 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             &a5,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 140041220: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140052504) ----------------------------------------------------
__int64 __fastcall sub_140052504(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h] BYREF
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  __int64 v9[5]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v10; // [rsp+70h] [rbp+10h] BYREF
  __int64 v11; // [rsp+78h] [rbp+18h] BYREF
  __int64 v12; // [rsp+80h] [rbp+20h] BYREF
  __int64 v13; // [rsp+88h] [rbp+28h] BYREF

  v6 = a5;
  v10 = a4;
  v13 = a3;
  v11 = a2;
  v12 = a1;
  if ( a2 && a3 )
  {
    v7 = a2;
    v9[0] = (__int64)&v10;
    v8 = a2;
    v9[1] = (__int64)&v11;
    v9[2] = (__int64)&v12;
    v9[3] = (__int64)&v13;
    v9[4] = (__int64)&v6;
    return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
             &a5,
             &v8,
             v9,
             &v7);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
}
// 1400411E0: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140052D24) ----------------------------------------------------
__int64 __fastcall sub_140052D24(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  __int64 v4; // [rsp+40h] [rbp+18h] BYREF
  __int64 v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140052CE4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_,_lambda_9a20e10065b92b5193c3597a66cba9d4_ &,_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140052D7C) ----------------------------------------------------
void __fastcall sub_140052D7C(__int64 *a1)
{
  sub_1400242F0(*a1);
}

//----- (0000000140052D84) ----------------------------------------------------
void __fastcall sub_140052D84(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (00000001400533AC) ----------------------------------------------------
__int64 sub_1400533AC()
{
  return (unsigned int)dword_14009BA1C;
}
// 14009BA1C: using guessed type int dword_14009BA1C;

//----- (00000001400533B4) ----------------------------------------------------
void __fastcall sub_1400533B4(int a1)
{
  dword_14009BA1C = a1;
}
// 14009BA1C: using guessed type int dword_14009BA1C;

//----- (000000014005342C) ----------------------------------------------------
__int64 __fastcall sub_14005342C(__int64 a1)
{
  return a1;
}

//----- (0000000140053450) ----------------------------------------------------
void __fastcall sub_140053450(__int64 a1)
{
  qword_14009C048 = a1;
}
// 14009C048: using guessed type __int64 qword_14009C048;

//----- (00000001400534C8) ----------------------------------------------------
void __fastcall sub_1400534C8(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (00000001400534D0) ----------------------------------------------------
void __fastcall sub_1400534D0(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140053B20) ----------------------------------------------------
__int64 __fastcall sub_140053B20(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  qword_14009CC20 = *a1;
  return result;
}
// 14009CC20: using guessed type __int64 qword_14009CC20;

//----- (0000000140053B2C) ----------------------------------------------------
__int64 __fastcall sub_140053B2C(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  qword_14009CC28 = *a1;
  return result;
}
// 14009CC28: using guessed type __int64 qword_14009CC28;

//----- (0000000140053BFC) ----------------------------------------------------
__int64 __fastcall sub_140053BFC(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140053C00) ----------------------------------------------------
__int64 __fastcall sub_140053C00(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140053C04) ----------------------------------------------------
__int64 __fastcall sub_140053C04(__int64 a1)
{
  return a1;
}

//----- (0000000140053C08) ----------------------------------------------------
__int64 __fastcall sub_140053C08(__int64 a1)
{
  return a1;
}

//----- (0000000140053C0C) ----------------------------------------------------
void **sub_140053C0C()
{
  return &qword_14009CC00;
}

//----- (0000000140053C14) ----------------------------------------------------
void **sub_140053C14()
{
  return &qword_14009CC08;
}

//----- (0000000140053C1C) ----------------------------------------------------
__int64 sub_140053C1C()
{
  return qword_14009CC10;
}
// 14009CC10: using guessed type __int64 qword_14009CC10;

//----- (0000000140053C24) ----------------------------------------------------
__int64 sub_140053C24()
{
  return qword_14009CC18;
}
// 14009CC18: using guessed type __int64 qword_14009CC18;

//----- (0000000140053FD0) ----------------------------------------------------
void __fastcall sub_140053FD0(__int64 a1)
{
  qword_14009CC20 = a1;
}
// 14009CC20: using guessed type __int64 qword_14009CC20;

//----- (0000000140053FD8) ----------------------------------------------------
void __fastcall sub_140053FD8(__int64 a1)
{
  qword_14009CC28 = a1;
}
// 14009CC28: using guessed type __int64 qword_14009CC28;

//----- (0000000140053FE0) ----------------------------------------------------
void __fastcall sub_140053FE0(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140054030) ----------------------------------------------------
void *sub_140054030()
{
  void *result; // rax
  int v1; // eax
  void *v2; // rcx

  result = qword_14009C370;
  if ( !qword_14009C370 )
  {
    if ( !qword_14009C378 || (unsigned int)common_initialize_environment_nolock<char>() )
    {
      return 0i64;
    }
    else
    {
      v1 = initialize_environment_by_cloning_nolock<char>();
      v2 = qword_14009C370;
      if ( v1 )
        return 0i64;
      return v2;
    }
  }
  return result;
}
// 1400540C0: using guessed type __int64 common_initialize_environment_nolock<char>(void);
// 140054484: using guessed type __int64 initialize_environment_by_cloning_nolock<char>(void);

//----- (0000000140054078) ----------------------------------------------------
void *sub_140054078()
{
  void *result; // rax
  int v1; // eax
  void *v2; // rcx

  result = qword_14009C378;
  if ( !qword_14009C378 )
  {
    if ( !qword_14009C370 || (unsigned int)common_initialize_environment_nolock<wchar_t>() )
    {
      return 0i64;
    }
    else
    {
      v1 = initialize_environment_by_cloning_nolock<wchar_t>();
      v2 = qword_14009C378;
      if ( v1 )
        return 0i64;
      return v2;
    }
  }
  return result;
}
// 14005412C: using guessed type __int64 common_initialize_environment_nolock<wchar_t>(void);
// 140054558: using guessed type __int64 initialize_environment_by_cloning_nolock<wchar_t>(void);

//----- (0000000140054608) ----------------------------------------------------
__int64 __fastcall sub_140054608(char **a1)
{
  return common_set_variable_in_environment_nolock<char>(*a1);
}

//----- (0000000140054614) ----------------------------------------------------
__int64 __fastcall sub_140054614(wchar_t **a1)
{
  return common_set_variable_in_environment_nolock<wchar_t>(*a1);
}

//----- (0000000140054620) ----------------------------------------------------
errno_t __fastcall sub_140054620(char **a1, rsize_t *a2, const char **a3)
{
  return strcpy_s(*a1, *a2, *a3);
}

//----- (0000000140054630) ----------------------------------------------------
errno_t __fastcall sub_140054630(wchar_t **a1, rsize_t *a2, const wchar_t **a3)
{
  return wcscpy_s(*a1, *a2, *a3);
}

//----- (00000001400546F8) ----------------------------------------------------
__int64 __fastcall sub_1400546F8(void **a1)
{
  void *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != qword_14009C388 )
    return unknown_libname_785(v1);
  return result;
}

//----- (0000000140054714) ----------------------------------------------------
__int64 __fastcall sub_140054714(void **a1)
{
  void *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != qword_14009C380 )
    return unknown_libname_786(v1);
  return result;
}

//----- (000000014005482C) ----------------------------------------------------
__int64 __fastcall sub_14005482C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140054830) ----------------------------------------------------
void **sub_140054830()
{
  return &qword_14009C370;
}

//----- (0000000140054838) ----------------------------------------------------
void **sub_140054838()
{
  return &qword_14009C378;
}

//----- (0000000140054840) ----------------------------------------------------
void **sub_140054840()
{
  return &qword_14009C370;
}

//----- (0000000140054848) ----------------------------------------------------
void **sub_140054848()
{
  return &qword_14009C378;
}

//----- (0000000140054850) ----------------------------------------------------
void **sub_140054850()
{
  return &qword_14009C388;
}

//----- (0000000140054858) ----------------------------------------------------
void **sub_140054858()
{
  return &qword_14009C380;
}

//----- (0000000140054914) ----------------------------------------------------
__int64 __fastcall sub_140054914(__int64 a1)
{
  return a1;
}

//----- (0000000140054918) ----------------------------------------------------
__int64 __fastcall sub_140054918(__int64 a1)
{
  return a1;
}

//----- (0000000140054964) ----------------------------------------------------
void **sub_140054964()
{
  return &qword_14009C370;
}

//----- (000000014005496C) ----------------------------------------------------
void **sub_14005496C()
{
  return &qword_14009C378;
}

//----- (0000000140054A98) ----------------------------------------------------
__int64 sub_140054A98()
{
  return qword_14009CC10;
}
// 14009CC10: using guessed type __int64 qword_14009CC10;

//----- (0000000140054AA0) ----------------------------------------------------
__int64 sub_140054AA0()
{
  return qword_14009CC18;
}
// 14009CC18: using guessed type __int64 qword_14009CC18;

//----- (0000000140054C48) ----------------------------------------------------
__int64 __fastcall sub_140054C48(unsigned int *a1)
{
  return *a1;
}

//----- (0000000140054C4C) ----------------------------------------------------
__int64 __fastcall sub_140054C4C(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_14009CC30;
    return 0i64;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 22i64;
  }
}
// 14009CC30: using guessed type int dword_14009CC30;

//----- (0000000140054E94) ----------------------------------------------------
__int64 sub_140054E94()
{
  return 0i64;
}

//----- (0000000140054E98) ----------------------------------------------------
void __fastcall sub_140054E98(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140054EA0) ----------------------------------------------------
void __fastcall sub_140054EA0(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140054EA8) ----------------------------------------------------
void __fastcall sub_140054EA8(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (000000014005509C) ----------------------------------------------------
__int64 __fastcall sub_14005509C(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_ede63489d7330338e618311e15f0c366_,_lambda_176e34f99554166dd2fac165c457248c_ &,_lambda_b0463272cb7667df9361a74a62ea8ca5_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 14005505C: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_ede63489d7330338e618311e15f0c366_,_lambda_176e34f99554166dd2fac165c457248c_ &,_lambda_b0463272cb7667df9361a74a62ea8ca5_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400550C4) ----------------------------------------------------
__int64 __fastcall sub_1400550C4(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_d67e8342c384adda8f857579ab50b2ae_,_lambda_30712929f77e709619002f448b6a9510_ &,_lambda_4525336fd7e478d965fb7ca7a337cad8_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140054F20: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_d67e8342c384adda8f857579ab50b2ae_,_lambda_30712929f77e709619002f448b6a9510_ &,_lambda_4525336fd7e478d965fb7ca7a337cad8_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400550EC) ----------------------------------------------------
__int64 __fastcall sub_1400550EC(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_3e0436e1742da57cd73032a8c01babf8_,_lambda_b7fb1a997d3ebc0cc0186c5835178808_ &,_lambda_eece23d6871d1810c6784d81edd5a05e_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140054EB0: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_3e0436e1742da57cd73032a8c01babf8_,_lambda_b7fb1a997d3ebc0cc0186c5835178808_ &,_lambda_eece23d6871d1810c6784d81edd5a05e_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140055260) ----------------------------------------------------
void __fastcall sub_140055260(__int64 a1)
{
  void *v2; // rbx
  __int64 v3[7]; // [rsp+20h] [rbp-38h] BYREF
  char v4; // [rsp+60h] [rbp+8h] BYREF
  int v5; // [rsp+68h] [rbp+10h] BYREF
  int v6; // [rsp+70h] [rbp+18h] BYREF

  v2 = calloc_base(1ui64, 0x158ui64);
  **(_QWORD **)a1 = v2;
  free_base(0i64);
  if ( v2 )
  {
    v3[0] = *(_QWORD *)a1;
    v3[1] = *(_QWORD *)(a1 + 8);
    v3[2] = *(_QWORD *)(a1 + 16);
    v3[3] = *(_QWORD *)(a1 + 24);
    v3[4] = *(_QWORD *)(a1 + 32);
    v5 = 4;
    v6 = 4;
    __crt_seh_guarded_call<void>::operator()<_lambda_d67e8342c384adda8f857579ab50b2ae_,_lambda_30712929f77e709619002f448b6a9510_ &,_lambda_4525336fd7e478d965fb7ca7a337cad8_>(
      &v4,
      &v6,
      v3,
      &v5);
  }
}
// 140054F20: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_d67e8342c384adda8f857579ab50b2ae_,_lambda_30712929f77e709619002f448b6a9510_ &,_lambda_4525336fd7e478d965fb7ca7a337cad8_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140055410) ----------------------------------------------------
void __fastcall sub_140055410(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140055418) ----------------------------------------------------
void __fastcall sub_140055418(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140055424) ----------------------------------------------------
void __fastcall sub_140055424(int *a1)
{
  sub_140058810(*a1);
}

//----- (000000014005543C) ----------------------------------------------------
void __fastcall sub_14005543C(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140055444) ----------------------------------------------------
void __fastcall sub_140055444(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (000000014005544C) ----------------------------------------------------
void __fastcall sub_14005544C(int *a1)
{
  sub_140058810(*a1);
}

//----- (000000014005547C) ----------------------------------------------------
__int64 __fastcall sub_14005547C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140055480) ----------------------------------------------------
__int64 __fastcall sub_140055480(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140055484) ----------------------------------------------------
__int64 __fastcall sub_140055484(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140055500) ----------------------------------------------------
__int64 __fastcall sub_140055500(__int64 a1)
{
  return a1;
}

//----- (0000000140056960) ----------------------------------------------------
__int64 __fastcall sub_140056960(__int64 a1)
{
  return a1;
}

//----- (0000000140056964) ----------------------------------------------------
__int64 sub_140056964()
{
  return (unsigned int)dword_14009C39C;
}
// 14009C39C: using guessed type int dword_14009C39C;

//----- (0000000140056998) ----------------------------------------------------
int *sub_140056998()
{
  return &dword_14009C3A0;
}
// 14009C3A0: using guessed type int dword_14009C3A0;

//----- (00000001400569BC) ----------------------------------------------------
void __fastcall sub_1400569BC(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140056BA0) ----------------------------------------------------
__int64 __fastcall sub_140056BA0(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_e24bbb7b643b32fcea6fa61b31d4c984_,_lambda_275893d493268fdec8709772e3fcec0e_ &,_lambda_9d71df4d7cf3f480f8d633942495c3b0_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140056A00: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_e24bbb7b643b32fcea6fa61b31d4c984_,_lambda_275893d493268fdec8709772e3fcec0e_ &,_lambda_9d71df4d7cf3f480f8d633942495c3b0_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140056BC8) ----------------------------------------------------
__int64 __fastcall sub_140056BC8(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_b8c45f8f788dd370798f47cfe8ac3a86_,_lambda_4e60a939b0d047cfe11ddc22648dfba9_ &,_lambda_332c3edc96d0294ec56c57d38c1cdfd5_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 1400569C4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_b8c45f8f788dd370798f47cfe8ac3a86_,_lambda_4e60a939b0d047cfe11ddc22648dfba9_ &,_lambda_332c3edc96d0294ec56c57d38c1cdfd5_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140056DB8) ----------------------------------------------------
void __fastcall sub_140056DB8(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140056F9C) ----------------------------------------------------
void __fastcall sub_140056F9C(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140056FA4) ----------------------------------------------------
void __fastcall sub_140056FA4(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140056FAC) ----------------------------------------------------
void __fastcall sub_140056FAC(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140056FE8) ----------------------------------------------------
int __fastcall sub_140056FE8(_onexit_t Function)
{
  return register_onexit_function(&stru_14009C3A8, Function);
}

//----- (00000001400570F4) ----------------------------------------------------
char sub_1400570F4()
{
  return 1;
}

//----- (00000001400570F8) ----------------------------------------------------
char sub_1400570F8()
{
  return 1;
}

//----- (000000014005710C) ----------------------------------------------------
char sub_14005710C()
{
  return 1;
}

//----- (0000000140057110) ----------------------------------------------------
char sub_140057110()
{
  return 1;
}

//----- (0000000140057168) ----------------------------------------------------
__vcrt_bool sub_140057168()
{
  return _vcrt_uninitialize(0);
}

//----- (0000000140057200) ----------------------------------------------------
char sub_140057200()
{
  return 1;
}

//----- (0000000140057568) ----------------------------------------------------
__int64 __fastcall sub_140057568(__int64 a1)
{
  return a1;
}

//----- (00000001400576C8) ----------------------------------------------------
void __fastcall sub_1400576C8(__int64 a1)
{
  qword_14009C3D8 = a1;
}
// 14009C3D8: using guessed type __int64 qword_14009C3D8;

//----- (0000000140057B34) ----------------------------------------------------
void __fastcall sub_140057B34(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140057C64) ----------------------------------------------------
__int64 __fastcall sub_140057C64(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_46352004c1216016012b18bd6f87e700_,_lambda_3bd07e1a1191394380780325891bf33f_ &,_lambda_334532d3f185bcaa59b5be82d7d22bff_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140057B3C: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_46352004c1216016012b18bd6f87e700_,_lambda_3bd07e1a1191394380780325891bf33f_ &,_lambda_334532d3f185bcaa59b5be82d7d22bff_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140057C8C) ----------------------------------------------------
__int64 __fastcall sub_140057C8C(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_5e887d1dcbef67a5eb4283622ba103bf_,_lambda_4466841279450cc726390878d4a41900_ &,_lambda_341c25c0346d94847f1f3c463c57e077_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140057B9C: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_5e887d1dcbef67a5eb4283622ba103bf_,_lambda_4466841279450cc726390878d4a41900_ &,_lambda_341c25c0346d94847f1f3c463c57e077_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140057CB4) ----------------------------------------------------
__int64 __fastcall sub_140057CB4(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_fb3a7dec4e47f37f22dae91bb15c9095_,_lambda_698284760c8add0bfb0756c19673e34b_ &,_lambda_dfb8eca1e75fef3034a8fb18dd509707_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140057C24: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_fb3a7dec4e47f37f22dae91bb15c9095_,_lambda_698284760c8add0bfb0756c19673e34b_ &,_lambda_dfb8eca1e75fef3034a8fb18dd509707_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140057CDC) ----------------------------------------------------
__int64 __fastcall sub_140057CDC(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_72d1df2b273a38828b1ce30cbf4cdab5_,_lambda_876a65b173b8412d3a47c70a915b0cf4_ &,_lambda_41932305e351933ebe8f8be3ed8bb5dc_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140057BE4: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_72d1df2b273a38828b1ce30cbf4cdab5_,_lambda_876a65b173b8412d3a47c70a915b0cf4_ &,_lambda_41932305e351933ebe8f8be3ed8bb5dc_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140057DA8) ----------------------------------------------------
void __fastcall sub_140057DA8(DWORD *a1)
{
  SetLastError(*a1);
}

//----- (0000000140057DC0) ----------------------------------------------------
void __fastcall sub_140057DC0(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140057DC8) ----------------------------------------------------
void __fastcall sub_140057DC8(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140057E08) ----------------------------------------------------
void __fastcall sub_140057E08(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140057E28) ----------------------------------------------------
void __fastcall sub_140057E28(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140057E30) ----------------------------------------------------
void __fastcall sub_140057E30(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140057E48) ----------------------------------------------------
void __fastcall sub_140057E48(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140057E64) ----------------------------------------------------
void __fastcall sub_140057E64(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140057E6C) ----------------------------------------------------
void __fastcall sub_140057E6C(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (000000014005800C) ----------------------------------------------------
__int64 __fastcall sub_14005800C(__int64 a1)
{
  return a1;
}

//----- (0000000140058228) ----------------------------------------------------
__int64 __fastcall sub_140058228(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001400585C0) ----------------------------------------------------
__int64 __fastcall sub_1400585C0(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = qword_14009C3E0;
  if ( *a2 != qword_14009C3E0 )
  {
    result = *(unsigned int *)(a1 + 936);
    if ( ((unsigned int)result & dword_1400933E8) == 0 )
    {
      result = _acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 140067888: using guessed type __int64 _acrt_update_thread_locale_data(void);
// 1400933E8: using guessed type int dword_1400933E8;
// 14009C3E0: using guessed type __int64 qword_14009C3E0;

//----- (00000001400585F4) ----------------------------------------------------
__int64 __fastcall sub_1400585F4(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = (__int64)off_140093028;
  if ( (void *)*a2 != off_140093028 )
  {
    result = *(unsigned int *)(a1 + 936);
    if ( ((unsigned int)result & dword_1400933E8) == 0 )
    {
      result = _acrt_update_thread_multibyte_data();
      *a2 = result;
    }
  }
  return result;
}
// 140064058: using guessed type __int64 _acrt_update_thread_multibyte_data(void);
// 1400933E8: using guessed type int dword_1400933E8;

//----- (0000000140058658) ----------------------------------------------------
__int64 __fastcall sub_140058658(volatile __int64 *a1, __int64 a2)
{
  return _InterlockedExchange64(a1, a2);
}

//----- (0000000140058660) ----------------------------------------------------
HANDLE sub_140058660()
{
  return hHeap;
}

//----- (00000001400587BC) ----------------------------------------------------
void __fastcall sub_1400587BC(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)&unk_14009C3F0 + a1);
}

//----- (0000000140058810) ----------------------------------------------------
void __fastcall sub_140058810(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)&unk_14009C3F0 + a1);
}

//----- (000000014005882C) ----------------------------------------------------
void sub_14005882C()
{
  EnterCriticalSection((LPCRITICAL_SECTION)&unk_14009C490);
}

//----- (000000014005883C) ----------------------------------------------------
void sub_14005883C()
{
  LeaveCriticalSection((LPCRITICAL_SECTION)&unk_14009C490);
}

//----- (0000000140058944) ----------------------------------------------------
__int64 __fastcall sub_140058944(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_630b2aca97f6d20d5b5ea6529ea6b6af_,_lambda_af91936f1d075d609f72d9d8cba980af_ &,_lambda_e82fa975f615b5c7c7b0e4d178fdae67_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 1400588AC: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_630b2aca97f6d20d5b5ea6529ea6b6af_,_lambda_af91936f1d075d609f72d9d8cba980af_ &,_lambda_e82fa975f615b5c7c7b0e4d178fdae67_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400589BC) ----------------------------------------------------
BOOL (__stdcall *sub_1400589BC())(LPWSTR)
{
  return _lambda_e2bb8337c48846e80c921ea5ddadc92d_::_helper_func_cdecl_;
}

//----- (00000001400589C4) ----------------------------------------------------
void __fastcall sub_1400589C4(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140058A34) ----------------------------------------------------
void __fastcall sub_140058A34(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140058B04) ----------------------------------------------------
__int64 sub_140058B04()
{
  return try_get_function(3i64, "FlsAlloc", &unk_140080B80, "FlsAlloc");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058B24) ----------------------------------------------------
__int64 sub_140058B24()
{
  return try_get_function(4i64, "FlsFree", &unk_140080B98, "FlsFree");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058BC4) ----------------------------------------------------
__int64 sub_140058BC4()
{
  return try_get_function(9i64, "GetDateFormatEx", &unk_140080C10, "GetDateFormatEx");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058BE4) ----------------------------------------------------
__int64 sub_140058BE4()
{
  return try_get_function(10i64, "GetEnabledXStateFeatures", "\v", "GetEnabledXStateFeatures");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058C04) ----------------------------------------------------
__int64 sub_140058C04()
{
  return try_get_function(11i64, "GetFileInformationByHandleEx", &unk_140080C50, "GetFileInformationByHandleEx");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058C24) ----------------------------------------------------
__int64 sub_140058C24()
{
  return try_get_function(12i64, "GetLastActivePopup", &unk_140080C78, "GetLastActivePopup");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058C44) ----------------------------------------------------
__int64 sub_140058C44()
{
  return try_get_function(13i64, "GetLocaleInfoEx", &unk_140080C98, "GetLocaleInfoEx");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058C64) ----------------------------------------------------
__int64 sub_140058C64()
{
  return try_get_function(14i64, "GetProcessWindowStation", &unk_140080CB0, "GetProcessWindowStation");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058C84) ----------------------------------------------------
__int64 sub_140058C84()
{
  return try_get_function(15i64, "GetSystemTimePreciseAsFileTime", "\t", &unk_140080CD4);
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058CA4) ----------------------------------------------------
__int64 sub_140058CA4()
{
  return try_get_function(16i64, "GetTimeFormatEx", &unk_140080CF8, "GetTimeFormatEx");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058CC4) ----------------------------------------------------
__int64 sub_140058CC4()
{
  return try_get_function(17i64, "GetUserDefaultLocaleName", &unk_140080D10, "GetUserDefaultLocaleName");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058CE4) ----------------------------------------------------
__int64 sub_140058CE4()
{
  return try_get_function(18i64, "GetUserObjectInformationW", &unk_140080D38, "GetUserObjectInformationW");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058D04) ----------------------------------------------------
__int64 sub_140058D04()
{
  return try_get_function(19i64, "GetXStateFeaturesMask", "\v", "GetXStateFeaturesMask");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058D24) ----------------------------------------------------
__int64 sub_140058D24()
{
  return try_get_function(20i64, "InitializeCriticalSectionEx", "\b", "InitializeCriticalSectionEx");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058D44) ----------------------------------------------------
__int64 sub_140058D44()
{
  return try_get_function(21i64, "IsValidLocaleName", &unk_140080DA8, "IsValidLocaleName");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058D64) ----------------------------------------------------
__int64 sub_140058D64()
{
  return try_get_function(23i64, "LCIDToLocaleName", &unk_140080DE0, "LCIDToLocaleName");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058D84) ----------------------------------------------------
__int64 sub_140058D84()
{
  return try_get_function(22i64, "LCMapStringEx", &unk_140080DC8, "LCMapStringEx");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058DA4) ----------------------------------------------------
__int64 sub_140058DA4()
{
  return try_get_function(24i64, "LocaleNameToLCID", &unk_140080E00, "LocaleNameToLCID");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058DC4) ----------------------------------------------------
__int64 sub_140058DC4()
{
  return try_get_function(25i64, "LocateXStateFeature", "\v", "LocateXStateFeature");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058DE4) ----------------------------------------------------
__int64 sub_140058DE4()
{
  return try_get_function(26i64, "MessageBoxA", &unk_140080E40, "MessageBoxA");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058E04) ----------------------------------------------------
__int64 sub_140058E04()
{
  return try_get_function(27i64, "MessageBoxW", &unk_140080E58, "MessageBoxW");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058E24) ----------------------------------------------------
__int64 sub_140058E24()
{
  return try_get_function(28i64, "RoInitialize", "\n", "RoInitialize");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058E44) ----------------------------------------------------
__int64 sub_140058E44()
{
  return try_get_function(29i64, "RoUninitialize", "\n", &unk_140080E84);
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058E64) ----------------------------------------------------
__int64 sub_140058E64()
{
  return try_get_function(30i64, "SetThreadStackGuarantee", &unk_140080E98, "SetThreadStackGuarantee");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140058E84) ----------------------------------------------------
__int64 sub_140058E84()
{
  return try_get_function(31i64, "SystemFunction036", "\r", "SystemFunction036");
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140059DF0) ----------------------------------------------------
__int64 __fastcall sub_140059DF0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 (__fastcall *function)(__int64, __int64, __int64, _QWORD); // rax

  function = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))try_get_function(
                                                                          26i64,
                                                                          "MessageBoxA",
                                                                          &unk_140080E40,
                                                                          "MessageBoxA");
  if ( !function )
    abort();
  return function(a1, a2, a3, a4);
}
// 140058F88: using guessed type __int64 __fastcall try_get_function(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014005A788) ----------------------------------------------------
__int64 __fastcall sub_14005A788(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_849(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(a4);
}
// 14005A760: using guessed type __int64 __fastcall unknown_libname_849(_QWORD, _QWORD, _QWORD);
// 14005A788: using guessed type char var_18[24];

//----- (000000014005A7C4) ----------------------------------------------------
__int64 __fastcall sub_14005A7C4(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005A7C4: using guessed type char var_18[24];

//----- (000000014005A83C) ----------------------------------------------------
__int64 __fastcall sub_14005A83C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005A83C: using guessed type char var_18[24];

//----- (000000014005A878) ----------------------------------------------------
__int64 __fastcall sub_14005A878(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_849(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<char>>(a4);
}
// 14005A760: using guessed type __int64 __fastcall unknown_libname_849(_QWORD, _QWORD, _QWORD);
// 14005A878: using guessed type char var_18[24];

//----- (000000014005A8B4) ----------------------------------------------------
__int64 __fastcall sub_14005A8B4(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005A8B4: using guessed type char var_18[24];

//----- (000000014005A92C) ----------------------------------------------------
__int64 __fastcall sub_14005A92C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005A92C: using guessed type char var_18[24];

//----- (000000014005A998) ----------------------------------------------------
__int64 __fastcall sub_14005A998(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_849(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<char>>(a4);
}
// 14005A760: using guessed type __int64 __fastcall unknown_libname_849(_QWORD, _QWORD, _QWORD);
// 14005A998: using guessed type char var_18[24];

//----- (000000014005A9D4) ----------------------------------------------------
__int64 __fastcall sub_14005A9D4(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_849(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<char>>(a4);
}
// 14005A760: using guessed type __int64 __fastcall unknown_libname_849(_QWORD, _QWORD, _QWORD);
// 14005A9D4: using guessed type char var_18[24];

//----- (000000014005AA10) ----------------------------------------------------
__int64 __fastcall sub_14005AA10(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_849(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(a4);
}
// 14005A760: using guessed type __int64 __fastcall unknown_libname_849(_QWORD, _QWORD, _QWORD);
// 14005AA10: using guessed type char var_18[24];

//----- (000000014005AA4C) ----------------------------------------------------
__int64 __fastcall sub_14005AA4C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_849(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<char>>(a4);
}
// 14005A760: using guessed type __int64 __fastcall unknown_libname_849(_QWORD, _QWORD, _QWORD);
// 14005AA4C: using guessed type char var_18[24];

//----- (000000014005ABD8) ----------------------------------------------------
__int64 __fastcall sub_14005ABD8(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005ABD8: using guessed type char var_18[24];

//----- (000000014005AC14) ----------------------------------------------------
__int64 __fastcall sub_14005AC14(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005AC14: using guessed type char var_18[24];

//----- (000000014005AC50) ----------------------------------------------------
__int64 __fastcall sub_14005AC50(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005AC50: using guessed type char var_18[24];

//----- (000000014005AC8C) ----------------------------------------------------
__int64 __fastcall sub_14005AC8C(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005AC8C: using guessed type char var_18[24];

//----- (000000014005ACF8) ----------------------------------------------------
__int64 __fastcall sub_14005ACF8(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005ACF8: using guessed type char var_18[24];

//----- (000000014005AD34) ----------------------------------------------------
__int64 __fastcall sub_14005AD34(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005AD34: using guessed type char var_18[24];

//----- (000000014005AD70) ----------------------------------------------------
__int64 __fastcall sub_14005AD70(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005AD70: using guessed type char var_18[24];

//----- (000000014005ADAC) ----------------------------------------------------
__int64 __fastcall sub_14005ADAC(__int64 a1, __int64 a2, __int64 a3, struct __crt_locale_pointers *a4)
{
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  unknown_libname_850(v6, a1, a2);
  return __crt_strtox::parse_integer<unsigned __int64,__crt_strtox::c_string_character_source<wchar_t>>(a4);
}
// 14005A774: using guessed type __int64 __fastcall unknown_libname_850(_QWORD, _QWORD, _QWORD);
// 14005ADAC: using guessed type char var_18[24];

//----- (000000014005D140) ----------------------------------------------------
__int64 __fastcall sub_14005D140(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_5118a789131033a5646699a06bf2b47a_,_lambda_6c868b97557875bf03ef8ae33acccf48_ &,_lambda_c7e520e7ba699ee0395251f697dddb81_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 14005D100: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_5118a789131033a5646699a06bf2b47a_,_lambda_6c868b97557875bf03ef8ae33acccf48_ &,_lambda_c7e520e7ba699ee0395251f697dddb81_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014005D180) ----------------------------------------------------
void __fastcall sub_14005D180(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (000000014005D188) ----------------------------------------------------
int __fastcall sub_14005D188(int **a1)
{
  return putch_nolock(**a1);
}

//----- (000000014005D194) ----------------------------------------------------
void __fastcall sub_14005D194(int *a1)
{
  sub_140058810(*a1);
}

//----- (000000014005D290) ----------------------------------------------------
HANDLE sub_14005D290()
{
  HANDLE result; // rax

  result = CreateFileW(L"CONIN$", 0xC0000000, 3u, 0i64, 3u, 0, 0i64);
  hConsoleHandle = result;
  return result;
}

//----- (000000014005D2CC) ----------------------------------------------------
int sub_14005D2CC()
{
  int result; // eax

  result = (_DWORD)hConsoleHandle + 2;
  if ( (unsigned __int64)hConsoleHandle + 2 > 1 )
    return CloseHandle(hConsoleHandle);
  return result;
}

//----- (000000014005D31C) ----------------------------------------------------
//void *sub_14005D31C()
//{
//  return off_140092CF0;
//}
// 140092CF0: using guessed type void *off_140092CF0;

//----- (000000014005D4F0) ----------------------------------------------------
int __fastcall sub_14005D4F0(wint_t a1)
{
  return iswctype(a1, 0x107u);
}

//----- (000000014005D4FC) ----------------------------------------------------
int __fastcall sub_14005D4FC(wint_t a1)
{
  return iswctype(a1, 0x103u);
}

//----- (000000014005D520) ----------------------------------------------------
int __fastcall sub_14005D520(wint_t a1)
{
  return iswctype(a1, 0x20u);
}

//----- (000000014005D590) ----------------------------------------------------
int __fastcall sub_14005D590(wint_t a1)
{
  return iswctype(a1, 0x117u);
}

//----- (000000014005D59C) ----------------------------------------------------
int __fastcall sub_14005D59C(wint_t a1)
{
  return iswctype(a1, 2u);
}

//----- (000000014005D5A8) ----------------------------------------------------
int __fastcall sub_14005D5A8(wint_t a1)
{
  return iswctype(a1, 0x157u);
}

//----- (000000014005D5B4) ----------------------------------------------------
int __fastcall sub_14005D5B4(wint_t a1)
{
  return iswctype(a1, 0x10u);
}

//----- (000000014005D5C0) ----------------------------------------------------
int __fastcall sub_14005D5C0(wint_t a1)
{
  return iswctype(a1, 8u);
}

//----- (000000014005D5CC) ----------------------------------------------------
int __fastcall sub_14005D5CC(wint_t a1)
{
  return iswctype(a1, 1u);
}

//----- (000000014005D5D8) ----------------------------------------------------
int __fastcall sub_14005D5D8(wint_t a1)
{
  return iswctype(a1, 0x80u);
}

//----- (000000014005D628) ----------------------------------------------------
int __fastcall sub_14005D628(wint_t a1)
{
  return iswctype(a1, 0x107u);
}

//----- (000000014005D634) ----------------------------------------------------
int __fastcall sub_14005D634(wint_t a1)
{
  return iswctype(a1, 0x103u);
}

//----- (000000014005D668) ----------------------------------------------------
int __fastcall sub_14005D668(wint_t a1)
{
  return iswctype(a1, 0x20u);
}

//----- (000000014005D674) ----------------------------------------------------
int __fastcall sub_14005D674(wint_t a1)
{
  return iswctype(a1, 4u);
}

//----- (000000014005D680) ----------------------------------------------------
int __fastcall sub_14005D680(wint_t a1)
{
  return iswctype(a1, 0x117u);
}

//----- (000000014005D68C) ----------------------------------------------------
int __fastcall sub_14005D68C(wint_t a1)
{
  return iswctype(a1, 2u);
}

//----- (000000014005D698) ----------------------------------------------------
int __fastcall sub_14005D698(wint_t a1)
{
  return iswctype(a1, 0x157u);
}

//----- (000000014005D6A4) ----------------------------------------------------
int __fastcall sub_14005D6A4(wint_t a1)
{
  return iswctype(a1, 0x10u);
}

//----- (000000014005D6B0) ----------------------------------------------------
int __fastcall sub_14005D6B0(wint_t a1)
{
  return iswctype(a1, 8u);
}

//----- (000000014005D6BC) ----------------------------------------------------
int __fastcall sub_14005D6BC(wint_t a1)
{
  return iswctype(a1, 1u);
}

//----- (000000014005D6C8) ----------------------------------------------------
int __fastcall sub_14005D6C8(wint_t a1)
{
  return iswctype(a1, 0x80u);
}

//----- (000000014005DA70) ----------------------------------------------------
__int64 __fastcall sub_14005DA70(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014005DBF8) ----------------------------------------------------
__int64 __fastcall sub_14005DBF8(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_bfedae4ebbf01fab1bb6dcc6a9e276e0_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_237c231691f317818eb88cc1d5d642d6_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 14005DB84: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_bfedae4ebbf01fab1bb6dcc6a9e276e0_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_237c231691f317818eb88cc1d5d642d6_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014005DC38) ----------------------------------------------------
void __fastcall sub_14005DC38(int *a1)
{
  sub_140065790(*a1);
}

//----- (000000014005DC8C) ----------------------------------------------------
void __fastcall sub_14005DC8C(int *a1)
{
  sub_1400656AC(*a1);
}

//----- (000000014005DD10) ----------------------------------------------------
__int64 __fastcall sub_14005DD10(int a1)
{
  int *v2; // [rsp+20h] [rbp-18h] BYREF
  int v3; // [rsp+40h] [rbp+8h] BYREF
  char v4; // [rsp+48h] [rbp+10h] BYREF
  int v5; // [rsp+50h] [rbp+18h] BYREF
  int v6; // [rsp+58h] [rbp+20h] BYREF

  v3 = a1;
  if ( a1 == -2 )
  {
    *_doserrno() = 0;
    *errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_14009CBB0
      && (*(_BYTE *)(qword_14009C7B0[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6) + 56) & 1) != 0 )
    {
      v5 = a1;
      v6 = a1;
      v2 = &v3;
      return __crt_seh_guarded_call<int>::operator()<_lambda_bfedae4ebbf01fab1bb6dcc6a9e276e0_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_237c231691f317818eb88cc1d5d642d6_>(
               &v4,
               &v6,
               &v2,
               &v5);
    }
    *_doserrno() = 0;
    *errno() = 9;
    invalid_parameter_noinfo();
  }
  return 0xFFFFFFFFi64;
}
// 14005DB84: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_bfedae4ebbf01fab1bb6dcc6a9e276e0_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_237c231691f317818eb88cc1d5d642d6_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 14009C7B0: using guessed type __int64 qword_14009C7B0[128];
// 14009CBB0: using guessed type int dword_14009CBB0;

//----- (000000014005DE70) ----------------------------------------------------
void __fastcall sub_14005DE70(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (000000014005E044) ----------------------------------------------------
void __fastcall sub_14005E044(__int64 *a1)
{
  sub_1400242E4(*a1);
}

//----- (000000014005E748) ----------------------------------------------------
int __fastcall sub_14005E748(const char **a1, const char *a2, size_t *a3)
{
  return strncmp(*a1, a2, *a3);
}

//----- (000000014005E754) ----------------------------------------------------
int __fastcall sub_14005E754(const wchar_t **a1, const wchar_t *a2, size_t *a3)
{
  return wcsncmp(*a1, a2, *a3);
}

//----- (000000014005E760) ----------------------------------------------------
int __fastcall sub_14005E760(const char **a1, const char *a2, size_t *a3)
{
  return strnicmp(*a1, a2, *a3);
}

//----- (000000014005E76C) ----------------------------------------------------
int __fastcall sub_14005E76C(const char **a1, const char *a2, size_t *a3)
{
  return strnicmp(*a1, a2, *a3);
}

//----- (000000014005E778) ----------------------------------------------------
int __fastcall sub_14005E778(const char **a1, const char *a2, size_t *a3)
{
  return strnicmp(*a1, a2, *a3);
}

//----- (000000014005E784) ----------------------------------------------------
int __fastcall sub_14005E784(const wchar_t **a1, const wchar_t *a2, size_t *a3)
{
  return wcsnicmp(*a1, a2, *a3);
}

//----- (000000014005E790) ----------------------------------------------------
int __fastcall sub_14005E790(const wchar_t **a1, const wchar_t *a2, size_t *a3)
{
  return wcsnicmp(*a1, a2, *a3);
}

//----- (000000014005E79C) ----------------------------------------------------
int __fastcall sub_14005E79C(const wchar_t **a1, const wchar_t *a2, size_t *a3)
{
  return wcsnicmp(*a1, a2, *a3);
}

//----- (0000000140061658) ----------------------------------------------------
__int64 __fastcall sub_140061658(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_b521505b218e5242e90febf6bfebc422_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_314360699dd331753a4119843814e9a7_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 1400615CC: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_b521505b218e5242e90febf6bfebc422_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_314360699dd331753a4119843814e9a7_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140061698) ----------------------------------------------------
void __fastcall sub_140061698(int *a1)
{
  sub_140065790(*a1);
}

//----- (000000014006170C) ----------------------------------------------------
void __fastcall sub_14006170C(int *a1)
{
  sub_1400656AC(*a1);
}

//----- (0000000140062404) ----------------------------------------------------
__int64 __fastcall sub_140062404(LPCSTR lpOutputString, __int64 a2, unsigned int a3)
{
  char is_packaged_app; // bp
  unsigned int v7; // edi
  HANDLE Thread; // rax
  void *v10; // rbx
  __int64 parent_window; // rcx
  __int64 Parameter[2]; // [rsp+30h] [rbp-28h] BYREF
  unsigned int v13; // [rsp+40h] [rbp-18h]
  unsigned int v14; // [rsp+44h] [rbp-14h]

  is_packaged_app = _acrt_is_packaged_app();
  v7 = 0;
  if ( IsDebuggerPresent() )
  {
    if ( lpOutputString )
      OutputDebugStringA(lpOutputString);
    if ( is_packaged_app )
      return 4i64;
  }
  if ( !(unsigned __int8)_acrt_can_show_message_box() )
    return (unsigned int)IsDebuggerPresent() + 3;
  if ( is_packaged_app )
  {
    Parameter[0] = a2;
    Parameter[1] = (__int64)lpOutputString;
    v13 = a3;
    v14 = 0;
    Thread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_1400626B4, Parameter, 0, 0i64);
    v10 = Thread;
    if ( Thread != (HANDLE)-1i64 && !WaitForSingleObjectEx(Thread, 0xFFFFFFFF, 0) )
      v7 = v14;
    if ( v10 != (void *)-1i64 )
      CloseHandle(v10);
    return v7;
  }
  else
  {
    if ( (unsigned __int8)_acrt_is_interactive() )
    {
      parent_window = _acrt_get_parent_window();
    }
    else
    {
      a3 |= 0x200000u;
      parent_window = 0i64;
    }
    return sub_140059DF0(parent_window, (__int64)lpOutputString, a2, a3);
  }
}
// 14005A040: using guessed type __int64 _acrt_can_show_message_box(void);
// 14005A0FC: using guessed type __int64 _acrt_get_parent_window(void);
// 14005A1C4: using guessed type __int64 _acrt_is_interactive(void);
// 14005A298: using guessed type __int64 _acrt_is_packaged_app(void);

//----- (0000000140062520) ----------------------------------------------------
__int64 __fastcall sub_140062520(LPCWSTR lpOutputString, __int64 a2, unsigned int a3)
{
  char is_packaged_app; // bp
  unsigned int v7; // edi
  HANDLE Thread; // rax
  void *v10; // rbx
  __int64 parent_window; // rcx
  __int64 Parameter[2]; // [rsp+30h] [rbp-28h] BYREF
  unsigned int v13; // [rsp+40h] [rbp-18h]
  unsigned int v14; // [rsp+44h] [rbp-14h]

  is_packaged_app = _acrt_is_packaged_app();
  v7 = 0;
  if ( IsDebuggerPresent() )
  {
    if ( lpOutputString )
      OutputDebugStringW(lpOutputString);
    if ( is_packaged_app )
      return 4i64;
  }
  if ( !(unsigned __int8)_acrt_can_show_message_box() )
    return (unsigned int)IsDebuggerPresent() + 3;
  if ( is_packaged_app )
  {
    Parameter[0] = a2;
    Parameter[1] = (__int64)lpOutputString;
    v13 = a3;
    v14 = 0;
    Thread = CreateThread(0i64, 0i64, message_box_wait_thread<wchar_t>, Parameter, 0, 0i64);
    v10 = Thread;
    if ( Thread != (HANDLE)-1i64 && !WaitForSingleObjectEx(Thread, 0xFFFFFFFF, 0) )
      v7 = v14;
    if ( v10 != (void *)-1i64 )
      CloseHandle(v10);
    return v7;
  }
  else
  {
    if ( (unsigned __int8)_acrt_is_interactive() )
    {
      parent_window = _acrt_get_parent_window();
    }
    else
    {
      a3 |= 0x200000u;
      parent_window = 0i64;
    }
    return _acrt_MessageBoxW(parent_window, lpOutputString, a2, a3);
  }
}
// 140059E78: using guessed type __int64 __fastcall _acrt_MessageBoxW(_QWORD, _QWORD, _QWORD, _QWORD);
// 14005A040: using guessed type __int64 _acrt_can_show_message_box(void);
// 14005A0FC: using guessed type __int64 _acrt_get_parent_window(void);
// 14005A1C4: using guessed type __int64 _acrt_is_interactive(void);
// 14005A298: using guessed type __int64 _acrt_is_packaged_app(void);

//----- (000000014006263C) ----------------------------------------------------
__int64 __fastcall sub_14006263C(__int64 *a1, __int64 *a2, __int64 *a3, unsigned int *a4)
{
  return sub_140059DF0(*a1, *a2, *a3, *a4);
}

//----- (0000000140062650) ----------------------------------------------------
__int64 __fastcall sub_140062650(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int *a4)
{
  return _acrt_MessageBoxW(*a1, *a2, *a3, *a4);
}
// 140059E78: using guessed type __int64 __fastcall _acrt_MessageBoxW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140062664) ----------------------------------------------------
__int64 __fastcall sub_140062664(__int64 *a1, __int64 *a2, __int64 *a3, unsigned int *a4)
{
  return sub_140059DF0(*a1, *a2, *a3, *a4);
}

//----- (0000000140062678) ----------------------------------------------------
__int64 __fastcall sub_140062678(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int *a4)
{
  return _acrt_MessageBoxW(*a1, *a2, *a3, *a4);
}
// 140059E78: using guessed type __int64 __fastcall _acrt_MessageBoxW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014006268C) ----------------------------------------------------
__int64 __fastcall sub_14006268C(__int64 *a1, __int64 *a2, __int64 *a3, unsigned int *a4)
{
  return sub_140059DF0(*a1, *a2, *a3, *a4);
}

//----- (00000001400626A0) ----------------------------------------------------
__int64 __fastcall sub_1400626A0(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int *a4)
{
  return _acrt_MessageBoxW(*a1, *a2, *a3, *a4);
}
// 140059E78: using guessed type __int64 __fastcall _acrt_MessageBoxW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400626B4) ----------------------------------------------------
__int64 __fastcall sub_1400626B4(LPVOID lpThreadParameter)
{
  *((_DWORD *)lpThreadParameter + 5) = sub_140059DF0(
                                         0i64,
                                         *((_QWORD *)lpThreadParameter + 1),
                                         *(_QWORD *)lpThreadParameter,
                                         *((_DWORD *)lpThreadParameter + 4));
  return 0i64;
}

//----- (0000000140062704) ----------------------------------------------------
void __fastcall sub_140062704(LPCSTR *a1)
{
  OutputDebugStringA(*a1);
}

//----- (0000000140062710) ----------------------------------------------------
void __fastcall sub_140062710(LPCWSTR *a1)
{
  OutputDebugStringW(*a1);
}

//----- (0000000140062774) ----------------------------------------------------
bool __fastcall sub_140062774(void *a1)
{
  return CloseHandle(a1);
}

//----- (0000000140062788) ----------------------------------------------------
__int64 __fastcall sub_140062788(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014006279C) ----------------------------------------------------
__int64 __fastcall sub_14006279C(LPCSTR lpOutputString, __int64 a2, unsigned int a3)
{
  char is_packaged_app; // bp
  unsigned int v7; // edi
  HANDLE Thread; // rax
  void *v9; // rbx
  __int64 parent_window; // rcx
  __int64 Parameter[2]; // [rsp+30h] [rbp-28h] BYREF
  unsigned int v13; // [rsp+40h] [rbp-18h]
  unsigned int v14; // [rsp+44h] [rbp-14h]

  is_packaged_app = _acrt_is_packaged_app();
  v7 = 0;
  if ( !IsDebuggerPresent() )
    goto LABEL_20;
  if ( lpOutputString )
    OutputDebugStringA(lpOutputString);
  if ( is_packaged_app )
  {
    return 4;
  }
  else
  {
LABEL_20:
    if ( (unsigned __int8)_acrt_can_show_message_box() )
    {
      if ( is_packaged_app )
      {
        Parameter[0] = a2;
        Parameter[1] = (__int64)lpOutputString;
        v13 = a3;
        v14 = 0;
        Thread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_1400626B4, Parameter, 0, 0i64);
        v9 = Thread;
        if ( Thread != (HANDLE)-1i64 )
        {
          if ( !WaitForSingleObjectEx(Thread, 0xFFFFFFFF, 0) )
            v7 = v14;
          CloseHandle(v9);
        }
      }
      else
      {
        if ( (unsigned __int8)_acrt_is_interactive() )
        {
          parent_window = _acrt_get_parent_window();
        }
        else
        {
          a3 |= 0x200000u;
          parent_window = 0i64;
        }
        return (unsigned int)sub_140059DF0(parent_window, (__int64)lpOutputString, a2, a3);
      }
    }
    else
    {
      return (unsigned int)IsDebuggerPresent() + 3;
    }
  }
  return v7;
}
// 14005A040: using guessed type __int64 _acrt_can_show_message_box(void);
// 14005A0FC: using guessed type __int64 _acrt_get_parent_window(void);
// 14005A1C4: using guessed type __int64 _acrt_is_interactive(void);
// 14005A298: using guessed type __int64 _acrt_is_packaged_app(void);

//----- (00000001400628B8) ----------------------------------------------------
__int64 __fastcall sub_1400628B8(LPCWSTR lpOutputString, __int64 a2, unsigned int a3)
{
  char is_packaged_app; // bp
  unsigned int v7; // edi
  HANDLE Thread; // rax
  void *v9; // rbx
  __int64 parent_window; // rcx
  __int64 Parameter[2]; // [rsp+30h] [rbp-28h] BYREF
  unsigned int v13; // [rsp+40h] [rbp-18h]
  unsigned int v14; // [rsp+44h] [rbp-14h]

  is_packaged_app = _acrt_is_packaged_app();
  v7 = 0;
  if ( !IsDebuggerPresent() )
    goto LABEL_20;
  if ( lpOutputString )
    OutputDebugStringW(lpOutputString);
  if ( is_packaged_app )
  {
    return 4;
  }
  else
  {
LABEL_20:
    if ( (unsigned __int8)_acrt_can_show_message_box() )
    {
      if ( is_packaged_app )
      {
        Parameter[0] = a2;
        Parameter[1] = (__int64)lpOutputString;
        v13 = a3;
        v14 = 0;
        Thread = CreateThread(0i64, 0i64, message_box_wait_thread<wchar_t>, Parameter, 0, 0i64);
        v9 = Thread;
        if ( Thread != (HANDLE)-1i64 )
        {
          if ( !WaitForSingleObjectEx(Thread, 0xFFFFFFFF, 0) )
            v7 = v14;
          CloseHandle(v9);
        }
      }
      else
      {
        if ( (unsigned __int8)_acrt_is_interactive() )
        {
          parent_window = _acrt_get_parent_window();
        }
        else
        {
          a3 |= 0x200000u;
          parent_window = 0i64;
        }
        return (unsigned int)_acrt_MessageBoxW(parent_window, lpOutputString, a2, a3);
      }
    }
    else
    {
      return (unsigned int)IsDebuggerPresent() + 3;
    }
  }
  return v7;
}
// 140059E78: using guessed type __int64 __fastcall _acrt_MessageBoxW(_QWORD, _QWORD, _QWORD, _QWORD);
// 14005A040: using guessed type __int64 _acrt_can_show_message_box(void);
// 14005A0FC: using guessed type __int64 _acrt_get_parent_window(void);
// 14005A1C4: using guessed type __int64 _acrt_is_interactive(void);
// 14005A298: using guessed type __int64 _acrt_is_packaged_app(void);

//----- (00000001400633B8) ----------------------------------------------------
HANDLE __fastcall sub_1400633B8(
        LPCSTR *a1,
        FINDEX_INFO_LEVELS *a2,
        LPVOID *a3,
        FINDEX_SEARCH_OPS *a4,
        LPVOID *a5,
        DWORD *a6)
{
  return FindFirstFileExA(*a1, *a2, *a3, *a4, *a5, *a6);
}

//----- (00000001400633E4) ----------------------------------------------------
HANDLE __fastcall sub_1400633E4(
        LPCWSTR *a1,
        FINDEX_INFO_LEVELS *a2,
        LPVOID *a3,
        FINDEX_SEARCH_OPS *a4,
        LPVOID *a5,
        DWORD *a6)
{
  return FindFirstFileExW(*a1, *a2, *a3, *a4, *a5, *a6);
}

//----- (0000000140063410) ----------------------------------------------------
BOOL __fastcall sub_140063410(HANDLE *a1, LPWIN32_FIND_DATAA *a2)
{
  return FindNextFileA(*a1, *a2);
}

//----- (0000000140063420) ----------------------------------------------------
BOOL __fastcall sub_140063420(HANDLE *a1, LPWIN32_FIND_DATAW *a2)
{
  return FindNextFileW(*a1, *a2);
}

//----- (0000000140063430) ----------------------------------------------------
errno_t __fastcall sub_140063430(char **a1, rsize_t *a2, const char **a3, rsize_t *a4)
{
  return strncpy_s(*a1, *a2, *a3, *a4);
}

//----- (0000000140063444) ----------------------------------------------------
errno_t __fastcall sub_140063444(wchar_t **a1, rsize_t *a2, const wchar_t **a3, rsize_t *a4)
{
  return wcsncpy_s(*a1, *a2, *a3, *a4);
}

//----- (0000000140063458) ----------------------------------------------------
errno_t __fastcall sub_140063458(char **a1, rsize_t *a2, const char **a3, rsize_t *a4)
{
  return strncpy_s(*a1, *a2, *a3, *a4);
}

//----- (000000014006346C) ----------------------------------------------------
errno_t __fastcall sub_14006346C(char **a1, rsize_t *a2, const char **a3, rsize_t *a4)
{
  return strncpy_s(*a1, *a2, *a3, *a4);
}

//----- (0000000140063480) ----------------------------------------------------
errno_t __fastcall sub_140063480(wchar_t **a1, rsize_t *a2, const wchar_t **a3, rsize_t *a4)
{
  return wcsncpy_s(*a1, *a2, *a3, *a4);
}

//----- (0000000140063494) ----------------------------------------------------
errno_t __fastcall sub_140063494(wchar_t **a1, rsize_t *a2, const wchar_t **a3, rsize_t *a4)
{
  return wcsncpy_s(*a1, *a2, *a3, *a4);
}

//----- (00000001400634A8) ----------------------------------------------------
__int64 __fastcall sub_1400634A8(_QWORD *a1)
{
  return unknown_libname_917(*a1);
}
// 14006E47C: using guessed type __int64 __fastcall unknown_libname_917(_QWORD);

//----- (00000001400634B0) ----------------------------------------------------
wchar_t *__fastcall sub_1400634B0(const wchar_t **a1, const wchar_t *a2)
{
  return wcspbrk(*a1, a2);
}

//----- (0000000140063584) ----------------------------------------------------
int (__cdecl *sub_140063584())(const void *, const void *)
{
  return CompareFunction;
}

//----- (000000014006358C) ----------------------------------------------------
int (__cdecl *sub_14006358C())(const void *, const void *)
{
  return unknown_libname_870;
}

//----- (00000001400635DC) ----------------------------------------------------
__int64 __fastcall sub_1400635DC(__int64 a1, void *a2)
{
  unsigned int v4; // esi

  v4 = unknown_libname_877();
  if ( v4 )
  {
    free_base(a2);
    return v4;
  }
  else
  {
    **(_QWORD **)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 8) += 8i64;
    return 0i64;
  }
}
// 1400636C4: using guessed type __int64 unknown_libname_877(void);

//----- (0000000140063628) ----------------------------------------------------
__int64 __fastcall sub_140063628(__int64 a1, void *a2)
{
  unsigned int v4; // esi

  v4 = unknown_libname_878();
  if ( v4 )
  {
    free_base(a2);
    return v4;
  }
  else
  {
    **(_QWORD **)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 8) += 8i64;
    return 0i64;
  }
}
// 14006378C: using guessed type __int64 unknown_libname_878(void);

//----- (0000000140063674) ----------------------------------------------------
__int64 __fastcall sub_140063674(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140063678) ----------------------------------------------------
__int64 __fastcall sub_140063678(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001400636A0) ----------------------------------------------------
bool __fastcall sub_1400636A0(void *a1)
{
  return FindClose(a1);
}

//----- (0000000140063854) ----------------------------------------------------
__int64 __fastcall sub_140063854(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140063868) ----------------------------------------------------
__int64 __fastcall sub_140063868(__int64 a1, __int64 a2)
{
  return a2 - 2;
}

//----- (00000001400638E0) ----------------------------------------------------
__int64 __fastcall sub_1400638E0(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_99476a1ad63dd22509b5d3e65b0ffc95_,_lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c_ &,_lambda_f7424dd8d45958661754dc4f2697e9c3_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 1400638A8: using guessed type __int64 __fastcall __crt_seh_guarded_call<void>::operator()<_lambda_99476a1ad63dd22509b5d3e65b0ffc95_,_lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c_ &,_lambda_f7424dd8d45958661754dc4f2697e9c3_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140063920) ----------------------------------------------------
void __fastcall sub_140063920(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140063B40) ----------------------------------------------------
void __fastcall sub_140063B40(int *a1)
{
  sub_140058810(*a1);
}

//----- (0000000140064118) ----------------------------------------------------
void *sub_140064118()
{
  return &unk_140093240;
}

//----- (0000000140064120) ----------------------------------------------------
void *sub_140064120()
{
  return &unk_140093130;
}

//----- (00000001400647C0) ----------------------------------------------------
char sub_1400647C0()
{
  return 1;
}

//----- (00000001400647C4) ----------------------------------------------------
int *sub_1400647C4()
{
  return &dword_14009CBFC;
}
// 14009CBFC: using guessed type int dword_14009CBFC;

//----- (00000001400647CC) ----------------------------------------------------
void **sub_1400647CC()
{
  return &qword_14009CC00;
}

//----- (00000001400647D4) ----------------------------------------------------
void **sub_1400647D4()
{
  return &qword_14009CC08;
}

//----- (00000001400647DC) ----------------------------------------------------
__int64 *sub_1400647DC()
{
  return &qword_14009CC10;
}
// 14009CC10: using guessed type __int64 qword_14009CC10;

//----- (00000001400647E4) ----------------------------------------------------
__int64 *sub_1400647E4()
{
  return &qword_14009CC20;
}
// 14009CC20: using guessed type __int64 qword_14009CC20;

//----- (00000001400647EC) ----------------------------------------------------
__int64 *sub_1400647EC()
{
  return &qword_14009CC18;
}
// 14009CC18: using guessed type __int64 qword_14009CC18;

//----- (00000001400647F4) ----------------------------------------------------
__int64 *sub_1400647F4()
{
  return &qword_14009CC28;
}
// 14009CC28: using guessed type __int64 qword_14009CC28;

//----- (00000001400647FC) ----------------------------------------------------
__int64 __fastcall sub_1400647FC(_QWORD *a1)
{
  if ( a1 && qword_14009CC20 )
  {
    *a1 = qword_14009CC20;
    return 0i64;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 22i64;
  }
}
// 14009CC20: using guessed type __int64 qword_14009CC20;

//----- (0000000140064834) ----------------------------------------------------
__int64 __fastcall sub_140064834(_QWORD *a1)
{
  if ( a1 && qword_14009CC28 )
  {
    *a1 = qword_14009CC28;
    return 0i64;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 22i64;
  }
}
// 14009CC28: using guessed type __int64 qword_14009CC28;

//----- (0000000140064900) ----------------------------------------------------
__int64 __fastcall sub_140064900(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140065390) ----------------------------------------------------
BOOL __fastcall sub_140065390(LPCSTR *a1, LPCSTR *a2)
{
  return SetEnvironmentVariableA(*a1, *a2);
}

//----- (00000001400653A0) ----------------------------------------------------
BOOL __fastcall sub_1400653A0(LPCWSTR *a1, LPCWSTR *a2)
{
  return SetEnvironmentVariableW(*a1, *a2);
}

//----- (00000001400653C8) ----------------------------------------------------
errno_t __fastcall sub_1400653C8(char **a1, rsize_t *a2, const char **a3)
{
  return strcpy_s(*a1, *a2, *a3);
}

//----- (00000001400653D8) ----------------------------------------------------
errno_t __fastcall sub_1400653D8(wchar_t **a1, rsize_t *a2, const wchar_t **a3)
{
  return wcscpy_s(*a1, *a2, *a3);
}

//----- (00000001400653E8) ----------------------------------------------------
errno_t __fastcall sub_1400653E8(char **a1, rsize_t *a2, const char **a3)
{
  return strcpy_s(*a1, *a2, *a3);
}

//----- (00000001400653F8) ----------------------------------------------------
errno_t __fastcall sub_1400653F8(wchar_t **a1, rsize_t *a2, const wchar_t **a3)
{
  return wcscpy_s(*a1, *a2, *a3);
}

//----- (0000000140065430) ----------------------------------------------------
int __fastcall sub_140065430(const char **a1, const char **a2, size_t *a3)
{
  return strnicoll(*a1, *a2, *a3);
}

//----- (0000000140065440) ----------------------------------------------------
int __fastcall sub_140065440(const wchar_t **a1, const wchar_t **a2, size_t *a3)
{
  return wcsnicoll(*a1, *a2, *a3);
}

//----- (0000000140065450) ----------------------------------------------------
void **sub_140065450()
{
  return &qword_14009C370;
}

//----- (0000000140065458) ----------------------------------------------------
void **sub_140065458()
{
  return &qword_14009C378;
}

//----- (0000000140065460) ----------------------------------------------------
void **sub_140065460()
{
  return &qword_14009C388;
}

//----- (0000000140065468) ----------------------------------------------------
void **sub_140065468()
{
  return &qword_14009C380;
}

//----- (0000000140065470) ----------------------------------------------------
void **sub_140065470()
{
  return &qword_14009C370;
}

//----- (0000000140065478) ----------------------------------------------------
void **sub_140065478()
{
  return &qword_14009C378;
}

//----- (00000001400654A0) ----------------------------------------------------
void __fastcall sub_1400654A0(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (00000001400654E0) ----------------------------------------------------
__int64 __fastcall sub_1400654E0(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001400656AC) ----------------------------------------------------
void __fastcall sub_1400656AC(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(qword_14009C7B0[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6)));
}
// 14009C7B0: using guessed type __int64 qword_14009C7B0[128];

//----- (0000000140065790) ----------------------------------------------------
void __fastcall sub_140065790(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(qword_14009C7B0[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6)));
}
// 14009C7B0: using guessed type __int64 qword_14009C7B0[128];

//----- (0000000140065B14) ----------------------------------------------------
int *sub_140065B14()
{
  return &dword_14009CC30;
}
// 14009CC30: using guessed type int dword_14009CC30;

//----- (0000000140065B1C) ----------------------------------------------------
void __fastcall sub_140065B1C(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140065B24) ----------------------------------------------------
void __fastcall sub_140065B24(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140066CBC) ----------------------------------------------------
void __fastcall sub_140066CBC(__int64 a1, void *a2)
{
  free_base(a2);
}

//----- (0000000140066CC4) ----------------------------------------------------
void __fastcall sub_140066CC4(const void **a1)
{
  free_crt_array_internal(a1, 2ui64);
}

//----- (0000000140066CD0) ----------------------------------------------------
void __fastcall sub_140066CD0(const void **a1)
{
  free_crt_array_internal(a1, 7ui64);
}

//----- (0000000140066CDC) ----------------------------------------------------
void __fastcall sub_140066CDC(const void **a1)
{
  free_crt_array_internal(a1, 0xCui64);
}

//----- (0000000140066CE8) ----------------------------------------------------
void __fastcall sub_140066CE8(const void **a1)
{
  free_crt_array_internal(a1, 2ui64);
}

//----- (0000000140066CF4) ----------------------------------------------------
void __fastcall sub_140066CF4(const void **a1)
{
  free_crt_array_internal(a1, 7ui64);
}

//----- (0000000140066D00) ----------------------------------------------------
void __fastcall sub_140066D00(const void **a1)
{
  free_crt_array_internal(a1, 0xCui64);
}

//----- (0000000140066D9C) ----------------------------------------------------
__int64 __fastcall sub_140066D9C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140069098) ----------------------------------------------------
HANDLE sub_140069098()
{
  return hHeap;
}

//----- (00000001400690BC) ----------------------------------------------------
char sub_1400690BC()
{
  hHeap = 0i64;
  return 1;
}

//----- (00000001400690C8) ----------------------------------------------------
HANDLE sub_1400690C8()
{
  return hHeap;
}

//----- (0000000140069260) ----------------------------------------------------
__int64 __fastcall sub_140069260(__int64 a1)
{
  return a1;
}

//----- (0000000140069264) ----------------------------------------------------
void __fastcall sub_140069264(__int64 a1)
{
  qword_14009CC48 = a1;
}
// 14009CC48: using guessed type __int64 qword_14009CC48;

//----- (00000001400693A0) ----------------------------------------------------
__int64 __fastcall sub_1400693A0(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<void (*)(int)>::operator()<_lambda_c36588078e9f5dfd39652860aa6b3aaf_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_dc9d2797ccde5d239b4a0efae8ebd7db_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 140069358: using guessed type __int64 __fastcall __crt_seh_guarded_call<void (*)(int)>::operator()<_lambda_c36588078e9f5dfd39652860aa6b3aaf_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_dc9d2797ccde5d239b4a0efae8ebd7db_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140069410) ----------------------------------------------------
void __fastcall sub_140069410(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (0000000140069418) ----------------------------------------------------
void __fastcall sub_140069418(int *a1)
{
  sub_140058810(*a1);
}

//----- (00000001400695A0) ----------------------------------------------------
__int64 __fastcall sub_1400695A0(__int64 a1)
{
  return a1;
}

//----- (000000014006C5CC) ----------------------------------------------------
__int64 __fastcall sub_14006C5CC(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<unsigned short>::operator()<_lambda_9fda798407f8391327e99fec20084266_,_lambda_6e3e78bb6855d1e4040e022c1b427e22_ &,_lambda_5d54a80e00f5dcce6acfc22736ebf0cf_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 14006C58C: using guessed type __int64 __fastcall __crt_seh_guarded_call<unsigned short>::operator()<_lambda_9fda798407f8391327e99fec20084266_,_lambda_6e3e78bb6855d1e4040e022c1b427e22_ &,_lambda_5d54a80e00f5dcce6acfc22736ebf0cf_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014006C60C) ----------------------------------------------------
void __fastcall sub_14006C60C(int *a1)
{
  sub_140058810(*a1);
}

//----- (000000014006C620) ----------------------------------------------------
void __fastcall sub_14006C620(int *a1)
{
  sub_1400587BC(*a1);
}

//----- (000000014006DDE8) ----------------------------------------------------
__int64 __fastcall sub_14006DDE8(unsigned int a1)
{
  return a1;
}

//----- (000000014006FBBC) ----------------------------------------------------
HANDLE sub_14006FBBC()
{
  HANDLE result; // rax

  result = CreateFileW(L"CONOUT$", 0x40000000u, 3u, 0i64, 3u, 0, 0i64);
  hConsoleOutput = result;
  return result;
}

//----- (000000014006FBF8) ----------------------------------------------------
int sub_14006FBF8()
{
  int result; // eax

  result = (_DWORD)hConsoleOutput + 2;
  if ( (unsigned __int64)hConsoleOutput + 2 > 1 )
    return CloseHandle(hConsoleOutput);
  return result;
}

//----- (000000014006FE90) ----------------------------------------------------
__int64 __fastcall sub_14006FE90(int a1, __int64 a2)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  int v4; // [rsp+40h] [rbp+18h] BYREF
  int v5; // [rsp+48h] [rbp+20h] BYREF

  v4 = a1;
  v5 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_702c71755a341b84ce26a812eea27a9e_,_lambda_1cffa78e445b1da5fba1a2e0e533226f_ &,_lambda_77b15b24eaa4cf6d702b2f4e7ca8df95_>(
           &v3,
           &v5,
           a2,
           &v4);
}
// 14006FE18: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_702c71755a341b84ce26a812eea27a9e_,_lambda_1cffa78e445b1da5fba1a2e0e533226f_ &,_lambda_77b15b24eaa4cf6d702b2f4e7ca8df95_>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014006FF28) ----------------------------------------------------
void __fastcall sub_14006FF28(int *a1)
{
  sub_1400656AC(*a1);
}

//----- (000000014006FF30) ----------------------------------------------------
void __fastcall sub_14006FF30(int *a1)
{
  sub_140065790(*a1);
}

//----- (0000000140070344) ----------------------------------------------------
__int64 sub_140070344()
{
  return set_fpsr(8064i64);
}
// 140070730: using guessed type __int64 __fastcall set_fpsr(_QWORD);

//----- (0000000140071070) ----------------------------------------------------
__int64 sub_140071070()
{
  return (unsigned int)dword_14009CC80;
}
// 14009CC80: using guessed type int dword_14009CC80;

//----- (0000000140072170) ----------------------------------------------------
void **__fastcall sub_140072170(_QWORD *a1)
{
  void **result; // rax

  result = &type_info::`vftable';
  *a1 = &type_info::`vftable';
  return result;
}
// 140087890: using guessed type void *type_info::`vftable';

//----- (000000014007217C) ----------------------------------------------------
_QWORD *__fastcall sub_14007217C(_QWORD *a1, char a2)
{
  *a1 = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_j__free_base_0(a1);
  return a1;
}
// 140087890: using guessed type void *type_info::`vftable';

// nfuncs=3337 queued=868 decompiled=868 lumina nreq=0 worse=0 better=0
// ALL OK, 868 function(s) have been successfully decompiled
